## Custom lattice types

It is quite likely that you will need more types of lattices than this package provides by default. In such cases you need to define a new type. Follow these steps:

**Create an exact alias**

Select a `Symbol` that will be the LatticeSym for this type and define an alias for the `Lattice{LatticeSym, N, NB}` type. The alias must not have any type parameters except for the dimension count if needed:

```julia
const HoneycombLattice = Lattice{:honeycomb, 2, 2}
const SquareLattice{N} = Lattice{:square, N, 1}
```

**Define the constructor**

The only positional arguments allowed are the macrocell size.[^1] The [`Bravais`](@ref) object must be generated in the constructor and passed to the default constructor `Lattice(sym, sz, bvs)`.

[^1]: This is done with purpose to achieve code consistency. Also in-place sublattice generation will almost certainly be broken. Use keyword arguments if you need additional parameters for some lattice type.

Let us define our own lattice type:
```@example env
const GrapheneLattice = Lattice{:graphene, 3, 2}
function GrapheneLattice(sz::Vararg{Int, 3})
    bvs = Bravais([1 1/2 0; 0 √3/2 0; 0 0 2], [0 1/2; 0 √3/6; 0 0])
    Lattice(:graphene, sz, bvs)
end
nothing # hide
```

A sublattice constructor will be generated by default:

```@example env
gl = GrapheneLattice(6, 6, 3) do (x, y, z)
    7 < x * √3 + y < 18
end
plot(gl, pretty=false)
```

!!! warning
    Please note that if the type alias is dimension-parametric, you must define the constructor *for a concrete type*, otherwise you will almost definitely break the lattice constructor dispatch:
    ```julia
    SquareLattice(sz::Vararg{Int, N}) where N = ...     # Wrong!
    SquareLattice{N}(sz::Vararg{Int, N}) where N = ...  # Correct
    ```
    In the second example `SquareLattice(sz::Vararg{Int, N}) where N` constructor will be generated automatically.

!!! danger "Outdated docs"
    All information below is outdated and does not refer to the current functionality of the package.

## `AbstractGraph` API

A AbstractGraph, as described in the [Pair selectors](@ref Pair-selectors) paragraph, is a lambda-like object. 
Actually, everything that differs is a built-in sanity check algorithm ensuring that the lattice it is used on is a subset of the lattice it was defined on.

To implement this interface, you must inherit the `LatticeModels.AbstractGraph` class and define two methods:
- `LatticeModels.lattice(::YourSelector)` must return the lattice your selector was defined on.
- `LatticeModels.match(::YourSelector, site1::LatticeSite, site2::LatticeSite)` must return whether the `(site1, site2)` pair is *selected*.

Let's take a look at the built-in `DomainsSelector`:

```julia
struct DomainsSelector <: LatticeModels.AbstractAbstractGraph
    domains::LatticeValue
end
LatticeModels.lattice(ps::DomainsSelector) = lattice(ps.domains)
LatticeModels.match(ps::DomainsSelector, site1::LatticeSite, site2::LatticeSite) =
    ps.domains[site1] == ps.domains[site2]
```

It's quite likely though that the built-in `AbstractGraph`s will cover all your needs:
- [`DomainsSelector`](@ref) can split your lattice into different domains: pass a `LatticeValue` and the pair will be *selected*
  only if the values on both sites match.
- [`PairLhsGraph`](@ref) takes a boolean-typed `LatticeValue` and *selects* a site pair only if the value on the first site of the pair is true. Can be useful for creating a slit in the lattice sample.
- [`PairRhsGraph`](@ref) is the same as previous, but selects pairs by the second site of the pair.
- [`PairSet`](@ref LatticeModels.PairSet) is an arbitrary set of site pairs - you can generate one by yourself or use the [`bonds`](@ref) function.
- You may also find the [`pairs_by_distance`](@ref) function useful: it is not a `AbstractGraph` because it is lattice-independent, but you may find it convenient if you want to *select* site pairs depending on the distance between the sites in the pair.

## Custom magnetic fields

You can induce magnetic field by setting the vector potential $\overrightarrow{A}$ in every point of the space.
This can be done by creating an `AbstractField` object: this is a lazy object that stores information about the magnetic field
and implements the [`LatticeModels.vector_potential`](@ref) function that calculates the above-mentioned vector potential.

The $\int_{r_1}^{r_2} \overrightarrow{A} \cdot \overrightarrow{dl}$ integral is found automatically with the [`LatticeModels.line_integral`](@ref) function.
The number of steps can be adjusted, but it is recommended to redefine this method for each new magnetic field type using an exact formula: this will improve performance and accuracy in most cases.

You can use a convenience macro to simplify definition of new field types:

```julia
@field_def struct LandauField(B::Number=1)
    # Define the vector potential function
    vector_potential(x) = (0, x*B)

    # Redefine the integrating function
    line_integral(p1, p2) = ((p1[1] + p2[1]) / 2) * (p2[2] - p1[2]) * B
end
```

Let's see what happened here. 
This macro created a new struct `LandauField <: AbstractField` with only one field `B::Number` and a constructor `LandauField(B::Number=1)`.

It also defined a suitable `LatticeModels.vector_potential` function. The only parameter in this function definition is `x`, which will be the X coordinate of the point (all other coordinate values will not be passed). 
The return type must be `Tuple` or `SVector` to ensure that it can be converted to `SVector` by the default `LatticeModels.line_integral` implementation.

This field object is compatible with lattices of any dimension count. Undefined elements of the $\overrightarrow{A}$ vector will be set to zero, and "excessive" ones will be discarded.

!!! tip
    To handle dimension-dependent behavior, you can use `vector_potential(p...) = (0, p[1]*B)` notation.
    Here `p` is a `SVector` which will allow you to yield different values depending on the dimension count.

You may notice that here the `LatticeModels.line_integral` function was also redefined. It simply takes two `SVector`s describing the coordinates of $p_1$ and $p_2$ and returns the value of the $\int_{p_1}^{p_2} \overrightarrow{A} \cdot \overrightarrow{dl}$ path integral between them.

!!! tip
    To control the accuracy and performance of the integration without redefining `LatticeModels.line_integral`, 
    set the default number of integration steps by adding `n_steps := <desired number>` to the struct definition.

## Custom array backends

You can freely change the type of underlying arrays in `LatticeArray`s by using the [`@on_lattice`](@ref) macro.
It will convert the internal array to the desired type and wrap it with the same `Basis`:

```@repl
using LatticeModels # hide
X, Y = coord_operators(SquareLattice(50, 50), 2)
XY = X * Y
using SparseArrays
sp_XY = @on_lattice sparse(XY)
```

In this example the `@on_lattice` macro transformed the call to `sparse` so that the internal array was passed to it, 
and its output was wrapped into a `LatticeArray`. Thus, `sp_XY` here is an operator on a sparse matrix, but equal to `XY`. 

Same way, you can send `LatticeArray`s to your GPU by calling `@on_lattice cu(XY)` from [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl).
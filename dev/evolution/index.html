<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unitary evolution · LatticeModels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LatticeModels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Advanced options</span><ul><li><a class="tocitem" href="../lattice/">Defining a lattice</a></li><li><a class="tocitem" href="../lattice_values/">Lattice values</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li class="is-active"><a class="tocitem" href>Unitary evolution</a><ul class="internal"><li><a class="tocitem" href="#The-evolution-macro"><span>The evolution macro</span></a></li><li><a class="tocitem" href="#Time-sequences"><span>Time sequences</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced options</a></li><li class="is-active"><a href>Unitary evolution</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Unitary evolution</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/evolution.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><div class="admonition is-danger"><header class="admonition-header">Outdated docs</header><div class="admonition-body"><p>This part of the documentation is outdated and does not refer to the current functionality of the package.</p></div></div><p>We often  want to study the behavior of some quantum system in time-dependent conditions. We can use the unitary evolution operator to describe how the density matrix depends on time:</p><p class="math-container">\[\mathcal{U}(t) = T\left\{ e^{\frac{1}{i\hbar} \int_{t_0}^t \hat{H}(\tau) d\tau} \right\},\hspace{0.5cm}
\mathcal{P}(t) = \mathcal{U}(t) \mathcal{P}_0 \mathcal{U}^\dagger (t)\]</p><h2 id="The-evolution-macro"><a class="docs-heading-anchor" href="#The-evolution-macro">The evolution macro</a><a id="The-evolution-macro-1"></a><a class="docs-heading-anchor-permalink" href="#The-evolution-macro" title="Permalink"></a></h2><p>This macro can be quite useful if your hamiltonian depends on time or if there are multiple Hamiltonians in your experiment. It avoids excessive computation in several cases automatically:</p><ul><li>If the hamiltonian does not change, the <span>$\mathcal{U}(t, dt)$</span> operator will not be re-evaluated.</li><li>If several wavefunctions or density matrices evolve using the same hamiltonian, neither the hamiltonian nor the evolution operator matrix will be re-evaluated.</li></ul><p>Let us define a function that generates a Chern insulator hamiltonian:</p><pre><code class="language- hljs">using LatticeModels, Plots
σ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]
Chern(l, B) = @hamiltonian begin
    lattice := l
    field := LandauField(B)
    dims_internal := 2
    @diag σ[3]
    @hop axis=1 (σ[3] - im * σ[1]) / 2
    @hop axis=2 (σ[3] - im * σ[2]) / 2
end
nothing # hide</code></pre><p>The <a href="../library/#LatticeModels.@evolution-Tuple"><code>@evolution</code></a> macro creates a scope where the hamiltonian and wavefunctions (or density matrices) are evaluated for the given time interval.  It takes two arguments: a braced list with evolution specifiers and a for-loop that iterates over the time interval:</p><pre><code class="language- hljs">l = SquareLattice(10, 10)
τ = 30
a = Animation()
B = 0.01
P0 = densitymatrix(diagonalize(qwz(l, 0)))

@evolution {
    H := Chern(l, B * min(t, τ) / τ),
    P0 --&gt; H --&gt; P
} for t in 0:0.1:2τ
    cur = DensityCurrents(H, P)
    heatmap(site_density(P), title=&quot;Local density, t = $t&quot;, clims=(0.9, 1.1))
    plot!(cur, arrows_scale=20, color=:blue)
    frame(a)
end
gif(a, &quot;animation.gif&quot;)</code></pre><p>Let us make it clear what an evolution specifier is. In fact, there are two possible variants:</p><ul><li><p>It is an <em>evolution rule</em> describing the initial state, the hamiltonian it will evolve accroding to, and the name of the variable to write the result. These three arguments must be written in a chain delimited by <code>--&gt;</code> like this: </p><p><code>P0 --&gt; Chern(l, B * min(t, τ) / τ) --&gt; P</code></p><p>Note that you can use a hamiltonian alias instead of an expression if it was previously defined.</p></li><li><p>It is an <em>alias declaration</em>, which means that a certain expression will be evaluated on every iteration and assigned to a variable with a given name. For example, <code>H := Chern(l, B * min(t, τ) / τ)</code> evaluates the Chern insulator hamiltonian and writes the result to the <code>H</code> variable.</p></li></ul><h3 id="Compatibility"><a class="docs-heading-anchor" href="#Compatibility">Compatibility</a><a id="Compatibility-1"></a><a class="docs-heading-anchor-permalink" href="#Compatibility" title="Permalink"></a></h3><p>This macro is designed to be compatible with arbitrary array types. This means that hamiltonian expressions or initial states needn&#39;t to be <code>LatticeArray</code>s, but they can be of any array type instead, as long as it supports linear algebra operations such as matrix multiplication.</p><p>Here are the functions that must be defined for the desired array type:</p><ul><li>Equality operator: <code>==</code></li><li>Basic arithmetic functions: <code>+</code>, <code>-</code>, <code>*</code>, <code>adjoint</code></li><li>The identity matrix <code>one(A)</code></li><li>The matrix exponent <code>exp(A)</code><ul><li>If it is not possible to implement this function you can set the <code>k</code> keyword argument (see below) to calculate the matrix exponent as a partial sum of Taylor series.</li></ul></li><li>If the inverse matrix <code>inv(A)</code> function is defined, you can use the Padé approximant for the matrix exponent, which is generally more accurate.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If you use <code>LatticeArray</code>s, you still have to make sure these functions and operators are defined for the underlying array type.</p></div></div><h3 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h3><p>The evolution macro avoids calculations where possible to improve performance. It is important to know how it achieves this result:</p><ul><li>If the hamiltonian matrix has not changed between two iterations and the time step remained approximately the same, <span>$\mathcal{U}(t, dt)$</span> will not be re-evaluated, because the matrix exponent is the most time-consuming operation compared to others like matrix multiplication or addition.<ul><li>The relative tolerance used to check if the time step has changed can be set via <code>rtol</code> keyword.</li></ul></li><li>If the hamiltonian expression does not explicitly depend on the loop variable (<code>t</code> in the example), it will be considered constant and evaluated only once at the beginning. Otherwise it will be evaluated on every iteration in the loop scope.</li><li>If several states evolve according to the same hamiltonian, both the hamiltonian and the <span>$\mathcal{U}(t, dt)$</span> evolution operator will be evaluated only once per iteration.</li></ul><p>To improve performance with small time intervals you can calculate the matrix exponent as a Taylor polynomial. Its order can be set via <code>k</code> keyword.</p><p>For more precise calculation add <code>pade=true</code> - this will enable matrix exponent calculation via Padé approximant. Note that this formula requires finding an inverse matrix, so this option is not compatible with sparse matrices.</p><p>By default the macro shows a progress informer that shows the task progress, the estimated time remaining and the fraction of time that was spent to perform evolution. To disable it add <code>show_progress=false</code> to the keyword arguments.</p><p>Keyword assignments should be placed before the rules list:</p><pre><code class="language-julia hljs">@evolution k=2 rtol=1e-6 show_progress=false {...} for t in ...</code></pre><h2 id="Time-sequences"><a class="docs-heading-anchor" href="#Time-sequences">Time sequences</a><a id="Time-sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Time-sequences" title="Permalink"></a></h2><p>A <code>TimeSequence</code> is a struct that stores information about how some value changed during time. It simplifies working with time-dependent values by allowing you to run the computation pass only once and re-evaluate all processing and visualization code as much as you want.</p><p>Here is an example:</p><pre><code class="language- hljs">P0 = densitymatrix(diagonalize(qwz(l)))
density_rec = TimeSequence()
deriv_rec = TimeSequence()

@evolution {
    H := Chern(l, B * min(t, τ) / τ),
    P0 --&gt; H --&gt; P
} for t in 0:0.1:2τ
    insert!(density_rec, t, site_density(P))
    insert!(deriv_rec, t, site_density(-im * (H * P - P * H)))
end

site = l[50]
p = plot(layout=(2,1))
plot!(p[1], density_rec[site], lab=&quot;p&quot;)

# Compare computed time derivative with Heisenberg equation
plot!(p[2], differentiate(density_rec[site]), lw=5, alpha=0.3, lab=&quot;dp/dt&quot;)
plot!(p[2], deriv_rec[site], lab=&quot;Heisenberg&quot;)</code></pre><h3 id="Indexing-and-iteration"><a class="docs-heading-anchor" href="#Indexing-and-iteration">Indexing and iteration</a><a id="Indexing-and-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-and-iteration" title="Permalink"></a></h3><p><code>TimeSequence</code>s support two kinds of indexing:</p><ul><li>Calling the record with a numeric value selects the time and returns the object in nearest snapshot.  Calling it with two numeric values yields a new <code>TimeSequence</code> with all timestamps between given values.</li><li>Indexing it with square brackets will apply this index to all snapshots. The output will also be a <code>TimeSequence</code>.</li></ul><p>Let&#39;s see how it works:</p><pre><code class="language- hljs">p = plot(layout=(1,3), size=(800, 250))
plot!(p[1], density_rec(10))                        # The snapshot with time nearest to 10
typeof(density_rec(10))                             # LatticeValue{Float64}
plot!(p[2], density_rec[l[25]])                     # The value on the 25-th site depending on time 
typeof(density_rec[l[25]])                          # Dict{Float64, Float64}
plot!(p[3], (density_rec(15, 25) |&gt; diff)[l[25]])   # Derivative of the value by time where 15 ≤ t ≤ 25</code></pre><p>Note that <code>TimeSequence</code> impements the <code>AbstractDict</code> and therefore is iterable. The iterator yields <code>timestamp =&gt; value</code> pairs:</p><pre><code class="language-julia hljs">for (t, P) in density_rec
    # Do what you need with t, P
end</code></pre><h3 id="Differentiation-and-integration"><a class="docs-heading-anchor" href="#Differentiation-and-integration">Differentiation and integration</a><a id="Differentiation-and-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Differentiation-and-integration" title="Permalink"></a></h3><p>You can also automatically differentiate and integrate the <code>TimeSequence</code> with <a href="@ref"><code>differentiate</code></a> and <a href="@ref"><code>integrate</code></a> functions (or their in-place alternatives <a href="../library/#LatticeModels.differentiate!-Tuple{TimeSequence}"><code>differentiate!</code></a> and <a href="../library/#LatticeModels.integrate!-Tuple{TimeSequence}"><code>integrate!</code></a>). However, the type of the stored values must implement the following methods:</p><ul><li><code>Base.copy</code>: the non in-place methods simply call their in-place versions on a copy of the original TimeSequence.</li><li><code>Base.zero</code>: this function will be called before integrating.</li><li><code>LinearAlgebra.axpby!</code> to implement basic in-place math.</li></ul><p>Still, types in this library (<code>LatticeValue</code>, <code>LatticeArray</code>, <code>MaterializedCurrents</code>), numbers and arrays are compatible with differentiation and integration out of the box.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Integrating or differentiating may produce unexpected results or crash if applied to a <code>TimeSequence</code> with elements of different type or defined on a different <a href="../library/#LatticeModels.Lattice"><code>Lattice</code></a>/<a href="@ref"><code>Basis</code></a>. <strong>Lattice or basis match is not checked when constructing a <code>TimeSequence</code>!</strong></p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../currents/">« Currents</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 5 September 2023 13:41">Tuesday 5 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

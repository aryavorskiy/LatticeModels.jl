<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LatticeModels.jl</title><meta name="title" content="API · LatticeModels.jl"/><meta property="og:title" content="API · LatticeModels.jl"/><meta property="twitter:title" content="API · LatticeModels.jl"/><meta name="description" content="Documentation for LatticeModels.jl."/><meta property="og:description" content="Documentation for LatticeModels.jl."/><meta property="twitter:description" content="Documentation for LatticeModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LatticeModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/lattice/">Defining the lattice</a></li><li><a class="tocitem" href="../manual/bonds/">Adding bonds</a></li><li><a class="tocitem" href="../manual/latticevalue/">Working with &#39;LatticeValue&#39;s</a></li><li><a class="tocitem" href="../manual/hamiltonian/">Constructing the Hamiltonian</a></li><li><a class="tocitem" href="../manual/operators/">States and Operators</a></li><li><a class="tocitem" href="../manual/greenfunction/">Green&#39;s function</a></li><li><a class="tocitem" href="../manual/currents/">Currents</a></li><li><a class="tocitem" href="../manual/evolution/">Evolution</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Lattice-basics"><span>Lattice basics</span></a></li><li><a class="tocitem" href="#Lattice-constructors"><span>Lattice constructors</span></a></li><li><a class="tocitem" href="#Bonds"><span>Bonds</span></a></li><li><a class="tocitem" href="#Boundary-conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#LatticeValue"><span>LatticeValue</span></a></li><li><a class="tocitem" href="#Operators-and-observables"><span>Operators and observables</span></a></li><li><a class="tocitem" href="#Hamiltonians"><span>Hamiltonians</span></a></li><li><a class="tocitem" href="#Built-in-models"><span>Built-in models</span></a></li><li><a class="tocitem" href="#Diagonalization"><span>Diagonalization</span></a></li><li><a class="tocitem" href="#Green&#39;s-function"><span>Green&#39;s function</span></a></li><li><a class="tocitem" href="#Currents"><span>Currents</span></a></li><li><a class="tocitem" href="#Evolution"><span>Evolution</span></a></li><li><a class="tocitem" href="#Internals-2"><span>Internals</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><ul><li><a href="#LatticeModels.AbstractBonds"><code>LatticeModels.AbstractBonds</code></a></li><li><a href="#LatticeModels.AbstractCurrents"><code>LatticeModels.AbstractCurrents</code></a></li><li><a href="#LatticeModels.AbstractLattice"><code>LatticeModels.AbstractLattice</code></a></li><li><a href="#LatticeModels.AbstractSite"><code>LatticeModels.AbstractSite</code></a></li><li><a href="#LatticeModels.AbstractTranslation"><code>LatticeModels.AbstractTranslation</code></a></li><li><a href="#LatticeModels.AdjacencyMatrix-Tuple{Function, LatticeModels.AbstractLattice}"><code>LatticeModels.AdjacencyMatrix</code></a></li><li><a href="#LatticeModels.AdjacencyMatrix"><code>LatticeModels.AdjacencyMatrix</code></a></li><li><a href="#LatticeModels.AdjacencyMatrix-Tuple{LatticeModels.AbstractBonds, Vararg{LatticeModels.AbstractBonds}}"><code>LatticeModels.AdjacencyMatrix</code></a></li><li><a href="#LatticeModels.AdjacencyMatrix-Tuple{DataOperator{BT, BT} where BT&lt;:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>LatticeModels.AdjacencyMatrix</code></a></li><li><a href="#LatticeModels.BallND"><code>LatticeModels.BallND</code></a></li><li><a href="#LatticeModels.BoundaryConditions"><code>LatticeModels.BoundaryConditions</code></a></li><li><a href="#LatticeModels.Box"><code>LatticeModels.Box</code></a></li><li><a href="#LatticeModels.Bravais"><code>LatticeModels.Bravais</code></a></li><li><a href="#LatticeModels.BravaisSite"><code>LatticeModels.BravaisSite</code></a></li><li><a href="#LatticeModels.BravaisTranslation"><code>LatticeModels.BravaisTranslation</code></a></li><li><a href="#LatticeModels.BravaisTranslation"><code>LatticeModels.BravaisTranslation</code></a></li><li><a href="#LatticeModels.CachedExp"><code>LatticeModels.CachedExp</code></a></li><li><a href="#LatticeModels.Currents-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.Currents</code></a></li><li><a href="#LatticeModels.Currents"><code>LatticeModels.Currents</code></a></li><li><a href="#LatticeModels.DensityCurrents"><code>LatticeModels.DensityCurrents</code></a></li><li><a href="#LatticeModels.DirectedBonds"><code>LatticeModels.DirectedBonds</code></a></li><li><a href="#LatticeModels.Eigensystem"><code>LatticeModels.Eigensystem</code></a></li><li><a href="#LatticeModels.Evolution"><code>LatticeModels.Evolution</code></a></li><li><a href="#LatticeModels.EvolutionSolver"><code>LatticeModels.EvolutionSolver</code></a></li><li><a href="#LatticeModels.FunctionBoundary"><code>LatticeModels.FunctionBoundary</code></a></li><li><a href="#LatticeModels.GaugeField"><code>LatticeModels.GaugeField</code></a></li><li><a href="#LatticeModels.GenericLattice-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.GenericLattice</code></a></li><li><a href="#LatticeModels.GenericLattice"><code>LatticeModels.GenericLattice</code></a></li><li><a href="#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{SiteT}} where SiteT&lt;:LatticeModels.AbstractSite"><code>LatticeModels.GenericLattice</code></a></li><li><a href="#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{N}} where N"><code>LatticeModels.GenericLattice</code></a></li><li><a href="#LatticeModels.GenericSite"><code>LatticeModels.GenericSite</code></a></li><li><a href="#LatticeModels.GreenFunction"><code>LatticeModels.GreenFunction</code></a></li><li><a href="#LatticeModels.Hamiltonian"><code>LatticeModels.Hamiltonian</code></a></li><li><a href="#LatticeModels.HoneycombLattice"><code>LatticeModels.HoneycombLattice</code></a></li><li><a href="#LatticeModels.IncompatibleLattices"><code>LatticeModels.IncompatibleLattices</code></a></li><li><a href="#LatticeModels.KagomeLattice"><code>LatticeModels.KagomeLattice</code></a></li><li><a href="#LatticeModels.KrylovKitExp"><code>LatticeModels.KrylovKitExp</code></a></li><li><a href="#LatticeModels.LandauGauge"><code>LatticeModels.LandauGauge</code></a></li><li><a href="#LatticeModels.LatticeBasis"><code>LatticeModels.LatticeBasis</code></a></li><li><a href="#LatticeModels.LatticeValue"><code>LatticeModels.LatticeValue</code></a></li><li><a href="#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, AbstractVector}"><code>LatticeModels.LatticeValue</code></a></li><li><a href="#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, LatticeModels.SiteProperty}"><code>LatticeModels.LatticeValue</code></a></li><li><a href="#LatticeModels.LineIntegralGaugeField"><code>LatticeModels.LineIntegralGaugeField</code></a></li><li><a href="#LatticeModels.LocalOperatorCurrents"><code>LatticeModels.LocalOperatorCurrents</code></a></li><li><a href="#LatticeModels.LookupTable"><code>LatticeModels.LookupTable</code></a></li><li><a href="#LatticeModels.NParticles-Union{Tuple{SampleT}, Tuple{SampleT, Any}} where SampleT&lt;:LatticeModels.Sample"><code>LatticeModels.NParticles</code></a></li><li><a href="#LatticeModels.NearestNeighbor"><code>LatticeModels.NearestNeighbor</code></a></li><li><a href="#LatticeModels.NearestNeighbor"><code>LatticeModels.NearestNeighbor</code></a></li><li><a href="#LatticeModels.NoField"><code>LatticeModels.NoField</code></a></li><li><a href="#LatticeModels.OperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{&lt;:Number}, SystemT}} where {SystemT&lt;:System, FieldT&lt;:LatticeModels.AbstractField}"><code>LatticeModels.OperatorBuilder</code></a></li><li><a href="#LatticeModels.OperatorBuilder"><code>LatticeModels.OperatorBuilder</code></a></li><li><a href="#LatticeModels.Path"><code>LatticeModels.Path</code></a></li><li><a href="#LatticeModels.PointFlux"><code>LatticeModels.PointFlux</code></a></li><li><a href="#LatticeModels.PointFlux"><code>LatticeModels.PointFlux</code></a></li><li><a href="#LatticeModels.PointFluxes-Tuple{AbstractVector, AbstractVector}"><code>LatticeModels.PointFluxes</code></a></li><li><a href="#LatticeModels.PointFluxes-Tuple{Any}"><code>LatticeModels.PointFluxes</code></a></li><li><a href="#LatticeModels.PointFluxes"><code>LatticeModels.PointFluxes</code></a></li><li><a href="#LatticeModels.Polygon"><code>LatticeModels.Polygon</code></a></li><li><a href="#LatticeModels.SiteAt"><code>LatticeModels.SiteAt</code></a></li><li><a href="#LatticeModels.SiteDistance"><code>LatticeModels.SiteDistance</code></a></li><li><a href="#LatticeModels.SiteProperty"><code>LatticeModels.SiteProperty</code></a></li><li><a href="#LatticeModels.SquareLattice"><code>LatticeModels.SquareLattice</code></a></li><li><a href="#LatticeModels.SubCurrents"><code>LatticeModels.SubCurrents</code></a></li><li><a href="#LatticeModels.SymmetricGauge"><code>LatticeModels.SymmetricGauge</code></a></li><li><a href="#LatticeModels.System-Tuple{LatticeModels.Sample}"><code>LatticeModels.System</code></a></li><li><a href="#LatticeModels.TimeSequence-Union{Tuple{}, Tuple{ET}} where ET"><code>LatticeModels.TimeSequence</code></a></li><li><a href="#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}"><code>LatticeModels.TimeSequence</code></a></li><li><a href="#LatticeModels.TimeSequence-Tuple{Function, LatticeModels.EvolutionIterator}"><code>LatticeModels.TimeSequence</code></a></li><li><a href="#LatticeModels.TimeSequence"><code>LatticeModels.TimeSequence</code></a></li><li><a href="#LatticeModels.Translation"><code>LatticeModels.Translation</code></a></li><li><a href="#LatticeModels.TriangularLattice"><code>LatticeModels.TriangularLattice</code></a></li><li><a href="#LatticeModels.TwistedBoundary"><code>LatticeModels.TwistedBoundary</code></a></li><li><a href="#LatticeModels.UndefinedLattice"><code>LatticeModels.UndefinedLattice</code></a></li><li><a href="#LatticeModels.UnitCell"><code>LatticeModels.UnitCell</code></a></li><li><a href="#LatticeModels.Chain-Tuple{Function, Any}"><code>LatticeModels.Chain</code></a></li><li><a href="#LatticeModels.FastOperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{&lt;:Number}, SystemT}} where {SystemT&lt;:System, FieldT&lt;:LatticeModels.AbstractField}"><code>LatticeModels.FastOperatorBuilder</code></a></li><li><a href="#LatticeModels.GrapheneRibbon"><code>LatticeModels.GrapheneRibbon</code></a></li><li><a href="#LatticeModels.PeriodicBoundary-Tuple{Any}"><code>LatticeModels.PeriodicBoundary</code></a></li><li><a href="#LatticeModels.adapt_bonds-Tuple{Any, LatticeModels.AbstractLattice}"><code>LatticeModels.adapt_bonds</code></a></li><li><a href="#LatticeModels.addlookuptable"><code>LatticeModels.addlookuptable</code></a></li><li><a href="#LatticeModels.adjacentsites-Tuple{AdjacencyMatrix, LatticeModels.AbstractSite}"><code>LatticeModels.adjacentsites</code></a></li><li><a href="#LatticeModels.bosehubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}"><code>LatticeModels.bosehubbard</code></a></li><li><a href="#LatticeModels.brastate-Tuple{LatticeValue{T} where T}"><code>LatticeModels.brastate</code></a></li><li><a href="#LatticeModels.check_issublattice-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractLattice}"><code>LatticeModels.check_issublattice</code></a></li><li><a href="#LatticeModels.check_samelattice-Tuple{Any, Any}"><code>LatticeModels.check_samelattice</code></a></li><li><a href="#LatticeModels.check_samesites-Tuple{Any, Any}"><code>LatticeModels.check_samesites</code></a></li><li><a href="#LatticeModels.construct_hamiltonian-Tuple{Type, System, Vararg{Any}}"><code>LatticeModels.construct_hamiltonian</code></a></li><li><a href="#LatticeModels.construct_operator-Tuple{Type, System, Vararg{Any}}"><code>LatticeModels.construct_operator</code></a></li><li><a href="#LatticeModels.coordoperator-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}, Any}"><code>LatticeModels.coordoperator</code></a></li><li><a href="#LatticeModels.coordoperators-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>LatticeModels.coordoperators</code></a></li><li><a href="#LatticeModels.coordvalue-Tuple{LatticeModels.AbstractLattice, Int64}"><code>LatticeModels.coordvalue</code></a></li><li><a href="#LatticeModels.coordvalues-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.coordvalues</code></a></li><li><a href="#LatticeModels.currentsfrom-Tuple{LatticeModels.AbstractCurrents, Any}"><code>LatticeModels.currentsfrom</code></a></li><li><a href="#LatticeModels.currentsfromto"><code>LatticeModels.currentsfromto</code></a></li><li><a href="#LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.FixedMu}}"><code>LatticeModels.densitymatrix</code></a></li><li><a href="#LatticeModels.diagonalelements-Tuple{LatticeModels.GreenFunctionEval{&lt;:System{&lt;:LatticeModels.Sample{LT, Nothing} where LT}}}"><code>LatticeModels.diagonalelements</code></a></li><li><a href="#LatticeModels.diagonalize-Tuple{Hamiltonian, Val}"><code>LatticeModels.diagonalize</code></a></li><li><a href="#LatticeModels.differentiate-Tuple{TimeSequence}"><code>LatticeModels.differentiate</code></a></li><li><a href="#LatticeModels.differentiate!-Tuple{TimeSequence}"><code>LatticeModels.differentiate!</code></a></li><li><a href="#LatticeModels.dos-Tuple{LatticeModels.AbstractEigensystem, Any}"><code>LatticeModels.dos</code></a></li><li><a href="#LatticeModels.fermihubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}"><code>LatticeModels.fermihubbard</code></a></li><li><a href="#LatticeModels.fillshapes-Union{Tuple{N}, Tuple{UnitCell{Sym, N} where Sym, Vararg{LatticeModels.AbstractShape}}} where N"><code>LatticeModels.fillshapes</code></a></li><li><a href="#LatticeModels.findgroundstate-Tuple{LatticeModels.HamiltonianEigensystem}"><code>LatticeModels.findgroundstate</code></a></li><li><a href="#LatticeModels.getnnbonds-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.getnnbonds</code></a></li><li><a href="#LatticeModels.greenfunction-Tuple{Any, Ket, Hamiltonian, Hamiltonian}"><code>LatticeModels.greenfunction</code></a></li><li><a href="#LatticeModels.greenfunction-Tuple{Any, LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.OneParticleBasisSystem}}"><code>LatticeModels.greenfunction</code></a></li><li><a href="#LatticeModels.groundstate-Tuple{Any}"><code>LatticeModels.groundstate</code></a></li><li><a href="#LatticeModels.haldane"><code>LatticeModels.haldane</code></a></li><li><a href="#LatticeModels.hubbard-Tuple{Type, NParticles, Vararg{Any}}"><code>LatticeModels.hubbard</code></a></li><li><a href="#LatticeModels.integrate-Tuple{TimeSequence}"><code>LatticeModels.integrate</code></a></li><li><a href="#LatticeModels.integrate!-Tuple{TimeSequence}"><code>LatticeModels.integrate!</code></a></li><li><a href="#LatticeModels.interaction-Tuple{Function, Type{&lt;:Number}, NParticles}"><code>LatticeModels.interaction</code></a></li><li><a href="#LatticeModels.interaction-Union{Tuple{K}, Tuple{Function, Type{&lt;:Number}, NParticles, Val{K}}} where K"><code>LatticeModels.interaction</code></a></li><li><a href="#LatticeModels.kanemele-Tuple{System, Real, Real}"><code>LatticeModels.kanemele</code></a></li><li><a href="#LatticeModels.ketstate-Tuple{LatticeValue{T} where T}"><code>LatticeModels.ketstate</code></a></li><li><a href="#LatticeModels.lattice-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.lattice</code></a></li><li><a href="#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.lattice</code></a></li><li><a href="#LatticeModels.ldos-Tuple{GreenFunction, Real, LatticeModels.AbstractSite}"><code>LatticeModels.ldos</code></a></li><li><a href="#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}"><code>LatticeModels.line_integral</code></a></li><li><a href="#LatticeModels.localdensity-Tuple{Union{DataOperator{var&quot;#s237&quot;, var&quot;#s237&quot;}, Bra{var&quot;#s237&quot;}, Ket{var&quot;#s237&quot;}} where var&quot;#s237&quot;&lt;:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>LatticeModels.localdensity</code></a></li><li><a href="#LatticeModels.localexpect-Tuple{DataOperator, Union{DataOperator{var&quot;#s235&quot;, var&quot;#s235&quot;}, Bra{var&quot;#s235&quot;}, Ket{var&quot;#s235&quot;}} where var&quot;#s235&quot;&lt;:(CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT})}"><code>LatticeModels.localexpect</code></a></li><li><a href="#LatticeModels.periodic_fluxes-Tuple{Union{LatticeModels.BravaisLattice, LatticeModels.LatticeWithMetadata{&lt;:LatticeModels.BravaisLattice}}, PointFlux}"><code>LatticeModels.periodic_fluxes</code></a></li><li><a href="#LatticeModels.projector-Tuple{Any, LatticeModels.AbstractEigensystem}"><code>LatticeModels.projector</code></a></li><li><a href="#LatticeModels.projector-Tuple{LatticeModels.AbstractEigensystem}"><code>LatticeModels.projector</code></a></li><li><a href="#LatticeModels.qwz-Tuple{LatticeValue{T} where T}"><code>LatticeModels.qwz</code></a></li><li><a href="#LatticeModels.removedangling!"><code>LatticeModels.removedangling!</code></a></li><li><a href="#LatticeModels.sample-Tuple{LatticeBasis}"><code>LatticeModels.sample</code></a></li><li><a href="#LatticeModels.setboundaries-Tuple{LatticeModels.AbstractLattice, BoundaryConditions}"><code>LatticeModels.setboundaries</code></a></li><li><a href="#LatticeModels.setnnbonds-Tuple{LatticeModels.AbstractLattice, Vararg{LatticeModels.AbstractBonds}}"><code>LatticeModels.setnnbonds</code></a></li><li><a href="#LatticeModels.shaperadius-Tuple{UnitCell, LatticeModels.AbstractShape, Int64}"><code>LatticeModels.shaperadius</code></a></li><li><a href="#LatticeModels.site_index"><code>LatticeModels.site_index</code></a></li><li><a href="#LatticeModels.sitedistance-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}"><code>LatticeModels.sitedistance</code></a></li><li><a href="#LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{&lt;:Integer, &lt;:Integer}}, NU}}} where {N, NU, NB}"><code>LatticeModels.span_unitcells</code></a></li><li><a href="#LatticeModels.tightbinding_hamiltonian-Tuple{Type, System, Vararg{Any}}"><code>LatticeModels.tightbinding_hamiltonian</code></a></li><li><a href="#LatticeModels.timerange-Tuple{TimeSequence}"><code>LatticeModels.timerange</code></a></li><li><a href="#LatticeModels.timestamps-Tuple{TimeSequence}"><code>LatticeModels.timestamps</code></a></li><li><a href="#LatticeModels.translate_to_nearest-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}"><code>LatticeModels.translate_to_nearest</code></a></li><li><a href="#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}"><code>LatticeModels.vector_potential</code></a></li><li><a href="#LatticeModels.@bravaisdef-Tuple{Any, Any}"><code>LatticeModels.@bravaisdef</code></a></li></ul><h2 id="Lattice-basics"><a class="docs-heading-anchor" href="#Lattice-basics">Lattice basics</a><a id="Lattice-basics-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-basics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.IncompatibleLattices" href="#LatticeModels.IncompatibleLattices"><code>LatticeModels.IncompatibleLattices</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">IncompatibleLattices([header, ]lat1, lat2)</code></pre><p>An exception thrown when two lattices are incompatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.SiteProperty" href="#LatticeModels.SiteProperty"><code>LatticeModels.SiteProperty</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SiteProperty</code></pre><p>An abstract type for a property of a site.</p><p>This interface is used to define various properties of a site. They can be accessed using <code>getsiteproperty</code>. This interface is used in following places:</p><ul><li><code>lattice[...]</code> syntax to access sites with specific properties.</li><li><code>lattice_value[...]</code> syntax to access values defined on sites with specific properties.</li><li>Functions to generate <code>LatticeValue</code>s and operators for specific properties.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = SquareLattice(3, 3);

julia&gt; l[x = 1, y = 2]          # Get site with x = 1 and y = 2
2-dim Bravais lattice site in 2D space at [1.0, 2.0]

julia&gt; l[x = 1]                 # Get sublattice with x = 1
3-site 2-dim Bravais lattice in 2D space
Unit cell:
  Basis site coordinates:
    ┌      ┐
    │ 0.000│
    │ 0.000│
    └      ┘
  Translation vectors:
    ┌      ┐ ┌      ┐
    │ 1.000│ │ 0.000│
    │ 0.000│ │ 1.000│
    └      ┘ └      ┘
Lattice type: SquareLattice{2}
Default translations:
  :axis1 → Bravais[3, 0]
  :axis2 → Bravais[0, 3]
Nearest neighbor hoppings:
  1.00000 =&gt;
    Bravais[1, 0]
    Bravais[0, 1]
  1.41421 =&gt;
    Bravais[1, -1]
    Bravais[1, 1]
  2.00000 =&gt;
    Bravais[2, 0]
    Bravais[0, 2]
Boundary conditions: none

julia&gt; l[x = 1, y = 2, z = 3]   # No site with defined z property on a 2D lattice
ERROR: ArgumentError: Invalid axis index 3 of a 2-dim site
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L29-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.check_issublattice-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractLattice}" href="#LatticeModels.check_issublattice-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractLattice}"><code>LatticeModels.check_issublattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Checks if <code>l1</code> is sublattice of <code>l2</code>. Throws an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L315-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.check_samelattice-Tuple{Any, Any}" href="#LatticeModels.check_samelattice-Tuple{Any, Any}"><code>LatticeModels.check_samelattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Checks if <code>l1</code> and <code>l2</code> objects are defined on the same lattice. Throws an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L299-L301">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.check_samesites-Tuple{Any, Any}" href="#LatticeModels.check_samesites-Tuple{Any, Any}"><code>LatticeModels.check_samesites</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Checks if <code>l1</code> and <code>l2</code> objects are defined on the same sites. Throws an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L307-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.lattice-Tuple{LatticeModels.AbstractLattice}" href="#LatticeModels.lattice-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.lattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lattice(any)</code></pre><p>Return the lattice of the given object (an operator, <code>LatticeValue</code>, ...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.site_index" href="#LatticeModels.site_index"><code>LatticeModels.site_index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">site_index(lat, site[, range])</code></pre><p>Return the index of the <code>site</code> in the lattice <code>lat</code>. If <code>range</code> is given, only search in the given range. Return <code>nothing</code> if the site is not found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GenericLattice" href="#LatticeModels.GenericLattice"><code>LatticeModels.GenericLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericLattice{SiteT}</code></pre><p>A generic lattice of <code>SiteT</code> sites.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = GenericLattice{2}()
0-site GenericLattice{GenericSite{2}} in 2D space

julia&gt; push!(l, GenericSite(0, 0))  # Add a site at (0, 0)
1-site GenericLattice{GenericSite{2}} in 2D space:
  Site at [0.0, 0.0]

julia&gt; push!(l, (0, 1))             # Add a site at (0, 1)
2-site GenericLattice{GenericSite{2}} in 2D space:
  Site at [0.0, 0.0]
  Site at [0.0, 1.0]

julia&gt; push!(l, [1, 0])             # Add a site at (1, 0)
3-site GenericLattice{GenericSite{2}} in 2D space:
  Site at [0.0, 0.0]
  Site at [0.0, 1.0]
  Site at [1.0, 0.0]

julia&gt; l[2]
2-dim GenericSite{2} at [0.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/genericlattice.jl#L27-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GenericLattice-Tuple{LatticeModels.AbstractLattice}" href="#LatticeModels.GenericLattice-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.GenericLattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericLattice(lat)</code></pre><p>Constructs a <code>GenericLattice</code> from some other lattice <code>lat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/genericlattice.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GenericLattice-Union{Tuple{}, Tuple{N}} where N" href="#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{N}} where N"><code>LatticeModels.GenericLattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericLattice{N}()</code></pre><p>Constructs an empty <code>N</code>-dimensional <code>GenericLattice</code> of <code>GenericSite</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/genericlattice.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GenericLattice-Union{Tuple{}, Tuple{SiteT}} where SiteT&lt;:LatticeModels.AbstractSite" href="#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{SiteT}} where SiteT&lt;:LatticeModels.AbstractSite"><code>LatticeModels.GenericLattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericLattice{SiteType}()</code></pre><p>Constructs an empty <code>GenericLattice</code> of <code>SiteType</code> sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/genericlattice.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GenericSite" href="#LatticeModels.GenericSite"><code>LatticeModels.GenericSite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GenericSite{N}</code></pre><p>A generic site in an N-dimensional lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/genericlattice.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.BravaisSite" href="#LatticeModels.BravaisSite"><code>LatticeModels.BravaisSite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BravaisSite{N,NU,B}</code></pre><p>A site of a <code>BravaisLattice{N,NU,B}</code> lattice.</p><p><strong>Fields</strong></p><ul><li><code>unitcell</code>: a <code>UnitCell</code> object representing the lattice unit cell.</li><li><code>latcoords</code>: a <code>SVector</code> of size <code>N</code> representing the lattice coordinates of the site.</li><li><code>basindex</code>: an <code>Int</code> representing the index of the site in the lattice basis.</li><li><code>coords</code>: a <code>SVector</code> of size <code>N</code> representing the spatial coordinates of the site.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/unitcell.jl#L134-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.UnitCell" href="#LatticeModels.UnitCell"><code>LatticeModels.UnitCell</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitCell(translations[, basis; offset, rotate])</code></pre><p>Constructs a Bravais lattice unit cell with given translation vectors and locations of basis sites.</p><p><strong>Arguments</strong></p><ul><li><code>translations</code>: an <code>AbstractMatrix</code> of size <code>N×N</code> representing the translation vectors of the lattice.</li><li><code>basis</code>: an <code>AbstractMatrix</code> of size <code>N×NB</code> representing the locations of basis sites.   If not provided, the lattice basis will consist of one site located in the bottom-left corner of the unit cell.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>offset</code>: a keyword argument that specifies how to shift the lattice basis.   Possible values:<ul><li><code>:origin</code>: no shift (default).</li><li><code>:center</code>: shift the lattice so that the center of the basis is at the origin of the unit cell.</li><li><code>:centeralign</code>: shift the lattice so that the center of the basis is at the center of the unit cell.</li><li>Also accepts an <code>AbstractVector</code> of size <code>N</code> to shift the lattice by a custom vector.</li></ul></li><li><code>rotate</code>: a keyword argument that specifies how to rotate the lattice basis.   Possible values:<ul><li><code>nothing</code>: no rotation (default).</li><li>An <code>AbstractMatrix</code> of size <code>N×N</code> to rotate the lattice.</li><li>A <code>Real</code> number to rotate the lattice by this angle in radians.</li><li>Also accepts an <code>AbstractMatrix</code> of size <code>N×N</code> to rotate the lattice basis.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/unitcell.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{&lt;:Integer, &lt;:Integer}}, NU}}} where {N, NU, NB}" href="#LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{&lt;:Integer, &lt;:Integer}}, NU}}} where {N, NU, NB}"><code>LatticeModels.span_unitcells</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">span_unitcells([f, ]unitcell, dims...[; boundaries, offset])</code></pre><p>Construct a Bravais lattice by spanning <code>unitcell</code> in <code>dims</code> dimensions, filtered by <code>f</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: a function that defines if the site is included in the lattice. Takes a <code>BravaisSite</code>, returns a <code>Bool</code>.</li><li><code>unitcell</code>: a <code>UnitCell</code> object.</li><li><code>dims</code>: a list of <code>Integer</code>s or <code>Range</code>s specifying the size of the lattice in each dimension.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>default_translations</code>: a list of <code>BravaisTranslation</code>s to add to the lattice as default boundary condition axes.</li><li><code>boundaries</code>: a <code>BoundaryConditions</code> object specifying the boundary conditions of the lattice.</li><li><code>rmdup</code>: a <code>Bool</code> specifying whether to remove sites that are equivalent after applying the boundary conditions.</li><li><code>offset</code>: the offset of the lattice from the origin. See <code>UnitCell</code> for details.</li><li><code>rotate</code>: a rotation matrix to apply to the lattice. See <code>UnitCell</code> for details.</li></ul><p>Keep in mind that the offset and rotation are applied to the unit cell before the lattice is spanned (and <code>f</code> is applied). To apply them after the lattice is spanned, use the <code>postoffset</code> and <code>postrotate</code> keywords.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; using LatticeModels

julia&gt; uc = UnitCell([[1, 0] [0, 1]])
1-site Unit cell of a 2-dim Bravais lattice in 2D space:
  Basis site coordinates:
    ┌      ┐
    │ 0.000│
    │ 0.000│
    └      ┘
  Translation vectors:
    ┌      ┐ ┌      ┐
    │ 1.000│ │ 0.000│
    │ 0.000│ │ 1.000│
    └      ┘ └      ┘

julia&gt; span_unitcells(uc, 3, 3) == SquareLattice(3, 3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/lattice.jl#L122-L164">source</a></section></article><h2 id="Lattice-constructors"><a class="docs-heading-anchor" href="#Lattice-constructors">Lattice constructors</a><a id="Lattice-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-constructors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.HoneycombLattice" href="#LatticeModels.HoneycombLattice"><code>LatticeModels.HoneycombLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HoneycombLattice</code></pre><p>Represents a honeycomb lattice.</p><p>Lattice vectors: <code>[1, 0]</code> and <code>[0.5, √3/2]</code>, two sites at <code>[0, 0]</code> and <code>[0.5, √3/6]</code> in each unit cell.</p><hr/><pre><code class="nohighlight hljs">HoneycombLattice(a, b)</code></pre><p>Construct a honeycomb lattice of a×b spanned unit cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/lattices.jl#L153-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.KagomeLattice" href="#LatticeModels.KagomeLattice"><code>LatticeModels.KagomeLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KagomeLattice</code></pre><p>Represents a kagome lattice.</p><p>Lattice vectors: <code>[1, 0]</code> and <code>[0.5, √3/2]</code>, three sites at <code>[0, 0]</code>, <code>[0.5, 0]</code> and <code>[0.25, √3/4]</code> in each unit cell.</p><hr/><pre><code class="nohighlight hljs">KagomeLattice(a, b)</code></pre><p>Construct a kagome lattice of a×b spanned unit cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/lattices.jl#L201-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.SquareLattice" href="#LatticeModels.SquareLattice"><code>LatticeModels.SquareLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SquareLattice{N}</code></pre><p>Represents a square lattice in <code>N</code> dimensions.</p><hr/><pre><code class="nohighlight hljs">SquareLattice(sz...)</code></pre><p>Construct a square lattice of size <code>sz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/lattices.jl#L126-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.TriangularLattice" href="#LatticeModels.TriangularLattice"><code>LatticeModels.TriangularLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TriangularLattice</code></pre><p>Represents a triangular lattice. Lattice vectors: <code>[1, 0]</code> and <code>[0.5, √3/2]</code>.</p><hr/><pre><code class="nohighlight hljs">TriangularLattice(a, b)</code></pre><p>Construct a triangular lattice of a×b spanned unit cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/lattices.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Chain-Tuple{Function, Any}" href="#LatticeModels.Chain-Tuple{Function, Any}"><code>LatticeModels.Chain</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Chain(sz)</code></pre><p>Construct a 1D chain lattice of size <code>sz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/lattices.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GrapheneRibbon" href="#LatticeModels.GrapheneRibbon"><code>LatticeModels.GrapheneRibbon</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GrapheneRibbon(len, wid[, center; kw...])</code></pre><p>Construct a graphene ribbon sample with zigzag edges. To get armchair edges, simply rotate the lattice by 90 degrees.</p><p><strong>Arguments</strong></p><ul><li><code>len</code>: the length of the ribbon.</li><li><code>wid</code>: the width of the ribbon.</li><li><code>center</code>: the unit cell coordinates of the bottom-left corner of the ribbon. Default is <code>(0, 0)</code>.</li></ul><p>All other keyword arguments are passed to <code>span_unitcells</code> (see its documentation for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/lattices.jl#L169-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.@bravaisdef-Tuple{Any, Any}" href="#LatticeModels.@bravaisdef-Tuple{Any, Any}"><code>LatticeModels.@bravaisdef</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@bravaisdef MyBravaisLattice UnitCell(...)
@bravaisdef MyBravaisLattice N -&gt; UnitCell(...)</code></pre><p>Define a new Bravais lattice type <code>MyBravaisLattice</code> with a unit cell constructor <code>UnitCell(expr)</code>. If the notation is <code>N -&gt; UnitCell(expr)</code>, the unit cell constructor will be dependent on the dimensionality <code>N</code>. otherwise, the dimensionality will be inferred from the unit cell. <code>N</code> is the dimensionality of the lattice.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; @bravaisdef MyBravaisLattice UnitCell([1 0; 0 1]);   # 2D square lattice

julia&gt; MyBravaisLattice(3, 3)
9-site 2-dim Bravais lattice in 2D space
Unit cell:
  Basis site coordinates:
    ┌      ┐
    │ 0.000│
    │ 0.000│
    └      ┘
  Translation vectors:
    ┌      ┐ ┌      ┐
    │ 1.000│ │ 0.000│
    │ 0.000│ │ 1.000│
    └      ┘ └      ┘
Lattice type: MyBravaisLattice
Default translations:
  :axis1 → Bravais[3, 0]
  :axis2 → Bravais[0, 3]
Nearest neighbor hoppings:
  1.00000 =&gt;
    Bravais[1, 0]
    Bravais[0, 1]
  1.41421 =&gt;
    Bravais[1, -1]
    Bravais[1, 1]
  2.00000 =&gt;
    Bravais[2, 0]
    Bravais[0, 2]
Boundary conditions: none</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/lattices.jl#L23-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.BallND" href="#LatticeModels.BallND"><code>LatticeModels.BallND</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BallND{N}([radius, center])</code></pre><p>Construct a <code>N</code>-dimensional ball with a given radius and center. Note the aliases: <code>Circle</code> and <code>Ball</code> are <code>BallND{2}</code> and <code>BallND{3}</code> respectively.</p><p><strong>Arguments</strong></p><ul><li><code>radius</code>: The radius of the ball.</li><li><code>center</code>: The center of the ball.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L168-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Box" href="#LatticeModels.Box"><code>LatticeModels.Box</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Box(intervals...)</code></pre><p>Construct a box with given horizontal and vertical intervals. Usage: <code>Box(1 .. 3, 2 .. 4)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>intervals</code>: The intervals for each dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L261-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Path" href="#LatticeModels.Path"><code>LatticeModels.Path</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Path(start, stop)</code></pre><p>Construct a path from <code>start</code> to <code>stop</code>.</p><p><strong>Arguments</strong></p><ul><li><code>start</code>: The start of the path.</li><li><code>stop</code>: The end of the path.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L292-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Polygon" href="#LatticeModels.Polygon"><code>LatticeModels.Polygon</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Polygon{N}([radius, center])
Polygon{N}([center; h])</code></pre><p>Construct a regular <code>N</code>-sided polygon with a given (circumscribed) radius and center. Note the aliases: <code>Triangle</code>, <code>Square</code>, and <code>Hexagon</code> are <code>Polygon{3}</code>, <code>Polygon{4}</code>, and <code>Polygon{6}</code> respectively.</p><p><strong>Arguments</strong></p><ul><li><code>radius</code>: The (circumscribed) radius of the polygon.</li><li><code>center</code>: The center of the polygon.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>h</code>: The distance from the center to the vertices. If given, the <code>radius</code> is calculated as <code>h / cos(pi / N)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L199-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.SiteAt" href="#LatticeModels.SiteAt"><code>LatticeModels.SiteAt</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SiteAt(coords)</code></pre><p>Represents a single site at the given coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L246-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.fillshapes-Union{Tuple{N}, Tuple{UnitCell{Sym, N} where Sym, Vararg{LatticeModels.AbstractShape}}} where N" href="#LatticeModels.fillshapes-Union{Tuple{N}, Tuple{UnitCell{Sym, N} where Sym, Vararg{LatticeModels.AbstractShape}}} where N"><code>LatticeModels.fillshapes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fillshapes(uc, shapes...[; sites, scale, kw...])</code></pre><p>Create a lattice sample with geometry defined by the given shapes. The lattice is filled with sites that are inside the shapes.</p><p><strong>Arguments</strong></p><ul><li><code>uc</code>: The <code>UnitCell</code> of the lattice. Might also be a lattice type.</li><li><code>shapes</code>: The shapes to fill the lattice with.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>sites</code>: If given, an attepmt will be made to fill the lattice with the given number of sites.   The scaling will be approximate and relying on assumptions that the shapes do not overlap.</li><li><code>scale</code>: The scaling factor for the shapes. If <code>sites</code> is given, the scaling factor will be   calculated automatically.</li></ul><p>All other keyword arguments are passed to the lattice constructor. See <a href="#LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{&lt;:Integer, &lt;:Integer}}, NU}}} where {N, NU, NB}"><code>span_unitcells</code></a> for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L98-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.removedangling!" href="#LatticeModels.removedangling!"><code>LatticeModels.removedangling!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">removedangling!(lat[, maxdepth])</code></pre><p>Remove dangling sites from the lattice. A site is considered dangling if it has less than 2 neighbors. The function will remove all dangling sites and their neighbors recursively up to <code>maxdepth</code> levels — the default is <code>Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L386-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.shaperadius-Tuple{UnitCell, LatticeModels.AbstractShape, Int64}" href="#LatticeModels.shaperadius-Tuple{UnitCell, LatticeModels.AbstractShape, Int64}"><code>LatticeModels.shaperadius</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shaperadius(unitcell, shape, sites)
shaperadius(lat, shape[, sites])</code></pre><p>Calculate the radius of a shape such that it contains appriximately <code>sites</code> sites.</p><p><strong>Arguments</strong></p><ul><li><code>unitcell</code>: The <code>UnitCell</code> of the lattice. Might also be a lattice type.</li><li><code>lat</code>: The lattice. It is considered that the lattice was constructed in the same shape.</li><li><code>shape</code>: The shape to calculate the radius for.</li><li><code>sites</code>: The number of sites the shape should contain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/shapes.jl#L58-L69">source</a></section></article><h2 id="Bonds"><a class="docs-heading-anchor" href="#Bonds">Bonds</a><a id="Bonds-1"></a><a class="docs-heading-anchor-permalink" href="#Bonds" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AdjacencyMatrix" href="#LatticeModels.AdjacencyMatrix"><code>LatticeModels.AdjacencyMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjacencyMatrix{LT} where {LT&lt;:Lattice}</code></pre><p>Represents the bonds on some lattice.</p><hr/><pre><code class="nohighlight hljs">AdjacencyMatrix(lat[, mat])</code></pre><p>Construct an adjacency matrix from the <code>mat</code> matrix on the <code>lat</code> lattice.</p><p>If <code>mat</code> is not provided, it is assumed to be a zero matrix.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = SquareLattice(2, 2);

julia&gt; a = AdjacencyMatrix(l)
Adjacency matrix on 4-site SquareLattice in 2D space
Values in a 4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 0 stored entries:
 ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅
 ⋅  ⋅  ⋅  ⋅

julia&gt; site1, site2, site3, site4 = l;

julia&gt; a[site1, site2] = a[site2, site4] = a[site3, site4] = true;

julia&gt; a
Adjacency matrix on 4-site SquareLattice in 2D space
Values in a 4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 6 stored entries:
 ⋅  1  ⋅  ⋅
 1  ⋅  ⋅  1
 ⋅  ⋅  ⋅  1
 ⋅  1  1  ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L164-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AdjacencyMatrix-Tuple{Function, LatticeModels.AbstractLattice}" href="#LatticeModels.AdjacencyMatrix-Tuple{Function, LatticeModels.AbstractLattice}"><code>LatticeModels.AdjacencyMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjacencyMatrix(f, lat)</code></pre><p>Constructs an adjacency matrix from the function <code>f</code> that returns if the sites are connected on the <code>lat</code> lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L328-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AdjacencyMatrix-Tuple{LatticeModels.AbstractBonds, Vararg{LatticeModels.AbstractBonds}}" href="#LatticeModels.AdjacencyMatrix-Tuple{LatticeModels.AbstractBonds, Vararg{LatticeModels.AbstractBonds}}"><code>LatticeModels.AdjacencyMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjacencyMatrix([lat, ]bonds...)</code></pre><p>Constructs an adjacency matrix from the <code>bonds</code>. If <code>lat</code> is not provided, it is inferred from the <code>bonds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L303-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.SiteDistance" href="#LatticeModels.SiteDistance"><code>LatticeModels.SiteDistance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SiteDistance(f, lat)</code></pre><p>A bonds type that connects sites based on the distance between them.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function that takes a distance and returns if the distance is allowed.</li><li><code>lat</code>: The lattice where the bonds are defined.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Translation" href="#LatticeModels.Translation"><code>LatticeModels.Translation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Translation &lt;: AbstractTranslation</code></pre><p>A spatial translation on some lattice.</p><p><strong>Fields</strong></p><ul><li><code>lat</code>: The lattice where the translations are defined.</li><li><code>R</code>: The vector of the translation.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; gl = GenericLattice([(1, 1), (1, 2), (2, 1), (2, 2)])
4-site GenericLattice{GenericSite{2}} in 2D space:
  Site at [1.0, 1.0]
  Site at [1.0, 2.0]
  Site at [2.0, 1.0]
  Site at [2.0, 2.0]

julia&gt; tr = Translation(gl, [1, 0])     # Translation by [1, 0]
Translation by [1.0, 0.0]
 on 4-site GenericLattice{GenericSite{2}} in 2D space

julia&gt; site1 = gl[!, x = 1, y = 1]      # Site at [1, 1]
2-dim GenericSite{2} at [1.0, 1.0]

julia&gt; site1 + tr                       # Translated site
2-dim GenericSite{2} at [2.0, 1.0]

julia&gt; site1 - tr                       # Inverse translation
2-dim GenericSite{2} at [0.0, 1.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L429-L462">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.UndefinedLattice" href="#LatticeModels.UndefinedLattice"><code>LatticeModels.UndefinedLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UndefinedLattice</code></pre><p>A lattice that is not defined. The bonds can be &#39;defined&#39; on it in context where the lattice is already defined before, e. g. in <code>construct_operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L350-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.adapt_bonds-Tuple{Any, LatticeModels.AbstractLattice}" href="#LatticeModels.adapt_bonds-Tuple{Any, LatticeModels.AbstractLattice}"><code>LatticeModels.adapt_bonds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adapt_bonds(bonds, lat)</code></pre><p>Adapt the bonds to the lattice <code>lat</code>. The output can be a different type of bonds, more fitting for the concrete type of lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.adjacentsites-Tuple{AdjacencyMatrix, LatticeModels.AbstractSite}" href="#LatticeModels.adjacentsites-Tuple{AdjacencyMatrix, LatticeModels.AbstractSite}"><code>LatticeModels.adjacentsites</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">adjacentsites(bonds, site)</code></pre><p>Returns the sites that are connected to <code>site</code> by the <code>bonds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.sitedistance-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}" href="#LatticeModels.sitedistance-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}"><code>LatticeModels.sitedistance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sitedistance([lat, ]site1, site2)</code></pre><p>Returns the distance between two sites on the <code>lat</code> lattice, taking boundary conditions into account.</p><p><strong>Arguments</strong></p><ul><li><code>lat</code>: The lattice where the sites are defined.</li><li><code>site1</code> and <code>site2</code>: The sites to measure the distance between.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L119-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.translate_to_nearest-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}" href="#LatticeModels.translate_to_nearest-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}"><code>LatticeModels.translate_to_nearest</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">translate_to_nearest(lat, site1, site2)</code></pre><p>Translate <code>site2</code> to its equivalent nearest to <code>site1</code> in the lattice <code>lat</code>, taking the boundary conditions into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Bravais" href="#LatticeModels.Bravais"><code>LatticeModels.Bravais</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bravais[ lattice_coords ]</code></pre><p>A convenient constructor for a <code>BravaisTranslation</code> that does not permute sublattices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/bonds.jl#L28-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.BravaisTranslation" href="#LatticeModels.BravaisTranslation"><code>LatticeModels.BravaisTranslation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BravaisTranslation([site_indices, ]translate_uc)
BravaisTranslation(site_indices)
BravaisTranslation([site_indices; ]axis[, dist=1])</code></pre><p>A convenient constructor for a <code>BravaisTranslation</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>site_indices</code>: a <code>::Int =&gt; ::Int</code> pair with indices of sites connected by the bond;</li></ul><p>if omitted, the bond connects sites with the same sublattice index.</p><ul><li><code>translate_uc</code>: The unit cell offset.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>axis</code>: The hopping direction axis in terms of unit cell vectors.</li><li><code>dist</code>: The hopping distance in terms of unit cell vectors.</li></ul><p>If <code>site_indices</code> are equal or undefined and <code>translate_uc</code> is zero, the translation is considered to be a translation of all sites to themselves. An error will be thrown in this case.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/bonds.jl#L36-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.BravaisTranslation" href="#LatticeModels.BravaisTranslation"><code>LatticeModels.BravaisTranslation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BravaisTranslation{T, N}</code></pre><p>A struct representing bonds in some direction in a lattice.</p><p>Note that though the dimension count for the bond is static, it is automatically compatible with higher-dimensional lattices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/bonds.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.NearestNeighbor" href="#LatticeModels.NearestNeighbor"><code>LatticeModels.NearestNeighbor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NearestNeighbor(lat[, N=1])</code></pre><p>Returns the nearest neighbor bonds of order <code>N</code> for the lattice <code>lat</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; lat = HoneycombLattice(5, 5);

julia&gt; NearestNeighbor(lat)
BravaisSiteMapping with 3 translations:
  1 =&gt; 2, [0, -1]
  1 =&gt; 2, [-1, 0]
  1 =&gt; 2, [0, 0]
 on 50-site HoneycombLattice in 2D space

julia&gt; lat = SquareLattice(3, 3, 3, 3);

julia&gt; NearestNeighbor(lat, 4)
BravaisSiteMapping with 12 translations:
  Bravais[1, -1, -1, -1]
  Bravais[1, 1, -1, -1]
  Bravais[1, -1, 1, -1]
  Bravais[1, 1, 1, -1]
  Bravais[2, 0, 0, 0]
  Bravais[0, 2, 0, 0]
  Bravais[0, 0, 2, 0]
  Bravais[1, -1, -1, 1]
  Bravais[1, 1, -1, 1]
   ⋮
 on 81-site SquareLattice in 4D space</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/nearestneighbor.jl#L137-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.NearestNeighbor" href="#LatticeModels.NearestNeighbor"><code>LatticeModels.NearestNeighbor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NearestNeighbor{N}</code></pre><p>A bonds type that connects sites that are nearest neighbors of order <code>N</code> on some lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/nearestneighbor.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.getnnbonds-Tuple{LatticeModels.AbstractLattice}" href="#LatticeModels.getnnbonds-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.getnnbonds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getnnbonds(lat)</code></pre><p>Returns the nearest neighbor bonds of the lattice <code>lat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/nearestneighbor.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.setnnbonds-Tuple{LatticeModels.AbstractLattice, Vararg{LatticeModels.AbstractBonds}}" href="#LatticeModels.setnnbonds-Tuple{LatticeModels.AbstractLattice, Vararg{LatticeModels.AbstractBonds}}"><code>LatticeModels.setnnbonds</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setnnbonds(lat, args...; overwrite=false)</code></pre><p>Adds the nearest neighbor bonds <code>args</code> to the lattice <code>lat</code>. If <code>overwrite</code> is <code>true</code>, the default nearest neighbor bonds are replaced by <code>args</code>. Otherwise, the new bonds are merged with the default.</p><p>Each <code>args</code> can be a bonds type or a distance-bonds pair.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; lat = SquareLattice(3, 3);

julia&gt; lat2 = setnnbonds(lat, SiteDistance(0 .. 1), SiteDistance(1 .. 2));

julia&gt; lat2.nnbonds
Nearest neighbor hoppings:
  #1 =&gt;
    SiteDistance(0 .. 1)
  #2 =&gt;
    SiteDistance(1 .. 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/lattices/bravais/nearestneighbor.jl#L56-L79">source</a></section></article><h2 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.BoundaryConditions" href="#LatticeModels.BoundaryConditions"><code>LatticeModels.BoundaryConditions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BoundaryConditions</code></pre><p>A collection of boundary conditions for a lattice.</p><p><strong>Fields</strong></p><ul><li><code>bcs</code>: A tuple of boundary conditions.</li><li><code>depth</code>: The upper limit of the depth of the boundary conditions (used for routing).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/boundaries.jl#L111-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.FunctionBoundary" href="#LatticeModels.FunctionBoundary"><code>LatticeModels.FunctionBoundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FunctionBoundary &lt;: Boundary</code></pre><p>A boundary condition with a function that returns the phase factor for a given site. The boundary condition is encoded in form <span>$ψ(x + R) = f(x)ψ(x)$</span>, where <span>$f(x)$</span> is the function and <span>$R$</span> is the translation vector.</p><hr/><pre><code class="nohighlight hljs">FunctionBoundary(f, translation)</code></pre><p>Construct a <code>FunctionBoundary</code> with a given function and translation.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function that returns the phase factor for a given site.</li><li><code>translation</code>: The translation vector of the boundary representad as <code>AbstractTranslation</code>.   If an array is passed, it is converted to <code>Translation</code> automatically.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/boundaries.jl#L78-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.TwistedBoundary" href="#LatticeModels.TwistedBoundary"><code>LatticeModels.TwistedBoundary</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TwistedBoundary &lt;: Boundary</code></pre><p>A boundary condition with a phase twist. A <code>PeriodicBoundary</code> is a special case of <code>TwistedBoundary</code> with zero twist.</p><hr/><pre><code class="nohighlight hljs">TwistedBoundary(translation, Θ)</code></pre><p>Construct a <code>TwistedBoundary</code> with a given translation and twist angle.</p><p><strong>Arguments</strong></p><ul><li><code>translation</code>: The translation vector of the boundary representad as <code>AbstractTranslation</code>.   If an array is passed, it is converted to <code>Translation</code> automatically.</li><li><code>Θ</code>: The twist angle in radians.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/boundaries.jl#L31-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.PeriodicBoundary-Tuple{Any}" href="#LatticeModels.PeriodicBoundary-Tuple{Any}"><code>LatticeModels.PeriodicBoundary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundary(translation)</code></pre><p>Construct a <code>PeriodicBoundary</code> with a given translation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/boundaries.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.setboundaries-Tuple{LatticeModels.AbstractLattice, BoundaryConditions}" href="#LatticeModels.setboundaries-Tuple{LatticeModels.AbstractLattice, BoundaryConditions}"><code>LatticeModels.setboundaries</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">setboundaries(lat, boundaries...[; checkboundaries=true, rmdup=false])</code></pre><p>Set the boundary conditions for the lattice <code>lat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lat</code>: The lattice.</li><li><code>boundaries</code>: The boundary conditions. It can be a single <code>Boundary</code> or a <code>Tuple</code> of <code>Boundary</code> objects.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>checkboundaries</code>: If <code>true</code>, check if the boundary conditions overlap within the lattice sites.</li><li><code>rmdup</code>: If <code>true</code>, remove duplicate sites from the lattice.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = SquareLattice(4, 4);

julia&gt; l2 = setboundaries(l, [4, 0] =&gt; true, [0, 4] =&gt; pi);

julia&gt; l2.boundaries
Boundary conditions (depth = 1):
  Bravais[4, 0] → periodic
  Bravais[0, 4] → twist θ = 3.14</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/boundaries.jl#L191-L217">source</a></section></article><h2 id="LatticeValue"><a class="docs-heading-anchor" href="#LatticeValue">LatticeValue</a><a id="LatticeValue-1"></a><a class="docs-heading-anchor-permalink" href="#LatticeValue" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LatticeValue" href="#LatticeModels.LatticeValue"><code>LatticeModels.LatticeValue</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LatticeValue{T, LT}</code></pre><p>Represents a value of type <code>T</code> on a <code>LT</code> lattice.</p><p><strong>Fields</strong></p><ul><li>lattice: the <code>AbstractLattice</code> object the value is defined on</li><li>values: the values on different sites</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/latticevalue.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, AbstractVector}" href="#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, AbstractVector}"><code>LatticeModels.LatticeValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LatticeValue(lat, values)</code></pre><p>Constructs a LatticeValue object.</p><p><strong>Arguments</strong></p><ul><li><code>lat</code>: the lattice the value is defined on.</li><li><code>values</code>: an <code>AbstractVector</code> of values on the lattice.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = SquareLattice(2, 2);

julia&gt; LatticeValue(l, [1, 2, 3, 4])    # Custom values
LatticeValue{Int64} on a 4-site SquareLattice in 2D space
Values stored in a Vector{Int64}:
[1, 2, 3, 4]

julia&gt; x = LatticeValue(l, :x)          # x-coordinate
LatticeValue{Float64} on a 4-site SquareLattice in 2D space
Values stored in a Vector{Float64}:
[1.0, 1.0, 2.0, 2.0]

julia&gt; l2 = SquareLattice(3, 3);

julia&gt; y = LatticeValue(l2, :y)          # y-coordinate
LatticeValue{Float64} on a 9-site SquareLattice in 2D space
Values stored in a Vector{Float64}:
[1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0]

julia&gt; x + y
ERROR: Matching lattices expected.
Got following:
  #1: 4-site SquareLattice in 2D space
  #2: 9-site SquareLattice in 2D space
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/latticevalue.jl#L51-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, LatticeModels.SiteProperty}" href="#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, LatticeModels.SiteProperty}"><code>LatticeModels.LatticeValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LatticeValue(lat, prop)</code></pre><p>Generates a <code>LatticeValue</code> representing the site property <code>prop</code> on lattice <code>lat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lat</code>: the lattice the value is defined on.</li><li><code>prop</code>: the <code>SiteProperty</code> to be represented. Can be a <code>SiteProperty</code> or a <code>Symbol</code> defining it.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/latticevalue.jl#L102-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.brastate-Tuple{LatticeValue{T} where T}" href="#LatticeModels.brastate-Tuple{LatticeValue{T} where T}"><code>LatticeModels.brastate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">brastate(lv)</code></pre><p>Converts a <code>LatticeValue</code> to a <code>Bra</code> wavefunction vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/latticevalue.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.coordvalue-Tuple{LatticeModels.AbstractLattice, Int64}" href="#LatticeModels.coordvalue-Tuple{LatticeModels.AbstractLattice, Int64}"><code>LatticeModels.coordvalue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordvalue(lat, coord)</code></pre><p>Generates a <code>LatticeValue</code> representing the spatial coordinate <code>coord</code> on lattice <code>lat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lat</code>: the lattice the value is defined on.</li><li><code>coord</code>: the coordinate to be represented. Can be an integer or a symbol.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/latticevalue.jl#L114-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.coordvalues-Tuple{LatticeModels.AbstractLattice}" href="#LatticeModels.coordvalues-Tuple{LatticeModels.AbstractLattice}"><code>LatticeModels.coordvalues</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordvalues(lat)</code></pre><p>Generates a tuple of <code>LatticeValue</code>s representing spatial coordinates on lattice <code>lat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/latticevalue.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.ketstate-Tuple{LatticeValue{T} where T}" href="#LatticeModels.ketstate-Tuple{LatticeValue{T} where T}"><code>LatticeModels.ketstate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ketstate(lv)</code></pre><p>Converts a <code>LatticeValue</code> to a <code>Ket</code> wavefunction vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/latticevalue.jl#L282-L286">source</a></section></article><h2 id="Operators-and-observables"><a class="docs-heading-anchor" href="#Operators-and-observables">Operators and observables</a><a id="Operators-and-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-and-observables" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LatticeBasis" href="#LatticeModels.LatticeBasis"><code>LatticeModels.LatticeBasis</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LatticeBasis &lt;: QuantumOpticsBase.Basis</code></pre><p>Basis for a lattice system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/bases.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.coordoperator-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}, Any}" href="#LatticeModels.coordoperator-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}, Any}"><code>LatticeModels.coordoperator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordoperator(sys, crd)
coordoperator(basis, crd)
coordoperator(lat[, internal], crd)</code></pre><p>Generate a coordinate operator for the given lattice.</p><p><strong>Arguments</strong></p><ul><li><code>sys</code>: a <code>System</code> for which the coordinate operators are to be generated.</li><li><code>basis</code>: a one-particle <code>Basis</code> for which the coordinate operators are to be generated.</li><li><code>lat</code>: a lattice for which the coordinate operators are to be generated.</li><li><code>internal</code>: The basis for the internal degrees of freedom.</li><li><code>crd</code>: The coordinate to generate the operator for. Must be an integer representing the   coordinate index (e. g. <code>1</code> for x, <code>2</code> for y, etc.) or a symbol (e. g. <code>:x</code>, <code>:y</code>, etc.).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/miscoperators.jl#L36-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.coordoperators-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}" href="#LatticeModels.coordoperators-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>LatticeModels.coordoperators</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">coordoperators(sys)
coordoperators(basis)
coordoperators(lat[, internal])</code></pre><p>Generate a <code>Tuple</code> of coordinate operators for the given lattice.</p><p><strong>Arguments</strong></p><ul><li><code>sys</code>: a <code>System</code> for which the coordinate operators are to be generated.</li><li><code>basis</code>: a one-particle <code>Basis</code> for which the coordinate operators are to be generated.</li><li><code>lat</code>: a lattice for which the coordinate operators are to be generated.</li><li><code>internal</code>: The basis for the internal degrees of freedom.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/miscoperators.jl#L18-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.interaction-Tuple{Function, Type{&lt;:Number}, NParticles}" href="#LatticeModels.interaction-Tuple{Function, Type{&lt;:Number}, NParticles}"><code>LatticeModels.interaction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interaction(f, [T, ]sys)</code></pre><p>Create an two-site interaction operator for a given <code>NParticles</code> system. The function <code>f</code> takes two arguments, which are the two sites, and returns the interaction energy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/manybody.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.interaction-Union{Tuple{K}, Tuple{Function, Type{&lt;:Number}, NParticles, Val{K}}} where K" href="#LatticeModels.interaction-Union{Tuple{K}, Tuple{Function, Type{&lt;:Number}, NParticles, Val{K}}} where K"><code>LatticeModels.interaction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">interaction(f, [T, ]sys, K[; affect_internal=true])</code></pre><p>Create an <code>2K</code>-site interaction operator for a given <code>NParticles</code> system. The function <code>f</code> takes two <code>K</code>-tuples of integer numbers, which are site indices for creation and annihilation operators, and returns the interaction energy.</p><p>If <code>affect_internal</code> is <code>true</code> (default), the interaction operator will act on the internal degrees of freedom as well, and <code>f</code> will take four <code>K</code>-tuples — lattice and internal indices for creation and annihilation operators. If the system has no internal degrees of freedom, <code>affect_internal</code> will automatically be set to <code>false</code> and <code>f</code> will take two <code>K</code>-tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/manybody.jl#L34-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AdjacencyMatrix-Tuple{DataOperator{BT, BT} where BT&lt;:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}" href="#LatticeModels.AdjacencyMatrix-Tuple{DataOperator{BT, BT} where BT&lt;:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>LatticeModels.AdjacencyMatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjacencyMatrix(op::Operator)</code></pre><p>Generates an <code>AdjacencyMatrix</code> for the provided operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/latticeutils.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.localdensity-Tuple{Union{DataOperator{var&quot;#s237&quot;, var&quot;#s237&quot;}, Bra{var&quot;#s237&quot;}, Ket{var&quot;#s237&quot;}} where var&quot;#s237&quot;&lt;:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}" href="#LatticeModels.localdensity-Tuple{Union{DataOperator{var&quot;#s237&quot;, var&quot;#s237&quot;}, Bra{var&quot;#s237&quot;}, Ket{var&quot;#s237&quot;}} where var&quot;#s237&quot;&lt;:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>LatticeModels.localdensity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localdensity(state)</code></pre><p>Compute the local density of given <code>state</code>. The result is a <code>LatticeValue</code> with the same lattice as the input state.</p><p><strong>Arguments</strong></p><ul><li><code>state</code>: A <code>Ket</code> or <code>Bra</code> representing the wavefunction or an <code>Operator</code> representing the density matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/latticeutils.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.localexpect-Tuple{DataOperator, Union{DataOperator{var&quot;#s235&quot;, var&quot;#s235&quot;}, Bra{var&quot;#s235&quot;}, Ket{var&quot;#s235&quot;}} where var&quot;#s235&quot;&lt;:(CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT})}" href="#LatticeModels.localexpect-Tuple{DataOperator, Union{DataOperator{var&quot;#s235&quot;, var&quot;#s235&quot;}, Bra{var&quot;#s235&quot;}, Ket{var&quot;#s235&quot;}} where var&quot;#s235&quot;&lt;:(CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT})}"><code>LatticeModels.localexpect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">localexpect(op, state)</code></pre><p>Compute the expectation values of the operator <code>op</code> acting on the local Hilbert space of <code>state</code>. The result is a <code>LatticeValue</code> with the same lattice as the input state.</p><p><strong>Arguments</strong></p><ul><li><code>op</code>: A <code>DataOperator</code> representing the operator.</li><li><code>state</code>: A <code>Ket</code> or <code>Bra</code> representing the wavefunction or an <code>Operator</code> representing the density matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/latticeutils.jl#L3-L12">source</a></section></article><h2 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Hamiltonian" href="#LatticeModels.Hamiltonian"><code>LatticeModels.Hamiltonian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hamiltonian &lt;: QuantumOpticsBase.DataOperator</code></pre><p>A wrapper for a Hamiltonian operator. Contains the operator matrix and the system it acts on.</p><hr/><pre><code class="nohighlight hljs">Hamiltonian(sys, op)</code></pre><p>Create a Hamiltonian operator for a given system and a given operator.</p><p><strong>Arguments</strong></p><ul><li><code>sys</code>: the system the Hamiltonian acts on.</li><li><code>op</code>: the operator matrix.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = SquareLattice(4, 4);

julia&gt; H = tightbinding_hamiltonian(l)
Hamiltonian(dim=16x16)
System: One particle on 16-site SquareLattice in 2D space
16×16 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 48 stored entries:
⎡⠪⡢⠑⢄⠀⠀⠀⠀⎤
⎢⠑⢄⠪⡢⠑⢄⠀⠀⎥
⎢⠀⠀⠑⢄⠪⡢⠑⢄⎥
⎣⠀⠀⠀⠀⠑⢄⠪⡢⎦

julia&gt; l2 = SquareLattice(5, 5);

julia&gt; H2 = tightbinding_hamiltonian(l2)
Hamiltonian(dim=25x25)
System: One particle on 25-site SquareLattice in 2D space
25×25 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 80 stored entries:
⎡⠪⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠢⡈⠠⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠈⠢⡈⠊⡠⡈⠢⡀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠈⠢⡈⠪⠂⡈⠢⡀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠈⠢⡈⠪⡢⠈⠢⡀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠈⠢⡀⠪⡢⡀⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠈⠀⎦

julia&gt; H + H2
ERROR: Incompatible Hamiltonians:
  #1: One particle on 16-site SquareLattice in 2D space
  #2: One particle on 25-site SquareLattice in 2D space
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/system.jl#L279-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.NParticles-Union{Tuple{SampleT}, Tuple{SampleT, Any}} where SampleT&lt;:LatticeModels.Sample" href="#LatticeModels.NParticles-Union{Tuple{SampleT}, Tuple{SampleT, Any}} where SampleT&lt;:LatticeModels.Sample"><code>LatticeModels.NParticles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NParticles(lat[, internal], N[; T=0, statistics=FermiDirac])
NParticles(sys, N[; T=0, statistics=FermiDirac])</code></pre><p>Create a manybody system with a given lattice and a given number of particles.</p><p><strong>Arguments</strong></p><ul><li><code>lat</code>: the lattice of the system.</li><li><code>internal</code>: The basis for the internal degrees of freedom.</li><li><code>sys</code>: a one-particle system.</li><li><code>N</code>: the number of particles in the system.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>T</code>: the temperature of the system. Default is <code>0</code>.</li><li><code>statistics</code>: the statistics of the particles. Default is <code>FermiDirac</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; lat = SquareLattice(3, 3);

julia&gt; NParticles(lat, 4, statistics=BoseEinstein)
NParticles(4 bosons) on 9-site SquareLattice in 2D space</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/system.jl#L135-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.System-Tuple{LatticeModels.Sample}" href="#LatticeModels.System-Tuple{LatticeModels.Sample}"><code>LatticeModels.System</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">System(lat[, internal; T, μ, N, statistics])</code></pre><p>Create a system with a given lattice and optionally internal degrees of freedom.</p><p><strong>Arguments</strong></p><ul><li><code>lat</code>: the lattice of the system.</li><li><code>internal</code>: The basis for the internal degrees of freedom.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>T</code>: the temperature of the system. Default is <code>0</code>.</li><li><code>μ</code>: the chemical potential of the system. Use <code>mu</code> synonym if Unicode input is not available.</li><li><code>N</code>: the number of particles in the system.</li><li><code>statistics</code>: the statistics of the particles. Default is <code>FermiDirac</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; lat = SquareLattice(3, 3);

julia&gt; System(lat)
One particle on 9-site SquareLattice in 2D space

julia&gt; System(lat, N=4, statistics=BoseEinstein)
4 non-interacting bosons on 9-site SquareLattice in 2D space

julia&gt; System(lat, mu=0, statistics=BoseEinstein)
Non-interactng bosons with fixed μ=0.0 on 9-site SquareLattice in 2D space</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/system.jl#L178-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.sample-Tuple{LatticeBasis}" href="#LatticeModels.sample-Tuple{LatticeBasis}"><code>LatticeModels.sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns the <code>Sample</code> of the object.</p><p>Define this function for your type to implement <code>Sample</code> API.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This function can be considered stable internal API. Feel free to use it in your packages.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/system.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.OperatorBuilder" href="#LatticeModels.OperatorBuilder"><code>LatticeModels.OperatorBuilder</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OperatorBuilder</code></pre><p>A helper struct for building custom operators. This struct is used to build operators for a given system or lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/builder.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.OperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{&lt;:Number}, SystemT}} where {SystemT&lt;:System, FieldT&lt;:LatticeModels.AbstractField}" href="#LatticeModels.OperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{&lt;:Number}, SystemT}} where {SystemT&lt;:System, FieldT&lt;:LatticeModels.AbstractField}"><code>LatticeModels.OperatorBuilder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OperatorBuilder([T, ]sys, [; field, auto_hermitian, occupations_type])
OperatorBuilder([T, ]lat, [internal; field, auto_hermitian, occupations_type])</code></pre><p>Construct an <code>OperatorBuilder</code> for a given system or lattice.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The type of the matrix elements. Defaults to <code>ComplexF64</code>.</li><li><code>sys</code>: A <code>System</code> object representing the system.</li><li><code>lat</code>: The lattice on which the operator is defined.</li><li><code>internal</code>: The basis for the internal degrees of freedom.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>field</code>: The gauge field to use for the bond operators. Defaults to <code>NoField()</code>, which   corresponds to zero magnetic field.</li><li><code>auto_hermitian</code>: Whether to automatically add the hermitian conjugate of the operator.   Defaults to <code>false</code>.</li><li><code>occupations_type</code>: The occupations type for the many-body operator. Ignored for one-body   operators. By default, the occupation numbers are stored in vectors.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = SquareLattice(5, 5);

julia&gt; builder = OperatorBuilder(l, field=LandauGauge(0.1), auto_hermitian=true)
OperatorBuilder(field=LandauGauge(0.1), auto_hermitian=true)
System: One particle on 25-site SquareLattice in 2D space

julia&gt; hx = Bravais[1, 0]; hy = Bravais[0, 1];

julia&gt; for site in l; builder[site, site + hx] = builder[site, site + hy] = 1; end

julia&gt; H = Hamiltonian(builder)
Hamiltonian(dim=25x25)
System: One particle on 25-site SquareLattice in 2D space
25×25 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 80 stored entries:
⎡⠪⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠢⡈⠠⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠈⠢⡈⠊⡠⡈⠢⡀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠈⠢⡈⠪⠂⡈⠢⡀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠈⠢⡈⠪⡢⠈⠢⡀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠈⠢⡀⠪⡢⡀⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠈⠀⎦

julia&gt; H == tightbinding_hamiltonian(l, field=LandauGauge(0.1))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/builder.jl#L103-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.FastOperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{&lt;:Number}, SystemT}} where {SystemT&lt;:System, FieldT&lt;:LatticeModels.AbstractField}" href="#LatticeModels.FastOperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{&lt;:Number}, SystemT}} where {SystemT&lt;:System, FieldT&lt;:LatticeModels.AbstractField}"><code>LatticeModels.FastOperatorBuilder</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FastOperatorBuilder([T, ]sys, [; field, auto_hermitian, occupations_type])
FastOperatorBuilder([T, ]lat, [internal; field, auto_hermitian, occupations_type])</code></pre><p>Construct an <code>OperatorBuilder</code> for a given system or lattice. This version of the constructor uses a slightly faster internal representation of the operator matrix, but only allows increment/decrement assignments: <code>builder[site1, site2] += 1</code> is allowed, but <code>builder[site1, site2] = 1</code> is not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/builder.jl#L161-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.construct_hamiltonian-Tuple{Type, System, Vararg{Any}}" href="#LatticeModels.construct_hamiltonian-Tuple{Type, System, Vararg{Any}}"><code>LatticeModels.construct_hamiltonian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_hamiltonian([T, ]sys, terms...[; field])
construct_hamiltonian([T, ]lat[, internal, terms...; field])</code></pre><p>Construct a Hamiltonian for the given system. Does the same as <code>construct_operator</code>, but wraps the result in a <code>Hamiltonian</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/constructoperator.jl#L125-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.construct_operator-Tuple{Type, System, Vararg{Any}}" href="#LatticeModels.construct_operator-Tuple{Type, System, Vararg{Any}}"><code>LatticeModels.construct_operator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_operator([T, ]sys, terms...[; field])
construct_operator([T, ]lat[, internal, terms...; field])</code></pre><p>Construct an operator for the given system.</p><p>Each of the <code>terms</code> describes a term of the Hamiltonian. The term can be given in several ways:</p><ul><li>A <code>DataOperator</code> on the lattice, internal or composite basis (will be matched automatically).</li><li>A <code>Pair</code> of an &quot;internal&quot; and an &quot;on-lattice&quot; part (e.g. <code>int_p =&gt; lat_p</code>):<ul><li>The &quot;internal&quot; part can be a <code>DataOperator</code>, a matrix or a number.</li><li>The &quot;on-lattice&quot; part can be a <code>LatticeValue</code> (represents a diagonal term), a site   (represents a local on-site potential), a bond (represents a hopping term) or a <code>site1 =&gt; site2</code>   pair (represents a single hopping).</li><li>Identity &quot;internal&quot; or &quot;on-lattice&quot; parts can be omitted.</li></ul></li></ul><p>See documentation for more details.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The element type of the Hamiltonian. Default is <code>ComplexF64</code>.</li><li><code>sys</code>: The <code>System</code> for which the Hamiltonian is constructed.</li><li><code>lat</code>: The lattice for which the Hamiltonian is constructed.</li><li><code>internal</code>: The basis for the internal degrees of freedom.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>field</code>: The gauge field to use for the bond operators. Default is <code>NoField()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/constructoperator.jl#L86-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.tightbinding_hamiltonian-Tuple{Type, System, Vararg{Any}}" href="#LatticeModels.tightbinding_hamiltonian-Tuple{Type, System, Vararg{Any}}"><code>LatticeModels.tightbinding_hamiltonian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tightbinding_hamiltonian([T, ]sys[, args...; t1=1, t2=0, t3=0, field])
tightbinding_hamiltonian([T, ]lat[, internal, args...; t1=1, t2=0, t3=0, field])</code></pre><p>Construct a tight-binding Hamiltonian for the given system.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The element type of the Hamiltonian. Default is <code>ComplexF64</code>.</li><li><code>sys</code>: The <code>System</code> for which the Hamiltonian is constructed.</li><li><code>lat</code>: The lattice for which the Hamiltonian is constructed.</li><li><code>internal</code>: The basis for the internal degrees of freedom.</li></ul><p>All other arguments are interpreted as terms of the Hamiltonian and passed to <code>construct_hamiltonian</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>t1</code>, <code>t2</code>, <code>t3</code>: The hopping amplitudes for the nearest, next-nearest, and next-next-nearest   neighbors, respectively.</li><li><code>field</code>: The gauge field to use for the bond operators. Default is <code>NoField()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/constructoperator.jl#L136-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GaugeField" href="#LatticeModels.GaugeField"><code>LatticeModels.GaugeField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GaugeField &lt;: AbstractField</code></pre><p>A gauge field defined by a vector potential function.</p><hr/><pre><code class="nohighlight hljs">GaugeField(func; n)</code></pre><p>Create a gauge field with a given vector potential function <code>func</code>.</p><p><strong>Arguments</strong></p><ul><li><code>func</code>: a function that takes a point in space and returns the vector potential at this point as a <code>SVector</code> or <code>Tuple</code>.</li><li><code>n</code>: the number of steps to use in the trapezoidal rule integration.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">field = GaugeField(n = 10) do p
    (-0.5 * p[2], 0.5 * p[1], 0)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/magneticfield.jl#L45-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LineIntegralGaugeField" href="#LatticeModels.LineIntegralGaugeField"><code>LatticeModels.LineIntegralGaugeField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LineIntegralGaugeField &lt;: AbstractField</code></pre><p>A gauge field defined by a line integral function.</p><hr/><pre><code class="nohighlight hljs">LineIntegralGaugeField(func)</code></pre><p>Create a gauge field with a given line integral function <code>func</code>. The function should take two points in space and return the line integral of the vector potential between these points.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">field = LineIntegralGaugeField() do p1, p2
    0.5 * (p1[1] * p2[2] - p1[2] * p2[1])   # A = [-y/2, x/2, 0]
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/magneticfield.jl#L75-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.NoField" href="#LatticeModels.NoField"><code>LatticeModels.NoField</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoField &lt;: AbstractField</code></pre><p>A stub object representing zero magnetic field. Use it as a default magnetic field argument in functions — this will not cause any performance overhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/magneticfield.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}" href="#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}"><code>LatticeModels.line_integral</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">line_integral(field, p1, p2[, n_steps=1])</code></pre><p>Calculates the <span>$\int_{p1}^{p2} \overrightarrow{A} \cdot \overrightarrow{dl}$</span> integral using the trapezoidal rule. Increase <code>n_steps</code> to improve accuracy (note that for linear field gauges like Landau or symmetrical the formula is already pefrectly accurate). If needed, redefine this function for specific field types — this is likely to boost accuracy and performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/magneticfield.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}" href="#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}"><code>LatticeModels.vector_potential</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_potential(field, point)</code></pre><p>Returns vector potential <span>$\overrightarrow{A}$</span> for <code>field</code> in location <code>point</code>.</p><p>This function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/operators/magneticfield.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LandauGauge" href="#LatticeModels.LandauGauge"><code>LatticeModels.LandauGauge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LandauGauge &lt;: AbstractField</code></pre><p>An object representing Landau gauge uniform magnetic field along z-axis.</p><p><strong>Fields</strong></p><ul><li><code>B</code>: The magnetic field value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.PointFlux" href="#LatticeModels.PointFlux"><code>LatticeModels.PointFlux</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointFlux(flux, [point; gauge])</code></pre><p>Construct a <code>PointFlux</code> object with given flux and point.</p><p>The optional <code>gauge</code> argument can be used to specify the gauge of the field. Possible values are <code>:axial</code> (<span>$A(r) = B \times \frac{r}{|r|}$</span>) and <code>:singular</code> (the the phase changes if the particle passes below the point). The default is <code>:axial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.PointFlux" href="#LatticeModels.PointFlux"><code>LatticeModels.PointFlux</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointFlux{GaugeT} &lt;: AbstractField</code></pre><p>An object representing a small magnetic flux through given point. The field is directed along z-axis.</p><p><strong>Fields</strong></p><ul><li><code>flux</code>: The magnetic flux value.</li><li><code>point</code>: A <code>Tuple</code> of x and y coordinates of the point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L36-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.PointFluxes" href="#LatticeModels.PointFluxes"><code>LatticeModels.PointFluxes</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointFluxes{GaugeT} &lt;: AbstractField</code></pre><p>An object representing a collection of small magnetic fluxes through given points. The field is directed along z-axis.</p><p><strong>Fields</strong></p><ul><li><code>fluxes</code>: The magnetic flux values.</li><li><code>points</code>: A vector of <code>NTuple{2,Float64}</code> points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L110-L118">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.PointFluxes-Tuple{AbstractVector, AbstractVector}" href="#LatticeModels.PointFluxes-Tuple{AbstractVector, AbstractVector}"><code>LatticeModels.PointFluxes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointFluxes(fluxes, points[; offset=(0, 0), gauge=:axial])</code></pre><p>Construct a <code>PointFluxes</code> object with given fluxes and points.</p><p>The optional <code>gauge</code> argument can be used to specify the gauge of the field.</p><p><strong>Arguments</strong></p><ul><li><code>fluxes</code>: A vector of flux values. Also can be a single value, in which case it will be broadcasted to all points.</li><li><code>points</code>: A vector of points or a <code>AbstractLattice</code> object. In the latter case the sites will be interpreted as points.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>offset</code>: An offset to add to the points, default is <code>(0, 0)</code>. Valid only if <code>points</code> is a <code>AbstractLattice</code>, otherwise an error is thrown.</li><li><code>gauge</code>: The gauge of the field. Possible values are <code>:axial</code> and <code>:singular</code>. The default is <code>:axial</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.PointFluxes-Tuple{Any}" href="#LatticeModels.PointFluxes-Tuple{Any}"><code>LatticeModels.PointFluxes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointFluxes(fields[; gauge])</code></pre><p>Construct a <code>PointFluxes</code> object from a collection of <code>PointFlux</code> objects.</p><p>An error is thrown if the gauges of the fields are inconsistent. You can specify the gauge of the field explicitly using the <code>gauge</code> keyword argument.</p><p>See also: <a href="#LatticeModels.PointFlux"><code>PointFlux</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L153-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.SymmetricGauge" href="#LatticeModels.SymmetricGauge"><code>LatticeModels.SymmetricGauge</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SymmetricGauge &lt;: AbstractField</code></pre><p>An object representing symmetrically gauged uniform magnetic field along z-axis.</p><p><strong>Fields</strong></p><ul><li><code>B</code>: The magnetic field value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.periodic_fluxes-Tuple{Union{LatticeModels.BravaisLattice, LatticeModels.LatticeWithMetadata{&lt;:LatticeModels.BravaisLattice}}, PointFlux}" href="#LatticeModels.periodic_fluxes-Tuple{Union{LatticeModels.BravaisLattice, LatticeModels.LatticeWithMetadata{&lt;:LatticeModels.BravaisLattice}}, PointFlux}"><code>LatticeModels.periodic_fluxes</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">periodic_fluxes(l, fl)</code></pre><p>Construct a <code>PointFluxes</code> object by periodic replication of a point flux over a Bravais lattice.</p><p><strong>Arguments</strong></p><ul><li><code>l</code>: A Bravais lattice.</li><li><code>fl</code>: A <code>PointFlux</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/magneticfields.jl#L185-L193">source</a></section></article><h2 id="Built-in-models"><a class="docs-heading-anchor" href="#Built-in-models">Built-in models</a><a id="Built-in-models-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.bosehubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}" href="#LatticeModels.bosehubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}"><code>LatticeModels.bosehubbard</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bosehubbard([type, ]lat, N[; U, T, t1, t2, t3, field])</code></pre><p><span>$\hat{H} = \sum_{i,j}^\text{sites} t_{ij} c^\dagger_i c_j + \sum_i^\text{sites} \frac{U}{2} \hat{n}_i (\hat{n}_i - 1)$</span></p><p>Generates a Bose-Hubbard model hamiltonian on given lattice <code>lat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>type</code>: The element type of the resulting operator. Default is <code>ComplexF64</code>.</li><li><code>N</code>: The number of particles.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>t1</code>, <code>t2</code>, <code>t3</code> denote the coefficient on first, second and third hoppings respectively.   By default <code>t1</code> is equal to one, the rest are zero.</li><li><code>U</code>: The interaction strength. Default is zero.</li><li><code>T</code>: The temperature of the system. Default is zero.</li><li><code>field</code>: The magnetic field. Default is <code>NoField()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/models.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.fermihubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}" href="#LatticeModels.fermihubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}"><code>LatticeModels.fermihubbard</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermihubbard([type, ]lat, N[; U, T, t1, t2, t3, field])</code></pre><p><span>$\hat{H} = \sum_{i,j}^\text{sites} t_{ij} c^\dagger_i c_j + \sum_i^\text{sites} U \hat{n}_i^{\uparrow} \hat{n}_i^{\downarrow}$</span></p><p>Generates a Fermi-Hubbard model hamiltonian on given lattice <code>lat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>type</code>: The element type of the resulting operator. Default is <code>ComplexF64</code>.</li><li><code>N</code>: The number of particles.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>t1</code>, <code>t2</code>, <code>t3</code> denote the coefficient on first, second and third hoppings respectively.   By default <code>t1</code> is equal to one, the rest are zero.</li><li><code>U</code>: The interaction strength. Default is zero.</li><li><code>T</code>: The temperature of the system. Default is zero.</li><li><code>field</code>: The magnetic field. Default is <code>NoField()</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/models.jl#L37-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.haldane" href="#LatticeModels.haldane"><code>LatticeModels.haldane</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">haldane(lat, t1, t2[, m=0; T, μ, field, statistics])</code></pre><p><span>$\hat{H} = \sum_i^\text{sublattice A} m c^\dagger_i c_i + \sum_j^\text{sublattice B} m c^\dagger_j c_j + \sum_{i, j}^\text{adjacent} \left( t_1 c^\dagger_i c_j + h. c. \right) + \sum_{i, j}^\text{2-connected, counter-clockwise} \left( i \cdot t_2 c^\dagger_i c_j + h. c. \right)$</span></p><p>Generates a Haldane topological insulator hamiltonian operator on given lattice <code>lat</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T</code>: The temperature of the system. Default is zero.</li><li><code>μ</code>: The chemical potential. Use <code>mu</code> as a synonym if Unicode input is not available.</li><li><code>field</code>: The magnetic field. Default is <code>NoField()</code>.</li><li><code>statistics</code> defines the particle statistics, either <code>FermiDirac</code> or <code>BoseEinstein</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/models.jl#L103-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.hubbard-Tuple{Type, NParticles, Vararg{Any}}" href="#LatticeModels.hubbard-Tuple{Type, NParticles, Vararg{Any}}"><code>LatticeModels.hubbard</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hubbard([type, ]sys[; U, T, t1, t2, t3, field])</code></pre><p>Generates a Hubbard model hamiltonian on given manybody system <code>sys</code>.</p><p>See <a href="#LatticeModels.fermihubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}"><code>fermihubbard</code></a>, <a href="#LatticeModels.bosehubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}"><code>bosehubbard</code></a> for more specific models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/models.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.kanemele-Tuple{System, Real, Real}" href="#LatticeModels.kanemele-Tuple{System, Real, Real}"><code>LatticeModels.kanemele</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kanemele(lat, t1, t2[; T, μ, field, statistics])</code></pre><p><span>$\hat{H} = \sum_{i, j}^\text{adjacent} \left( t_1 c^\dagger_i c_j + h. c. \right) + \sum_{i, j}^\text{2-connected, counter-clockwise} \left( i \cdot t_2 c^\dagger_i σ_z c_j + h. c. \right)$</span></p><p>Generates a Kane-Mele hamiltonian operator on given lattice <code>lat</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T</code>: The temperature of the system. Default is zero.</li><li><code>μ</code>: The chemical potential. Use keyword <code>mu</code> as a synonym if Unicode input is not available.</li><li><code>field</code>: The magnetic field. Default is <code>NoField()</code>.</li><li><code>statistics</code> defines the particle statistics, either <code>FermiDirac</code> or <code>BoseEinstein</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/models.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.qwz-Tuple{LatticeValue{T} where T}" href="#LatticeModels.qwz-Tuple{LatticeValue{T} where T}"><code>LatticeModels.qwz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qwz(m[; T, μ, field, statistics])
qwz(lat[, m; T, μ, field, statistics])</code></pre><p><span>$\hat{H} = \sum_i^\text{sites} m_i c^\dagger_i \sigma_z c_i + \sum_i^\text{sites} \left( c^\dagger_{i + \hat{x}} \frac{\sigma_z - i \sigma_x}{2} c_i + c^\dagger_{i + \hat{y}} \frac{\sigma_z - i \sigma_y}{2} c_i + h. c. \right)$</span></p><p>Generates a QWZ model hamiltonian operator on given square lattice <code>lat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>m</code> (either a <code>LatticeValue</code> or a number) defines the <span>$m_i$</span> factors</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>T</code>: The temperature of the system. Default is zero.</li><li><code>μ</code>: The chemical potential. Use <code>mu</code> as a synonym if Unicode input is not available.</li><li><code>field</code>: The magnetic field. Default is <code>NoField()</code>.</li><li><code>statistics</code> defines the particle statistics, either <code>FermiDirac</code> or <code>BoseEinstein</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/models.jl#L63-L84">source</a></section></article><h2 id="Diagonalization"><a class="docs-heading-anchor" href="#Diagonalization">Diagonalization</a><a id="Diagonalization-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonalization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Eigensystem" href="#LatticeModels.Eigensystem"><code>LatticeModels.Eigensystem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Eigensystem{LT, MT} where {LT&lt;:AbstractLattice, MT&lt;:AbstractMatrix}</code></pre><p>Eigenvalues and eigenvectors for some operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/spectrum.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.FixedMu}}" href="#LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.FixedMu}}"><code>LatticeModels.densitymatrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">densitymatrix(eig::Eigensystem[; T=0, μ, N, statistics, info=true])</code></pre><p>Creates an <code>Operator</code> representing a equilibrium density matrix, given the eigensystem <code>eig</code> of the Hamiltonian.</p><p>The resulting distribution will be Fermi-Dirac or Bose-Einstein if the <code>statistics</code> is specified, otherwise the Gibbs distribution will be used.</p><p><strong>Keyword arguments</strong></p><ul><li><code>T</code> is the temperature of the system. Default is zero.</li><li><code>μ</code> is the chemical potential. Use <code>mu</code> as a synonym if Unicode input is not available.</li><li><code>N</code> is the number of particles. If specified, the chemical potential is found automatically.</li><li><code>statistics</code> defines the particle statistics, either <code>FermiDirac</code> or <code>BoseEinstein</code>.</li><li><code>info</code> is a boolean flag to enable/disable logging. Default is <code>true</code>.</li></ul><p>Note that if <code>eig</code> is a diagonalized <code>Hamiltonian</code>, the <code>μ</code>, <code>N</code> and <code>statistics</code> parameters are inserted automatically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/spectrum.jl#L290-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.diagonalize-Tuple{Hamiltonian, Val}" href="#LatticeModels.diagonalize-Tuple{Hamiltonian, Val}"><code>LatticeModels.diagonalize</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagonalize(op::DataOperator[, routine; params...])</code></pre><p>Finds eigenvalues and eigenvectors for a <code>Operator</code> and stores them in an <code>Eigensystem</code>.</p><p>Two routines are available:</p><ul><li><code>:lapack</code> uses the <code>eigen</code> function from the standard <code>LinearAlgebra</code> package.</li><li><code>:krylovkit</code> uses the Lanczos algorithm from the <code>KrylovKit</code> package.   Accepts following parameters:<ul><li><code>v0</code> is the starting vector. Default is <code>rand(ComplexF64, size(op.data, 1))</code>.</li><li><code>n</code> is the target number of eigenvectors. Default is 10.</li></ul>All other keyword arguments are passed to the <code>KrylovKit.eigsolve</code> function. See its documentation for details.</li><li><code>:auto</code> automatically selects the routine based on the size of the operator.</li></ul><p>The default routine is <code>:lapack</code> for dense operators. If the operator matrix is less than 5000×5000, it is automatically converted to a dense operator. In other cases <code>:krylovkit</code> is used.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; l = SquareLattice(4, 4);

julia&gt; H = tightbinding_hamiltonian(l)
Hamiltonian(dim=16x16)
System: One particle on 16-site SquareLattice in 2D space
16×16 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 48 stored entries:
⎡⠪⡢⠑⢄⠀⠀⠀⠀⎤
⎢⠑⢄⠪⡢⠑⢄⠀⠀⎥
⎢⠀⠀⠑⢄⠪⡢⠑⢄⎥
⎣⠀⠀⠀⠀⠑⢄⠪⡢⎦

julia&gt; eig = diagonalize(H)
Diagonalized Hamiltonian (16 eigenvectors)
Eigenvalues in range -3.23607 .. 3.23607
System: One particle on 16-site SquareLattice in 2D space</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/spectrum.jl#L69-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.findgroundstate-Tuple{LatticeModels.HamiltonianEigensystem}" href="#LatticeModels.findgroundstate-Tuple{LatticeModels.HamiltonianEigensystem}"><code>LatticeModels.findgroundstate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findgroundstate(eig::HamiltonianEigensystem)
findgroundstate(ham::Hamiltonian)</code></pre><p>Finds the ground state of a Hamiltonian. Returns the energy and the state.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">eig = diagonalize(ham)
E, ψ = findgroundstate(eig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/spectrum.jl#L180-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.groundstate-Tuple{Any}" href="#LatticeModels.groundstate-Tuple{Any}"><code>LatticeModels.groundstate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">groundstate(eig::HamiltonianEigensystem)
groundstate(ham::Hamiltonian)</code></pre><p>Finds the ground state of a Hamiltonian. Returns the state.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">eig = diagonalize(ham)
ψ = groundstate(eig)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/spectrum.jl#L195-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.projector-Tuple{Any, LatticeModels.AbstractEigensystem}" href="#LatticeModels.projector-Tuple{Any, LatticeModels.AbstractEigensystem}"><code>LatticeModels.projector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">projector(f, eig::Eigensystem)</code></pre><p>Returns an <code>Operator</code> representing a function applied to the diagonalized operator defined by the formula below:</p><p><span>$\hat{\mathcal{P}} = \sum_i f(A_i) |\psi_i⟩⟨\psi_i|$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/spectrum.jl#L219-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.projector-Tuple{LatticeModels.AbstractEigensystem}" href="#LatticeModels.projector-Tuple{LatticeModels.AbstractEigensystem}"><code>LatticeModels.projector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">projector(eig::Eigensystem)</code></pre><p>returns an <code>Operator</code> that projects onto the eigenvectors of the spectrum, defined by the formula below.</p><p><span>$\hat{\mathcal{P}} = \sum_i |\psi_i⟩⟨\psi_i|$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/spectrum.jl#L209-L215">source</a></section></article><h2 id="Green&#39;s-function"><a class="docs-heading-anchor" href="#Green&#39;s-function">Green&#39;s function</a><a id="Green&#39;s-function-1"></a><a class="docs-heading-anchor-permalink" href="#Green&#39;s-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.GreenFunction" href="#LatticeModels.GreenFunction"><code>LatticeModels.GreenFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GreenFunction</code></pre><p>A Green&#39;s function for a given lattice and Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/greenfunction.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.diagonalelements-Tuple{LatticeModels.GreenFunctionEval{&lt;:System{&lt;:LatticeModels.Sample{LT, Nothing} where LT}}}" href="#LatticeModels.diagonalelements-Tuple{LatticeModels.GreenFunctionEval{&lt;:System{&lt;:LatticeModels.Sample{LT, Nothing} where LT}}}"><code>LatticeModels.diagonalelements</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diagonalelements(gf::GreenFunctionEval)</code></pre><p>Return the diagonal elements of the Green&#39;s function as a <code>LatticeValue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/greenfunction.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.dos-Tuple{LatticeModels.AbstractEigensystem, Any}" href="#LatticeModels.dos-Tuple{LatticeModels.AbstractEigensystem, Any}"><code>LatticeModels.dos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dos(eig[, E; broaden])
dos(gf[, E; broaden])</code></pre><p>Calculates the DOS (density of states) for a given eigensystem at energy <code>E</code>. If <code>E</code> is not specified, a function that calculates the DOS at a given energy is returned.</p><p><strong>Arguments</strong></p><ul><li><code>eig</code> is an <code>Eigensystem</code> or <code>HamiltonianEigensystem</code>.</li><li><code>gf</code> is a <code>GreenFunction</code>.</li><li><code>E</code> is the energy at which the DOS is calculated.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>broaden</code> is the broadening factor for the energy levels, default is <code>0.1</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/greenfunction.jl#L291-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.greenfunction-Tuple{Any, Ket, Hamiltonian, Hamiltonian}" href="#LatticeModels.greenfunction-Tuple{Any, Ket, Hamiltonian, Hamiltonian}"><code>LatticeModels.greenfunction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">greenfunction(psi0, hamp, hamm[; E₀, tol, showprogress, kw...])</code></pre><p>Calculates the Green&#39;s function for a many-body system with a given initial state <code>psi0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>psi0</code> is the initial state.</li><li><code>hamp</code> is the Hamiltonian for the subspace with one more particle than in <code>psi0</code>.</li><li><code>hamm</code> is the Hamiltonian for the subspace with one less particle than in <code>psi0</code>.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>E₀</code> is the energy shift for the Green&#39;s function. Default is <code>0</code>. Use <code>E0</code> as a synonym   if Unicode input is not available.</li><li><code>tol</code> is the tolerance for the new eigenvectors. Default is <code>1e-5</code>.</li><li><code>showprogress</code> is a flag to show the progress bar. Default is <code>true</code>.</li></ul><p>All other keyword arguments are passed to the <code>diagonalize</code> function. See its documentation for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/greenfunction.jl#L208-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.greenfunction-Tuple{Any, LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.OneParticleBasisSystem}}" href="#LatticeModels.greenfunction-Tuple{Any, LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.OneParticleBasisSystem}}"><code>LatticeModels.greenfunction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">greenfunction(ham_eig::HamiltonianEigensystem)</code></pre><p>Creates a Green&#39;s function for a given one-body Hamiltonian eigensystem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/greenfunction.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.ldos-Tuple{GreenFunction, Real, LatticeModels.AbstractSite}" href="#LatticeModels.ldos-Tuple{GreenFunction, Real, LatticeModels.AbstractSite}"><code>LatticeModels.ldos</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ldos(gf::GreenFunction, E[, site; broaden])
ldos(gf::GreenFunction, site[; broaden])</code></pre><p>Calculates the LDOS (local density of states) for a given Green&#39;s function at energy <code>E</code>. <code>broaden</code> is the broadening factor for the energy levels, default is <code>0.1</code>.</p><p>If <code>site</code> is not specified, the LDOS for all sites is calculated and returned as a <code>LatticeValue</code>. Otherwise, the LDOS for the given site is returned as a <code>Real</code> value.</p><p>If <code>E</code> is not specified, a function that calculates the LDOS at site <code>site</code> for given energy is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/greenfunction.jl#L316-L328">source</a></section></article><h2 id="Currents"><a class="docs-heading-anchor" href="#Currents">Currents</a><a id="Currents-1"></a><a class="docs-heading-anchor-permalink" href="#Currents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Currents" href="#LatticeModels.Currents"><code>LatticeModels.Currents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Currents &lt;: AbstractCurrents</code></pre><p>A <code>AbstractCurrents</code> instance that stores values for all currents explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/currents.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Currents-Tuple{LatticeModels.AbstractCurrents}" href="#LatticeModels.Currents-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.Currents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Currents(currents[, adjacency_matrix])</code></pre><p>Creates a <code>Currents</code> instance for <code>currents</code>.</p><p><strong>Arguments</strong></p><ul><li><code>currents</code>: The <code>AbstractCurrents</code> object to be turned into <code>Currents</code>. That might be time-consuming,   because  this requires evaluation of the current between all pairs.</li><li><code>adjacency_matrix</code>: If provided, the current will be evaluated only between adjacent sites.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; lat = SquareLattice(4, 4); site1, site2 = lat[1:2];

julia&gt; H0 = tightbinding_hamiltonian(lat); psi = groundstate(H0);

julia&gt; H1 = tightbinding_hamiltonian(lat, field=LandauGauge(0.1));

julia&gt; currents = DensityCurrents(H1, psi)
Density currents for system:
One particle on 16-site SquareLattice in 2D space

julia&gt; c2 = Currents(currents)
Currents{SparseArrays.SparseMatrixCSC{Float64, Int64}} on 16-site SquareLattice in 2D space

julia&gt; c2[site1, site2] ≈ currents[site1, site2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/currents.jl#L192-L222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.DensityCurrents" href="#LatticeModels.DensityCurrents"><code>LatticeModels.DensityCurrents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DensityCurrents &lt;: AbstractCurrents</code></pre><p>Density currents for given state and given hamiltonian.</p><hr/><pre><code class="nohighlight hljs">DensityCurrents(hamiltonian, state)</code></pre><p>Constructs a <code>DensityCurrents</code> object for given <code>hamiltonian</code> and <code>state</code>.</p><p><strong>Arguments</strong></p><ul><li><code>hamiltonian</code>: A <code>Hamiltonian</code> object representing the Hamiltonian of the system.</li><li><code>state</code>: A <code>Ket</code> or <code>Bra</code> representing the wavefunction or an <code>Operator</code> representing the density matrix.</li></ul><p><strong>Example</strong></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; lat = SquareLattice(4, 4);

julia&gt; H0 = tightbinding_hamiltonian(lat); psi = groundstate(H0);

julia&gt; H1 = tightbinding_hamiltonian(lat, field=LandauGauge(0.1));

julia&gt; currents = DensityCurrents(H1, psi)
Density currents for system:
One particle on 16-site SquareLattice in 2D space</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/currents.jl#L51-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LocalOperatorCurrents" href="#LatticeModels.LocalOperatorCurrents"><code>LatticeModels.LocalOperatorCurrents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LocalOperatorCurrents &lt;: AbstractCurrents</code></pre><p>Local operator (e. g. spin) currents for given state and given hamiltonian.</p><hr/><pre><code class="nohighlight hljs">LocalOperatorCurrents(hamiltonian, state, op)</code></pre><p>Constructs a <code>DensityCurrents</code> object for given <code>hamiltonian</code> and <code>state</code>.</p><p><strong>Arguments</strong></p><ul><li><code>hamiltonian</code>: A <code>Hamiltonian</code> object representing the Hamiltonian of the system.</li><li><code>state</code>: A <code>Ket</code> or <code>Bra</code> representing the wavefunction or an <code>Operator</code> representing the density matrix.</li><li><code>op</code>: A local (on-site) operator; either an <code>Operator</code> or a matrix of such.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; lat = SquareLattice(4, 4); site1, site2 = lat[1:2];

julia&gt; H0 = qwz(lat); psi = groundstate(H0);

julia&gt; H1 = qwz(lat, field=LandauGauge(0.1));

julia&gt; op = [1 0; 0 -1];            # Spin operator

julia&gt; currents = LocalOperatorCurrents(H1, psi, op)
Currents of Operator(Spin(1/2))
 1   0
 0  -1
For system:
One particle on (16-site SquareLattice in 2D space) ⊗ Spin(1/2)

julia&gt; op2 = one(SpinBasis(3//2));  # Invalid operator

julia&gt; LocalOperatorCurrents(H1, psi, op2)
ERROR: ArgumentError: Operator must be defined on the internal basis of the Hamiltonian.
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/zoo/currents.jl#L109-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.SubCurrents" href="#LatticeModels.SubCurrents"><code>LatticeModels.SubCurrents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SubCurrents{CT&lt;:AbstractCurrents} &lt;: AbstractCurrents</code></pre><p>A lazy wrapper for a <code>Currents</code> object representing the same currents but on a smaller lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/currents.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.currentsfrom-Tuple{LatticeModels.AbstractCurrents, Any}" href="#LatticeModels.currentsfrom-Tuple{LatticeModels.AbstractCurrents, Any}"><code>LatticeModels.currentsfrom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">currentsfrom(currents, src)</code></pre><p>Create a <code>LatticeValue</code> object with the currents from <code>src</code> region to all other sites.</p><p><strong>Arguments</strong></p><ul><li><code>currents</code>: The <code>AbstractCurrents</code> object to process.</li><li><code>src</code>: The source region. Can be a site/collection of sites or a <code>LatticeValue{Bool}</code> mask.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/currents.jl#L76-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.currentsfromto" href="#LatticeModels.currentsfromto"><code>LatticeModels.currentsfromto</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">currentsfromto(currents, src[, dst])</code></pre><p>Finds the total current from <code>src</code> to <code>dst</code> regions. If <code>dst</code> is not provided, the current from <code>src</code> to all other sites is returned.</p><p><strong>Arguments</strong></p><ul><li><code>currents</code>: The <code>AbstractCurrents</code> object to process.</li><li><code>src</code>: The source region.</li><li><code>dst</code>: The destination region.</li></ul><p>Both <code>src</code> and <code>dst</code> can be a site/collection of sites or a <code>LatticeValue{Bool}</code> mask.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/currents.jl#L91-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}" href="#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.lattice</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gets the lattice where the given <code>AbstractCurrents</code> object is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/currents.jl#L14-L16">source</a></section></article><h2 id="Evolution"><a class="docs-heading-anchor" href="#Evolution">Evolution</a><a id="Evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.CachedExp" href="#LatticeModels.CachedExp"><code>LatticeModels.CachedExp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CachedExp([ham; threshold=1e-10, nztol=1e-14])</code></pre><p>A <code>EvolutionSolver</code> that finds the matrix exponential of the Hamiltonian and caches it. The matrix exponential is computed using a scaling and squaring method, so this solver works well with sparse or GPU arrays.</p><p><strong>Arguments</strong></p><ul><li><code>ham</code>: The Hamiltonian of the system. It can be an <code>Operator</code> or its matrix.</li><li><code>threshold</code>: The threshold for the error in the matrix exponential.</li><li><code>nztol</code>: The tolerance for dropping small elements in the matrix exponential if it is   sparse.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/evolution.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.Evolution" href="#LatticeModels.Evolution"><code>LatticeModels.Evolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Evolution([solver, ]hamiltonian, states...; timedomain, namedstates...)</code></pre><p>Create an <code>Evolution</code> object that can be used to evolve states in time according to the Schrödinger equation.</p><p><strong>Arguments</strong></p><ul><li><code>solver</code>: A <code>EvolutionSolver</code> object that will be used to evolve the states. If omitted,   a <code>CachedExp</code> solver will be created.</li><li><code>hamiltonian</code>: The Hamiltonian of the system. It can be a matrix, a time-dependent operator   or a function that returns the Hamiltonian at a given time.</li><li><code>states</code> and <code>namedstates</code>: The states to be evolved. They can be <code>Ket</code> wavefunctions or   <code>DataOperator</code> density matrices.</li><li><code>timedomain</code>: The time domain to be used for the evolution. If omitted, the non-iterable <code>Evolution</code>   object will be returned, and you will be able to call it with   the time domain later.</li></ul><p>See <code>EvolutionSolver</code> for more information about solvers.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Please note that the <code>Evolution</code> object is a <strong>stateful</strong> iterator. This means that it keeps track of the current time and the states as they evolve. You can perform evolution multiple times, but the timeline will be kept and the states will be updated in place.</p><p>Also do not edit the states in place, as this will affect the evolution. If you need to modify the states or save them, make a copy of them first.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/evolution.jl#L156-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.KrylovKitExp" href="#LatticeModels.KrylovKitExp"><code>LatticeModels.KrylovKitExp</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KrylovKitExp([ham; kw...])</code></pre><p>A <code>EvolutionSolver</code> that uses the <code>exponentiate</code> function from KrylovKit.jl to evolve the wavefunction vectors. This solver is useful for large, sparse, time-dependent Hamiltonians.</p><p><strong>Arguments</strong></p><ul><li><code>ham</code>: The Hamiltonian of the system. It can be an <code>Operator</code> or its matrix.</li><li><code>kw...</code>: Keyword arguments to be passed to <code>exponentiate</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/evolution.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.TimeSequence" href="#LatticeModels.TimeSequence"><code>LatticeModels.TimeSequence</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeSequence{ET}</code></pre><p>A time-ordered sequence of values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.TimeSequence-Tuple{Any, AbstractVector}" href="#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}"><code>LatticeModels.TimeSequence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeSequence(times, values)</code></pre><p>Constructs a <code>TimeSequence</code> with the given <code>times</code> and <code>values</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.TimeSequence-Tuple{Function, LatticeModels.EvolutionIterator}" href="#LatticeModels.TimeSequence-Tuple{Function, LatticeModels.EvolutionIterator}"><code>LatticeModels.TimeSequence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeSequence(f, ev, times)
TimeSequence(f, ev_iter)</code></pre><p>Constructs a TimeSequence by iterating the evolution iterator <code>ev</code> and applying the function <code>f</code> to each moment.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: A function that takes a moment and returns a value. The function is applied to each moment in the evolution.</li><li><code>ev</code>: An <code>Evolution</code> object.</li><li><code>times</code>: A range of times to evaluate the function at.</li><li><code>ev_iter</code>: An evoltuion iterator that yields moments. Think of it as <code>ev(times)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.TimeSequence-Union{Tuple{}, Tuple{ET}} where ET" href="#LatticeModels.TimeSequence-Union{Tuple{}, Tuple{ET}} where ET"><code>LatticeModels.TimeSequence</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TimeSequence{ET}()</code></pre><p>Constructs an empty <code>TimeSequence</code> with eltype <code>ET</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.differentiate!-Tuple{TimeSequence}" href="#LatticeModels.differentiate!-Tuple{TimeSequence}"><code>LatticeModels.differentiate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiate!(tseq::TimeSequence)</code></pre><p>Differentiate the values stored in <code>tseq</code> by time using the symmetric difference formula. The new values are written into <code>tseq</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; tseq = TimeSequence(0:0.1:10, 0:0.1:10)  # f(t) = t
TimeSequence{Float64} with 101 entry
Timestamps in range 0.0 .. 10.0:
  0.0 =&gt; 0.0
  0.1 =&gt; 0.1
  0.2 =&gt; 0.2
  0.3 =&gt; 0.3
  0.4 =&gt; 0.4
  0.5 =&gt; 0.5
  0.6 =&gt; 0.6
  0.7 =&gt; 0.7
  0.8 =&gt; 0.8
  ⋮

julia&gt; differentiate!(tseq)                     # f&#39;(t) = 1
TimeSequence{Float64} with 100 entries
Timestamps in range 0.05 .. 9.95:
  0.05 =&gt; 1.0
  0.15 =&gt; 1.0
  0.25 =&gt; 1.0
  0.35 =&gt; 1.0
  0.45 =&gt; 1.0
  0.55 =&gt; 1.0
  0.65 =&gt; 1.0
  0.75 =&gt; 1.0
  0.85 =&gt; 1.0
  ⋮</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L154-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.differentiate-Tuple{TimeSequence}" href="#LatticeModels.differentiate-Tuple{TimeSequence}"><code>LatticeModels.differentiate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">differentiate(tseq::TimeSequence)</code></pre><p>Differentiate the values stored in <code>tseq</code> and create a copy; see <a href="#LatticeModels.differentiate!-Tuple{TimeSequence}"><code>differentiate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L206-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.integrate!-Tuple{TimeSequence}" href="#LatticeModels.integrate!-Tuple{TimeSequence}"><code>LatticeModels.integrate!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate!(tseq::TimeSequence)</code></pre><p>Integrate the values stored in <code>tseq</code> over time using the trapezoidal rule. The new values are written into <code>tseq</code>. The first value is set to zero.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LatticeModels

julia&gt; tseq = TimeSequence(0:0.1:10, 0:0.1:10)  # f(t) = t
TimeSequence{Float64} with 101 entry
Timestamps in range 0.0 .. 10.0:
  0.0 =&gt; 0.0
  0.1 =&gt; 0.1
  0.2 =&gt; 0.2
  0.3 =&gt; 0.3
  0.4 =&gt; 0.4
  0.5 =&gt; 0.5
  0.6 =&gt; 0.6
  0.7 =&gt; 0.7
  0.8 =&gt; 0.8
  ⋮

julia&gt; integrate!(tseq)                         # F(t) = t^2 / 2
TimeSequence{Float64} with 101 entry
Timestamps in range 0.0 .. 10.0:
  0.0 =&gt; 0.0
  0.1 =&gt; 0.005
  0.2 =&gt; 0.02
  0.3 =&gt; 0.045
  0.4 =&gt; 0.08
  0.5 =&gt; 0.125
  0.6 =&gt; 0.18
  0.7 =&gt; 0.245
  0.8 =&gt; 0.32
  ⋮</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L213-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.integrate-Tuple{TimeSequence}" href="#LatticeModels.integrate-Tuple{TimeSequence}"><code>LatticeModels.integrate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integrate(tseq::TimeSequence)</code></pre><p>Integrate the values stored in <code>tseq</code> and create a copy; see <a href="#LatticeModels.integrate!-Tuple{TimeSequence}"><code>integrate!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.timerange-Tuple{TimeSequence}" href="#LatticeModels.timerange-Tuple{TimeSequence}"><code>LatticeModels.timerange</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timerange(tseq::TimeSequence)</code></pre><p>Returns the range of the timestamps of the <code>TimeSequence</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.timestamps-Tuple{TimeSequence}" href="#LatticeModels.timestamps-Tuple{TimeSequence}"><code>LatticeModels.timestamps</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">timestamps(tseq::TimeSequence)</code></pre><p>Returns the timestamps of the <code>TimeSequence</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/timesequence.jl#L45-L49">source</a></section></article><h2 id="Internals-2"><a class="docs-heading-anchor" href="#Internals-2">Internals</a><a class="docs-heading-anchor-permalink" href="#Internals-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AbstractLattice" href="#LatticeModels.AbstractLattice"><code>LatticeModels.AbstractLattice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLattice{SiteT}</code></pre><p>An abstract type for a lattice of <code>SiteT</code> sites.</p><p><strong>Methods for subtypes to implement</strong></p><ul><li><code>length(l::AbstractLattice)</code>: Return the number of sites in the lattice.</li><li><code>site_index(l::AbstractLattice, site::SiteT)</code>: Return the index of the site in the lattice.</li><li><code>getindex(l::AbstractLattice, i::Int)</code>: Return the site with the given index.</li><li><code>getindex(l::AbstractLattice, is::AbstractVector{Int})</code>: Return an <code>AbstractLattice</code> with the sites at the given indices.</li></ul><p><strong>Optional methods for mutable lattices</strong></p><ul><li><code>emptymutable(l::AbstractLattice, ::Type{SiteT})</code>: Return an empty mutable instance of lattice.</li><li><code>copymutable(l::AbstractLattice)</code>: Return a mutable copy of the lattice.</li><li><code>push!(l::AbstractLattice, site::SiteT)</code>: Add a site to the lattice.</li><li><code>deleteat!(l::AbstractLattice, is::AbstractVector{Int})</code>: Remove the sites with the given indices from the lattice.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L119-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AbstractSite" href="#LatticeModels.AbstractSite"><code>LatticeModels.AbstractSite</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSite{N}</code></pre><p>An abstract type for a site of a <code>N</code>-dimensional lattice.</p><p><strong>Fields</strong></p><ul><li><code>coords</code>: A <code>SVector</code> of size <code>N</code> representing the spatial coordinates of the site.   All subtypes are expected to have this field.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lattice.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AbstractBonds" href="#LatticeModels.AbstractBonds"><code>LatticeModels.AbstractBonds</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractBonds{LT}</code></pre><p>An abstract type for bonds on some lattice.</p><p><strong>Methods for subtypes to implement</strong></p><ul><li><code>lattice(bonds::AbstractBonds)</code>: Returns the lattice where the bonds are defined.</li><li><code>isadjacent(bonds::AbstractBonds, site1::AbstractSite, site2::AbstractSite)</code>:   Returns if the sites are connected by the bonds.</li></ul><p><strong>Optional methods for subtypes to implement</strong></p><ul><li><code>adapt_bonds(bonds::AbstractBonds, l::AbstractLattice)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L5-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.DirectedBonds" href="#LatticeModels.DirectedBonds"><code>LatticeModels.DirectedBonds</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectedBonds{LT} &lt;: AbstractBonds{LT}</code></pre><p>An abstract type for bonds on some lattice that have a direction.</p><p><strong>Methods for subtypes to implement</strong></p><ul><li><code>lattice(bonds::DirectionalBonds)</code>: Returns the lattice where the bonds are defined.</li><li><code>destinations(bonds::DirectionalBonds, site::AbstractSite)</code>: Returns the sites where the</li></ul><p><code>site</code> is connected to, accounting for the direction of the bonds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L363-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AbstractTranslation" href="#LatticeModels.AbstractTranslation"><code>LatticeModels.AbstractTranslation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractTranslation{LT}</code></pre><p>An abstract type for translations on some lattice.</p><p><strong>Methods for subtypes to implement</strong></p><ul><li><code>lattice(bonds::AbstractTranslation)</code>: Returns the lattice where the translations are defined.</li><li><code>destination(bonds::AbstractTranslation, site::AbstractSite)</code>: Returns the site where the <code>site</code> is translated to.</li></ul><p><strong>Optional methods for subtypes to implement</strong></p><ul><li><code>adapt_bonds(bonds::AbstractTranslation, l::AbstractLattice)</code>:   Adapt the translation to the lattice <code>l</code>. The output can be a different type of   translation, more fitting for the concrete type of lattice.</li><li><code>inv(bonds::AbstractTranslation)</code>: Returns the inverse of the translation, if any.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/bonds.jl#L397-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.AbstractCurrents" href="#LatticeModels.AbstractCurrents"><code>LatticeModels.AbstractCurrents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCurrents</code></pre><p>Supertype for all type representing currents-like values on a lattice. Subtypes must implement <code>Base.getindex(::Int, ::Int)</code> and <code>lattice</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/currents.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.LookupTable" href="#LatticeModels.LookupTable"><code>LatticeModels.LookupTable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LookupTable</code></pre><p>A helper data structure to quickly find the index of a site in a lattice.</p><p>Relies on <code>sitekey(site)</code> and <code>secondarykey(function)</code> functions to determine the index of a site in the lattice.</p><p>Works well under following assumptions:</p><ul><li>The <code>sitekey</code> is some integer property of the sites.</li><li>The sites in the lattice are ordered by <code>sitekey</code>.</li><li>The numbering is mostly contiguous, i.e. there are no (or few) gaps in the numbering.</li><li>The <code>secondarykey</code> is also integer, mostly contiguous, ordered and unique for all sites with the same <code>sitekey</code>.</li></ul><p>Set them to <code>nothing</code> to disable usage (this is the default behavior).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lookuptable.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.EvolutionSolver" href="#LatticeModels.EvolutionSolver"><code>LatticeModels.EvolutionSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EvolutionSolver</code></pre><p>Abstract type for solvers that can be used to evolve states in time according to the Schrödinger equation.</p><p>See also concrete implementations: <code>CachedExp</code>, <code>KrylovKitExp</code>.</p><p><strong>Methods to implement</strong></p><ul><li><code>update_solver!(solver, hamiltonian, dt, force=false)</code>: Update the solver to evolve the   states according to the given Hamiltonian and time step. If <code>force</code> is <code>true</code>, the   solver should always update, even if the Hamiltonian and time step are seemingly the   same as the previous ones.</li><li><code>step!(solver, state, cache)</code>: Evolve the given state in time using the solver. The <code>cache</code>   argument is used to store intermediate results and can be <code>nothing</code> if the solver does   not need it.</li><li><code>evolution_cache(solver, state)</code>: Return a cache object that can be used to store   intermediate results for the given state. Returns <code>nothing</code> if the solver does not need   a cache for the given state (this is the default implementation).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/evolution.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LatticeModels.addlookuptable" href="#LatticeModels.addlookuptable"><code>LatticeModels.addlookuptable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addlookuptable(lat)</code></pre><p>Adds a lookup table to the lattice <code>lat</code> and returns the lattice with the lookup table.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Make sure you add the lookup table to the lattice after you stop making changes to it. Otherwise the results may be unpredictable.</p><p>This operation is not in-place.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/5e43eb4c166131e6fa09c1384612716ed527ab36/src/core/lookuptable.jl#L95-L105">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/evolution/">« Evolution</a><a class="docs-footer-nextpage" href="../internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Friday 17 January 2025 17:55">Friday 17 January 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · LatticeModels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LatticeModels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Advanced options</span><ul><li><a class="tocitem" href="../lattice/">Defining a lattice</a></li><li><a class="tocitem" href="../lattice_values/">Lattice values</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li><a class="tocitem" href="../evolution/">Unitary evolution</a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Lattice-system"><span>Lattice system</span></a></li><li><a class="tocitem" href="#Lattice-values"><span>Lattice values</span></a></li><li><a class="tocitem" href="#Bonds"><span>Bonds</span></a></li><li><a class="tocitem" href="#Magnetic-fields"><span>Magnetic fields</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Currents"><span>Currents</span></a></li><li><a class="tocitem" href="#Unitary-evolution"><span>Unitary evolution</span></a></li><li><a class="tocitem" href="#Time-sequences"><span>Time sequences</span></a></li><li><a class="tocitem" href="#Model-zoo"><span>Model zoo</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="LatticeModels.jl"><a class="docs-heading-anchor" href="#LatticeModels.jl">LatticeModels.jl</a><a id="LatticeModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LatticeModels.jl" title="Permalink"></a></h1><ul><li><a href="#LatticeModels.AbstractCurrents"><code>LatticeModels.AbstractCurrents</code></a></li><li><a href="#LatticeModels.DensityCurrents"><code>LatticeModels.DensityCurrents</code></a></li><li><a href="#LatticeModels.FluxField"><code>LatticeModels.FluxField</code></a></li><li><a href="#LatticeModels.HoneycombLattice"><code>LatticeModels.HoneycombLattice</code></a></li><li><a href="#LatticeModels.LandauField"><code>LatticeModels.LandauField</code></a></li><li><a href="#LatticeModels.Lattice"><code>LatticeModels.Lattice</code></a></li><li><a href="#LatticeModels.LatticeValue"><code>LatticeModels.LatticeValue</code></a></li><li><a href="#LatticeModels.LatticeValue-Tuple{Lattice, AbstractVector}"><code>LatticeModels.LatticeValue</code></a></li><li><a href="#LatticeModels.MaterializedCurrents"><code>LatticeModels.MaterializedCurrents</code></a></li><li><a href="#LatticeModels.NoField"><code>LatticeModels.NoField</code></a></li><li><a href="#LatticeModels.SiteOffset"><code>LatticeModels.SiteOffset</code></a></li><li><a href="#LatticeModels.SiteOffset"><code>LatticeModels.SiteOffset</code></a></li><li><a href="#LatticeModels.SquareLattice"><code>LatticeModels.SquareLattice</code></a></li><li><a href="#LatticeModels.SubCurrents"><code>LatticeModels.SubCurrents</code></a></li><li><a href="#LatticeModels.SymmetricField"><code>LatticeModels.SymmetricField</code></a></li><li><a href="#LatticeModels.TimeSequence"><code>LatticeModels.TimeSequence</code></a></li><li><a href="#LatticeModels.TimeSequence-Tuple{Real, Any}"><code>LatticeModels.TimeSequence</code></a></li><li><a href="#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}"><code>LatticeModels.TimeSequence</code></a></li><li><a href="#LatticeModels.check_issublattice-Tuple{Lattice, Lattice}"><code>LatticeModels.check_issublattice</code></a></li><li><a href="#LatticeModels.check_samelattice-Tuple{Any, Any}"><code>LatticeModels.check_samelattice</code></a></li><li><a href="#LatticeModels.check_samemacrocell-Tuple{Any, Any}"><code>LatticeModels.check_samemacrocell</code></a></li><li><a href="#LatticeModels.coord_values-Tuple{Lattice}"><code>LatticeModels.coord_values</code></a></li><li><a href="#LatticeModels.differentiate!-Tuple{TimeSequence}"><code>LatticeModels.differentiate!</code></a></li><li><a href="#LatticeModels.evolution_operator!-Tuple{AbstractMatrix, AbstractMatrix, Real}"><code>LatticeModels.evolution_operator!</code></a></li><li><a href="#LatticeModels.haldane"><code>LatticeModels.haldane</code></a></li><li><a href="#LatticeModels.integrate!-Tuple{TimeSequence}"><code>LatticeModels.integrate!</code></a></li><li><a href="#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.lattice</code></a></li><li><a href="#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}"><code>LatticeModels.line_integral</code></a></li><li><a href="#LatticeModels.map_currents-Tuple{Function, LatticeModels.AbstractCurrents}"><code>LatticeModels.map_currents</code></a></li><li><a href="#LatticeModels.materialize-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.materialize</code></a></li><li><a href="#LatticeModels.pairs_by_distance-Tuple{Any}"><code>LatticeModels.pairs_by_distance</code></a></li><li><a href="#LatticeModels.project-Tuple{LatticeValue, Any}"><code>LatticeModels.project</code></a></li><li><a href="#LatticeModels.qwz-Tuple{LatticeValue}"><code>LatticeModels.qwz</code></a></li><li><a href="#LatticeModels.radius_vector-Union{Tuple{N}, Tuple{Lattice, LatticeModels.LatticeSite{N}, LatticeModels.LatticeSite{N}}} where N"><code>LatticeModels.radius_vector</code></a></li><li><a href="#LatticeModels.radius_vector-Tuple{Lattice, Bonds{&lt;:Pair}}"><code>LatticeModels.radius_vector</code></a></li><li><a href="#LatticeModels.site_distance-Tuple{}"><code>LatticeModels.site_distance</code></a></li><li><a href="#LatticeModels.site_distance-Tuple{Lattice, LatticeModels.LatticeSite, LatticeModels.LatticeSite}"><code>LatticeModels.site_distance</code></a></li><li><a href="#LatticeModels.site_index-Tuple{Lattice, Union{LatticeModels.LatticePointer, LatticeModels.LatticeSite}}"><code>LatticeModels.site_index</code></a></li><li><a href="#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym"><code>LatticeModels.sublattice</code></a></li><li><a href="#LatticeModels.timestamps-Tuple{TimeSequence}"><code>LatticeModels.timestamps</code></a></li><li><a href="#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}"><code>LatticeModels.vector_potential</code></a></li><li><a href="#LatticeModels.@evolution-Tuple"><code>LatticeModels.@evolution</code></a></li></ul><h2 id="Lattice-system"><a class="docs-heading-anchor" href="#Lattice-system">Lattice system</a><a id="Lattice-system-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-system" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.Lattice" href="#LatticeModels.Lattice"><code>LatticeModels.Lattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lattice{LatticeSym, N, NB}</code></pre><p>A finite subset of a <code>Brvais{N, NB}</code>. <code>LatticeSym</code> is a <code>Symbol</code> which represents the type of the lattice (e. g. <code>:square</code>, <code>:honeycomb</code>). This makes <code>Lattice</code> object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.</p><hr/><pre><code class="nohighlight hljs">Lattice(sym, sz, bvs[, mask])</code></pre><p>Constructs a finite <code>Lattice{sym, N, NB}</code> as a subset of the <code>bvs</code> Bravais lattice. <code>sz</code> is a <code>NTuple{N, Int}</code> which represents how many times the unit cell of <code>bvs</code> was translated by each axis - these sites form a <em>macrocell</em>. <code>mask</code>, if defined, is a <code>Vector{Bool}</code> storing information about which of the sites from the macrocell are actually included in the lattice, and which are not.</p><p>For example, a 3×3 square lattice with its center site excluded is represented as <code>Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])</code></p><p>To define a new type of lattice, create an alias for <code>Lattice{YourSym, YourN, YourNB}</code>. Refer to the docs for detailed explanation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.check_issublattice-Tuple{Lattice, Lattice}" href="#LatticeModels.check_issublattice-Tuple{Lattice, Lattice}"><code>LatticeModels.check_issublattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if <code>l1</code> is sublattice of <code>l2</code>. Throws an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L246-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.check_samelattice-Tuple{Any, Any}" href="#LatticeModels.check_samelattice-Tuple{Any, Any}"><code>LatticeModels.check_samelattice</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if <code>l1</code> and <code>l2</code> objects are defined on one lattice. Throws an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L228-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.check_samemacrocell-Tuple{Any, Any}" href="#LatticeModels.check_samemacrocell-Tuple{Any, Any}"><code>LatticeModels.check_samemacrocell</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Checks if <code>l1</code> and <code>l2</code> are defined on one macrocell. Throws an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L236-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.radius_vector-Union{Tuple{N}, Tuple{Lattice, LatticeModels.LatticeSite{N}, LatticeModels.LatticeSite{N}}} where N" href="#LatticeModels.radius_vector-Union{Tuple{N}, Tuple{Lattice, LatticeModels.LatticeSite{N}, LatticeModels.LatticeSite{N}}} where N"><code>LatticeModels.radius_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius_vector(l::Lattice, site1::LatticeSite, site2::LatticeSite) -&gt; vector</code></pre><p>Finds the vector between two sites on a lattice according to possibly periodic boundary conditions (<code>site2</code> will be translated along the macrocell to minimize the distance between them).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.site_distance-Tuple{Lattice, LatticeModels.LatticeSite, LatticeModels.LatticeSite}" href="#LatticeModels.site_distance-Tuple{Lattice, LatticeModels.LatticeSite, LatticeModels.LatticeSite}"><code>LatticeModels.site_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">site_distance(l::Lattice, site1::LatticeSite, site2::LatticeSite[; pbc=false])</code></pre><p>Returns the distance between two sites on the <code>l</code> lattice.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>pbc</code>: if <code>true</code>, the boundary conditions will be considered periodic and</li></ul><p>the distance will be measured on the shortest path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L140-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.site_distance-Tuple{}" href="#LatticeModels.site_distance-Tuple{}"><code>LatticeModels.site_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">site_distance(; pbc)</code></pre><p>Generates a function that finds the distance between sites (see <code>site_distance(::Lattice, ::LatticeSite, ::LatticeSite)</code>). This notation can be handy when passing this function as an argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.site_index-Tuple{Lattice, Union{LatticeModels.LatticePointer, LatticeModels.LatticeSite}}" href="#LatticeModels.site_index-Tuple{Lattice, Union{LatticeModels.LatticePointer, LatticeModels.LatticeSite}}"><code>LatticeModels.site_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">site_index(l::Lattice, site::LatticeSite; macrocell=false)</code></pre><p>Returns the integer index for given <code>site</code> in <code>lattice</code>. Returns <code>nothing</code> if the site is not present in the lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym" href="#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym"><code>LatticeModels.sublattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublattice(lf::Function, l::Lattice) -&gt; Lattice</code></pre><p>Generates a a subset of lattice <code>l</code> by applying the <code>lf</code> function to its sites. The <code>lf</code> function must return a boolean value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice.jl#L188-L192">source</a></section></article><h2 id="Lattice-values"><a class="docs-heading-anchor" href="#Lattice-values">Lattice values</a><a id="Lattice-values-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LatticeValue" href="#LatticeModels.LatticeValue"><code>LatticeModels.LatticeValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeValue{T, LT}</code></pre><p>Represents a value of type <code>T</code> on a <code>Lattice{LatticeSym}</code> lattice.</p><p>Fields:</p><ul><li>lattice: the <code>Lattice</code> object the value is defined on</li><li>values: the values on different sites</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice_value.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LatticeValue-Tuple{Lattice, AbstractVector}" href="#LatticeModels.LatticeValue-Tuple{Lattice, AbstractVector}"><code>LatticeModels.LatticeValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LatticeValue(l::Lattice, v::AbstractVector)</code></pre><p>Constructs a LatticeValue object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice_value.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.coord_values-Tuple{Lattice}" href="#LatticeModels.coord_values-Tuple{Lattice}"><code>LatticeModels.coord_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coord_values(l::Lattice)</code></pre><p>Generates a tuple of <code>LatticeValue</code>s representing spatial coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice_value.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.project-Tuple{LatticeValue, Any}" href="#LatticeModels.project-Tuple{LatticeValue, Any}"><code>LatticeModels.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(lv::LatticeValue, axis)</code></pre><p>Creates a mapping from site coordinates to values of <code>lv</code>. The coordinate axis to project the sites onto can be set with the <code>axis</code> argument - it can be either an integer from 1 to 3 or an axis descriptor <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/lattice_value.jl#L160-L166">source</a></section></article><h2 id="Bonds"><a class="docs-heading-anchor" href="#Bonds">Bonds</a><a id="Bonds-1"></a><a class="docs-heading-anchor-permalink" href="#Bonds" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SiteOffset" href="#LatticeModels.SiteOffset"><code>LatticeModels.SiteOffset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SiteOffset{T, N}</code></pre><p>A struct representing bonds in some direction in a lattice.</p><hr/><pre><code class="nohighlight hljs">SiteOffset([site_indices, ]translate_uc)</code></pre><p>Constructs a <code>SiteOffset</code> object.</p><p><strong>Arguments:</strong></p><ul><li><code>site_indices</code>: a <code>::Int =&gt; ::Int</code> pair with indices of sites connected by the bond.</li></ul><p>When not defined, the resulting <code>bonds</code> object will connect site with any basis index to a site with the same basis index, but in another unit cell.</p><ul><li><code>translate_uc</code>: the unit cell offset.</li></ul><p>If <code>site_indices</code> are equal or undefined and <code>translate_uc</code> is zero, the bond connects each site with itself. In this case an error will be thrown. Note that though the dimension count for the bond is static, it is automatically compatible to higher-dimensional lattices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/bonds.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SiteOffset" href="#LatticeModels.SiteOffset"><code>LatticeModels.SiteOffset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SiteOffset(site_indices)
SiteOffset([site_indices; ]axis[, dist=1])</code></pre><p>A convenient constructor for a <code>SiteOffset</code> object. <code>site_indices</code> is <code>1 =&gt; 1</code> by default.</p><p><code>site_indices</code> is a <code>::Int =&gt; ::Int</code> pair with indices of sites connected by the bond; <code>1 =&gt; 1</code> is the default value.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>axis</code>: The hopping direction axis in terms of unit cell vectors.</li><li><code>dist</code>: The hopping distance in terms of</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/bonds.jl#L40-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.radius_vector-Tuple{Lattice, Bonds{&lt;:Pair}}" href="#LatticeModels.radius_vector-Tuple{Lattice, Bonds{&lt;:Pair}}"><code>LatticeModels.radius_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius_vector(l::Lattice, hop::SiteOffset)</code></pre><p>Finds the vector between two sites on a lattice according to possibly periodic boundary conditions (<code>site2</code> will be translated along the macrocell to minimize the distance between them).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/bonds.jl#L69-L73">source</a></section></article><h2 id="Magnetic-fields"><a class="docs-heading-anchor" href="#Magnetic-fields">Magnetic fields</a><a id="Magnetic-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Magnetic-fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.NoField" href="#LatticeModels.NoField"><code>LatticeModels.NoField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoField &lt;: AbstractField</code></pre><p>A stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/field.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}" href="#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}"><code>LatticeModels.line_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">line_integral(field, p1, p2[, n_steps=1])</code></pre><p>Calculates the <span>$\int_{p1}^{p2} \overrightarrow{A} \cdot \overrightarrow{dl}$</span> integral using the trapezoidal rule. Increase <code>n_steps</code> to improve accuracy (note that for linear fields like Landau or symmetrical calibrations the formula is already pefrectly accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/field.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}" href="#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}"><code>LatticeModels.vector_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_potential(field, point)</code></pre><p>Returns vector potential <span>$\overrightarrow{A}$</span> for <code>field</code> in location <code>point</code>.</p><p>This function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/core/field.jl#L5-L12">source</a></section></article><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><h2 id="Currents"><a class="docs-heading-anchor" href="#Currents">Currents</a><a id="Currents-1"></a><a class="docs-heading-anchor-permalink" href="#Currents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.AbstractCurrents" href="#LatticeModels.AbstractCurrents"><code>LatticeModels.AbstractCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCurrents</code></pre><p>Supertype for all type representing currents-like values on a lattice. Subtypes must implement <code>Base.getindex(::Int, ::Int)</code> and <code>lattice</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/currents.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.MaterializedCurrents" href="#LatticeModels.MaterializedCurrents"><code>LatticeModels.MaterializedCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaterializedCurrents &lt;: AbstractCurrents</code></pre><p>A <code>AbstractCurrents</code> instance that stores values for all currents explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/currents.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SubCurrents" href="#LatticeModels.SubCurrents"><code>LatticeModels.SubCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubCurrents{CT&lt;:AbstractCurrents} &lt;: AbstractCurrents</code></pre><p>A lazy wrapper for a <code>Currents</code> object representing the same currents but on a smaller lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/currents.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}" href="#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice(::AbstractCurrents)</code></pre><p>Gets the lattice where the given <code>AbstractCurrents</code> object is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/currents.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.map_currents-Tuple{Function, LatticeModels.AbstractCurrents}" href="#LatticeModels.map_currents-Tuple{Function, LatticeModels.AbstractCurrents}"><code>LatticeModels.map_currents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_currents(map_fn, currs::AnstractCurrents[; reduce_fn, sort=false])</code></pre><p>Accepts a function that takes a <code>Lattice</code> and two <code>LatticeSite</code>s and returns any value. Applies <code>map_fn</code> to every site pair and returns two <code>Vector</code>s: one with currents, one with results of <code>map_fn</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>reduce_fn</code>: if a function is provided, all currents with the same mapped value will be reduced into one value.</li></ul><p>For example, if <code>aggr_fn=(x -&gt; mean(abs.(x)))</code>, and <code>map_fn</code> finds the distance between the sites, the returned lists will store the distance between sites and the average absolute current between sites with such distance.</p><ul><li><code>sort</code>: if true, the output arrays will be sorted by mapped value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/currents.jl#L151-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.materialize-Tuple{LatticeModels.AbstractCurrents}" href="#LatticeModels.materialize-Tuple{LatticeModels.AbstractCurrents}"><code>LatticeModels.materialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">materialize([function, ]currents)</code></pre><p>Creates a <code>MaterializedCurrents</code> instance for <code>currents</code>.</p><p>If <code>function</code> is provided, it must accept a <code>Lattice</code> and two <code>LatticeSite</code>s and return if the current between this site must be calculated or not. This can be useful to avoid exsessive calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/currents.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.pairs_by_distance-Tuple{Any}" href="#LatticeModels.pairs_by_distance-Tuple{Any}"><code>LatticeModels.pairs_by_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pairs_by_distance(f)</code></pre><p>A selector function used for hopping operator definition or currents materialization.</p><p>Takes a function and generates a lambda which accepts a lattice and two <code>LatticeSite</code>s, returning whether <code>f</code> applied to distance between the two sites returned <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/currents.jl#L139-L146">source</a></section></article><h2 id="Unitary-evolution"><a class="docs-heading-anchor" href="#Unitary-evolution">Unitary evolution</a><a id="Unitary-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.evolution_operator!-Tuple{AbstractMatrix, AbstractMatrix, Real}" href="#LatticeModels.evolution_operator!-Tuple{AbstractMatrix, AbstractMatrix, Real}"><code>LatticeModels.evolution_operator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolution_operator(H, t)</code></pre><p>Calculates the unitary evolution operator using the formula</p><p>$ \mathcal{U}(t) = e^{-\frac{1}{i\hbar} \hat{H} t} $</p><p><strong>Arguments</strong></p><ul><li><code>H</code>: the hamiltonian matrix</li><li><code>t</code>: the evolution time</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/evolution.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.@evolution-Tuple" href="#LatticeModels.@evolution-Tuple"><code>LatticeModels.@evolution</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@evolution [kwargs...] {rules...} for_loop</code></pre><p>Generates an environment with defined hamiltonian and density matrices that evolve by certain laws. See <a href="../evolution/">Unitary evolution</a> for more details.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>k</code>: order of the Taylor expansion for matrix exponent. If omitted, the default <code>exp</code> function will be used.</li><li><code>pade</code>: set this to true to use Padé approximant formula instead of Taylor expansion.</li><li><code>rtol</code>: the relative tolerance to decide whether the <code>Δt</code> changed between iterations or not. <code>1e-12</code> by default.</li><li><code>show_progress</code>: defines whether the progress informer must be displayed or not. <code>true</code> by default.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/evolution.jl#L237-L248">source</a></section></article><h2 id="Time-sequences"><a class="docs-heading-anchor" href="#Time-sequences">Time sequences</a><a id="Time-sequences-1"></a><a class="docs-heading-anchor-permalink" href="#Time-sequences" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.TimeSequence" href="#LatticeModels.TimeSequence"><code>LatticeModels.TimeSequence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeSequence{ET}</code></pre><p>Series of some data depending on time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/time_sequence.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.TimeSequence-Tuple{Any, AbstractVector}" href="#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}"><code>LatticeModels.TimeSequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TimeSequence(times, values)</code></pre><p>Constructs a TimeSequence with given timestamps and values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/time_sequence.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.TimeSequence-Tuple{Real, Any}" href="#LatticeModels.TimeSequence-Tuple{Real, Any}"><code>LatticeModels.TimeSequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TimeSequence(value; t=0)</code></pre><p>Constructs a TimeSequence with one single snapshot. The timestamp is zero by default but can be over riden.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/time_sequence.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.differentiate!-Tuple{TimeSequence}" href="#LatticeModels.differentiate!-Tuple{TimeSequence}"><code>LatticeModels.differentiate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">differentiate!(ts::TimeSequence)</code></pre><p>Differentiate the values stored in the <code>TimeSequence</code> object by time using the symmetric difference formula.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/time_sequence.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.integrate!-Tuple{TimeSequence}" href="#LatticeModels.integrate!-Tuple{TimeSequence}"><code>LatticeModels.integrate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrate(ts::TimeSequence)</code></pre><p>Integrates the values stored in the <code>TimeSequence</code> object over time using the trapezoidal rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/time_sequence.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.timestamps-Tuple{TimeSequence}" href="#LatticeModels.timestamps-Tuple{TimeSequence}"><code>LatticeModels.timestamps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">timestamps(ts::TimeSequence)</code></pre><p>Returns the timestamps of the snapshots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/time_sequence.jl#L27-L31">source</a></section></article><h2 id="Model-zoo"><a class="docs-heading-anchor" href="#Model-zoo">Model zoo</a><a id="Model-zoo-1"></a><a class="docs-heading-anchor-permalink" href="#Model-zoo" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.DensityCurrents" href="#LatticeModels.DensityCurrents"><code>LatticeModels.DensityCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DensityCurrents &lt;: AbstractCurrents</p><p>Density currents for given density matrix and given hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.FluxField" href="#LatticeModels.FluxField"><code>LatticeModels.FluxField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxField &lt;: AbstractField</code></pre><p>An object representing a small magnetic flux through given point. The field is directed along z-axis. Fields:</p><ul><li><code>B</code>: The magnetic field value</li><li><code>point</code>: A <code>NTuple{2, Number}</code> representing the point where the magnetic flux is located.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.HoneycombLattice" href="#LatticeModels.HoneycombLattice"><code>LatticeModels.HoneycombLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HoneycombLattice</code></pre><p>Type alias for <code>Lattice{:honeycomb,2,2}</code>.</p><hr/><pre><code class="nohighlight hljs">HoneycombLattice(sz::Vararg{Int, 2})</code></pre><p>Constructs a honeycomb lattice with a <code>sz</code>-size macrocell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L25-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LandauField" href="#LatticeModels.LandauField"><code>LatticeModels.LandauField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LandauField &lt;: AbstractField</code></pre><p>An object representing Landau calibrated uniform magnetic field along z-axis. Fields:</p><ul><li><code>B</code>: The magnetic field value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SquareLattice" href="#LatticeModels.SquareLattice"><code>LatticeModels.SquareLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SquareLattice{N}</code></pre><p>Type alias for <code>Lattice{:square,N,1}</code>.</p><hr/><pre><code class="nohighlight hljs">SquareLattice(sz::Int...)</code></pre><p>Constructs a square lattice of size <code>sz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SymmetricField" href="#LatticeModels.SymmetricField"><code>LatticeModels.SymmetricField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymmetricField &lt;: AbstractField</code></pre><p>An object representing symmetrically calibrated uniform magnetic field along z-axis. Fields:</p><ul><li><code>B</code>: The magnetic field value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.haldane" href="#LatticeModels.haldane"><code>LatticeModels.haldane</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">haldane(l::HoneycombLattice, t1::Real, t2::Real[, m::Real=0; field::AbstractField])</code></pre><p class="math-container">\[\hat{H} =
\sum_i^\text{sublattice A} m c^\dagger_i c_i +
\sum_j^\text{sublattice B} m c^\dagger_j c_j +
\sum_{i, j}^\text{adjacent} \left( t_1 c^\dagger_i c_j + h. c. \right) +
\sum_{i, j}^\text{2-connected,\\counter-clockwise} \left( i \cdot t_2 c^\dagger_i c_j + h. c. \right)\]</p><p>Generates a Haldane topological insulator hamiltonian operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L141-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.qwz-Tuple{LatticeValue}" href="#LatticeModels.qwz-Tuple{LatticeValue}"><code>LatticeModels.qwz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qwz([f, ]mv::LatticeValue[; field::AbstractField, pbc=false])
qwz([f, ]l::SquareLattice[, m::Number=1; field::AbstractField, pbc=false])</code></pre><p class="math-container">\[\hat{H} =
\sum_i^\text{sites} m_i c^\dagger_i \sigma_z c_i +
\sum_i^\text{sites} \left(
c^\dagger_{i + \hat{x}} \frac{\sigma_z - i \sigma_x}{2} c_i +
c^\dagger_{i + \hat{y}} \frac{\sigma_z - i \sigma_y}{2} c_i +
h. c. \right)\]</p><p>Generates a QWZ model hamiltonian operator with set magnetic field. If the <span>$m_i$</span> values are set by the <code>mv::LatticeValue</code>, which must be defined on a <code>SquareLattice</code>. Otherwise they will all be set to <code>m</code>.</p><p><code>f</code> here must be a function or a <code>PairSelector</code> describing which hoppings will be excluded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/4f9e7a3df2fcf335bafc79eadda94b9befa25314/src/zoo.jl#L116-L132">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« Internals</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 6 September 2023 15:18">Wednesday 6 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · LatticeModels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LatticeModels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../lattice/">Defining a lattice</a></li><li><a class="tocitem" href="../lattice_values/">Lattice values</a></li><li><a class="tocitem" href="../lattice_operator/">Lattice operators</a></li><li><a class="tocitem" href="../hamiltonian/">Hamiltonian generation</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li><a class="tocitem" href="../evolution/">Unitary evolution</a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced options</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Lattice-creation"><span>Lattice creation</span></a></li><li><a class="tocitem" href="#Lattice-values"><span>Lattice values</span></a></li><li><a class="tocitem" href="#Lattice-operators"><span>Lattice operators</span></a></li><li><a class="tocitem" href="#Hoppings"><span>Hoppings</span></a></li><li><a class="tocitem" href="#Magnetic-fields"><span>Magnetic fields</span></a></li><li><a class="tocitem" href="#Hamiltonian-tools"><span>Hamiltonian tools</span></a></li><li><a class="tocitem" href="#Currents"><span>Currents</span></a></li><li><a class="tocitem" href="#Unitary-evolution"><span>Unitary evolution</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="LatticeModels.jl"><a class="docs-heading-anchor" href="#LatticeModels.jl">LatticeModels.jl</a><a id="LatticeModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#LatticeModels.jl" title="Permalink"></a></h1><ul><li><a href="#LatticeModels.AbstractCurrents"><code>LatticeModels.AbstractCurrents</code></a></li><li><a href="#LatticeModels.Basis"><code>LatticeModels.Basis</code></a></li><li><a href="#LatticeModels.BondSet"><code>LatticeModels.BondSet</code></a></li><li><a href="#LatticeModels.Bravais"><code>LatticeModels.Bravais</code></a></li><li><a href="#LatticeModels.DensityCurrents"><code>LatticeModels.DensityCurrents</code></a></li><li><a href="#LatticeModels.FluxField"><code>LatticeModels.FluxField</code></a></li><li><a href="#LatticeModels.HoneycombLattice"><code>LatticeModels.HoneycombLattice</code></a></li><li><a href="#LatticeModels.Hopping"><code>LatticeModels.Hopping</code></a></li><li><a href="#LatticeModels.LandauField"><code>LatticeModels.LandauField</code></a></li><li><a href="#LatticeModels.Lattice"><code>LatticeModels.Lattice</code></a></li><li><a href="#LatticeModels.LatticeArray"><code>LatticeModels.LatticeArray</code></a></li><li><a href="#LatticeModels.LatticeOperator-Tuple{LinearAlgebra.UniformScaling, Basis}"><code>LatticeModels.LatticeOperator</code></a></li><li><a href="#LatticeModels.LatticeSite"><code>LatticeModels.LatticeSite</code></a></li><li><a href="#LatticeModels.LatticeValue"><code>LatticeModels.LatticeValue</code></a></li><li><a href="#LatticeModels.MaterializedCurrents"><code>LatticeModels.MaterializedCurrents</code></a></li><li><a href="#LatticeModels.NoField"><code>LatticeModels.NoField</code></a></li><li><a href="#LatticeModels.Spectrum"><code>LatticeModels.Spectrum</code></a></li><li><a href="#LatticeModels.SquareLattice"><code>LatticeModels.SquareLattice</code></a></li><li><a href="#LatticeModels.SubCurrents"><code>LatticeModels.SubCurrents</code></a></li><li><a href="#LatticeModels.SymmetricField"><code>LatticeModels.SymmetricField</code></a></li><li><a href="#LatticeModels.TensorProduct"><code>LatticeModels.TensorProduct</code></a></li><li><a href="#LatticeModels.apply_field!-Tuple{LatticeOperator, AbstractField}"><code>LatticeModels.apply_field!</code></a></li><li><a href="#LatticeModels.bonds-Tuple{LatticeOperator}"><code>LatticeModels.bonds</code></a></li><li><a href="#LatticeModels.bonds-Tuple{Lattice, Vararg{LatticeModels.Hopping}}"><code>LatticeModels.bonds</code></a></li><li><a href="#LatticeModels.coord_operators-Tuple{Basis}"><code>LatticeModels.coord_operators</code></a></li><li><a href="#LatticeModels.coord_operators-Tuple{Lattice, Int64}"><code>LatticeModels.coord_operators</code></a></li><li><a href="#LatticeModels.coord_values-Tuple{Lattice}"><code>LatticeModels.coord_values</code></a></li><li><a href="#LatticeModels.coords-Tuple{Lattice, LatticeSite}"><code>LatticeModels.coords</code></a></li><li><a href="#LatticeModels.current_lambda-Tuple{T} where T&lt;:AbstractCurrents"><code>LatticeModels.current_lambda</code></a></li><li><a href="#LatticeModels.diag_aggregate-Tuple{Function, LatticeModels.LatticeArray}"><code>LatticeModels.diag_aggregate</code></a></li><li><a href="#LatticeModels.diag_operator-Tuple{Basis, LatticeValue{&lt;:Number}}"><code>LatticeModels.diag_operator</code></a></li><li><a href="#LatticeModels.diag_operator-Tuple{Lattice, AbstractMatrix}"><code>LatticeModels.diag_operator</code></a></li><li><a href="#LatticeModels.diag_operator-Tuple{Function, Basis}"><code>LatticeModels.diag_operator</code></a></li><li><a href="#LatticeModels.diag_operator-Tuple{Function, Lattice}"><code>LatticeModels.diag_operator</code></a></li><li><a href="#LatticeModels.evolution_operator-Tuple{Any, Real}"><code>LatticeModels.evolution_operator</code></a></li><li><a href="#LatticeModels.filled_projector"><code>LatticeModels.filled_projector</code></a></li><li><a href="#LatticeModels.hopping"><code>LatticeModels.hopping</code></a></li><li><a href="#LatticeModels.hopping_operator"><code>LatticeModels.hopping_operator</code></a></li><li><a href="#LatticeModels.lattice-Tuple{T} where T&lt;:AbstractCurrents"><code>LatticeModels.lattice</code></a></li><li><a href="#LatticeModels.materialize-Tuple{AbstractCurrents}"><code>LatticeModels.materialize</code></a></li><li><a href="#LatticeModels.plot_fallback-Tuple{LatticeValue}"><code>LatticeModels.plot_fallback</code></a></li><li><a href="#LatticeModels.projector-Tuple{Function, Spectrum}"><code>LatticeModels.projector</code></a></li><li><a href="#LatticeModels.projector-Tuple{Spectrum}"><code>LatticeModels.projector</code></a></li><li><a href="#LatticeModels.promote_dims!-Tuple{LatticeModels.Hopping, Int64}"><code>LatticeModels.promote_dims!</code></a></li><li><a href="#LatticeModels.ptrace-Tuple{LatticeModels.LatticeArray}"><code>LatticeModels.ptrace</code></a></li><li><a href="#LatticeModels.radius_vector-Tuple{Lattice, LatticeSite, LatticeSite}"><code>LatticeModels.radius_vector</code></a></li><li><a href="#LatticeModels.spectrum-Tuple{LatticeModels.LatticeArray{LT, &lt;:Matrix} where LT}"><code>LatticeModels.spectrum</code></a></li><li><a href="#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym"><code>LatticeModels.sublattice</code></a></li><li><a href="#LatticeModels.trip_integral-Tuple{AbstractField, Any, Any}"><code>LatticeModels.trip_integral</code></a></li><li><a href="#LatticeModels.vector_potential-Union{Tuple{FT}, Tuple{FT, Any}} where FT&lt;:AbstractField"><code>LatticeModels.vector_potential</code></a></li><li><a href="#LatticeModels.@evolution-Tuple"><code>LatticeModels.@evolution</code></a></li><li><a href="#LatticeModels.@field_def-Tuple{Any}"><code>LatticeModels.@field_def</code></a></li><li><a href="#LatticeModels.@hamiltonian-Tuple{Any}"><code>LatticeModels.@hamiltonian</code></a></li><li><a href="#LatticeModels.@on_lattice-Tuple{Any}"><code>LatticeModels.@on_lattice</code></a></li></ul><h2 id="Lattice-creation"><a class="docs-heading-anchor" href="#Lattice-creation">Lattice creation</a><a id="Lattice-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-creation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.Bravais" href="#LatticeModels.Bravais"><code>LatticeModels.Bravais</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bravais{N, NB}</code></pre><p><code>N</code>-dimensional infinite Bravais lattice with <code>NB</code> sites in basis.</p><hr/><pre><code class="nohighlight hljs">Bravais(translation_vectors[, basis])</code></pre><p>Constructs a Bravais lattice with given translation vectors and locations of basis sites relative to some unit cell. The <code>basis</code> argument can be omitted, in which case the lattice basis will consist of one site located in the bottom-left corner of the unit cell.</p><p><code>translation_vectors</code> argument must be an <code>AbstractMatrix{&lt;:Real}</code> of size <code>N×N</code>, while <code>basis</code> must also be an  abstract matrix of size <code>N×NB</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L4-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.HoneycombLattice" href="#LatticeModels.HoneycombLattice"><code>LatticeModels.HoneycombLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HoneycombLattice</code></pre><p>Type alias for <code>Lattice{:honeycomb,2,2}</code>.</p><hr/><pre><code class="nohighlight hljs">HoneycombLattice(sz::Vararg{Int, 2})</code></pre><p>Constructs a honeycomb lattice with a <code>sz</code>-size macro cell.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L284-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.Lattice" href="#LatticeModels.Lattice"><code>LatticeModels.Lattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lattice{LatticeSym, N, NB}</code></pre><p>A finite subset of a <code>Brvais{N, NB}</code>. <code>LatticeSym</code> is a <code>Symbol</code> which represents the type of the lattice (e. g. <code>:square</code>, <code>:honeycomb</code>). This makes <code>Lattice</code> object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.</p><hr/><pre><code class="nohighlight hljs">Lattice(sym, sz, bvs[, mask])</code></pre><p>Constructs a finite <code>Lattice{sym, N, NB}</code> as a subset of the <code>bvs</code> Bravais lattice. <code>sz</code> is a <code>NTuple{N, Int}</code> which represents how many times the unit cell of <code>bvs</code> was translated by each axis - these sites form a <em>macro cell</em>. <code>mask</code>, if defined, is a <code>Vector{Bool}</code> storing information about which of the sites from the macro cell are actually included in the lattice, and which are not.</p><p>For example, a 3×3 square lattice with its center site excluded is represented as <code>Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])</code></p><p>To define a new type of lattice, create an alias for <code>Lattice{YourSym, YourN, YourNB}</code>. Refer to the docs for detailed explanation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L35-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LatticeSite" href="#LatticeModels.LatticeSite"><code>LatticeModels.LatticeSite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeSite{N}</code></pre><p>A site of a <code>Lattice{LatticeSym, N, NB}</code> lattice.</p><p>Fields:</p><ul><li><code>unit_cell</code>: a set of translations along all axes representing the unit cell the site is located in.</li><li><code>basis_index</code>: the number of site in the lattice basis.</li></ul><p>This type is used to iterate over all sites of a <code>Lattice{LatticeSym, N, NB}</code>. The exact location of a <code>LatticeSite</code> can be found using the <code>coords(lattice, site)</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L80-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SquareLattice" href="#LatticeModels.SquareLattice"><code>LatticeModels.SquareLattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SquareLattice{N}</code></pre><p>Type alias for <code>Lattice{:square,N,1}</code>.</p><hr/><pre><code class="nohighlight hljs">SquareLattice(sz::Int...)</code></pre><p>Constructs a square lattice of size <code>sz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L267-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.coords-Tuple{Lattice, LatticeSite}" href="#LatticeModels.coords-Tuple{Lattice, LatticeSite}"><code>LatticeModels.coords</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coords(lattice::Lattice, site::LatticeSite) -&gt; vector</code></pre><p>Finds the location in space of lattice site <code>site</code> on lattice <code>lattice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L131-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.radius_vector-Tuple{Lattice, LatticeSite, LatticeSite}" href="#LatticeModels.radius_vector-Tuple{Lattice, LatticeSite, LatticeSite}"><code>LatticeModels.radius_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">radius_vector(lattice::Lattice, site1::LatticeSite, site2::LatticeSite) -&gt; vector</code></pre><p>Finds the vector between two sites on a lattice according to possibly periodic boundary conditions (<code>site2</code> will be translated along the macro cell to minimize the distance between them).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym" href="#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym"><code>LatticeModels.sublattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sublattice(lf::Function, l::Lattice) -&gt; Lattice</code></pre><p>Generates a a subset of lattice <code>l</code> by applying the <code>lf</code> function to its sites. The <code>lf</code> function must accept two positional arguments (a <code>LatticeSite</code> and a vector with its coordinates) and return a boolean value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice.jl#L240-L245">source</a></section></article><h2 id="Lattice-values"><a class="docs-heading-anchor" href="#Lattice-values">Lattice values</a><a id="Lattice-values-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-values" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LatticeValue" href="#LatticeModels.LatticeValue"><code>LatticeModels.LatticeValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeValue{T, LatticeSym}</code></pre><p>Represents a value of type <code>T</code> on a <code>Lattice{LatticeSym}</code> lattice.</p><p>Fields:</p><ul><li>lattice: the <code>Lattice</code> object the value is defined on</li><li>values: the values on different sites</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_value.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.coord_values-Tuple{Lattice}" href="#LatticeModels.coord_values-Tuple{Lattice}"><code>LatticeModels.coord_values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coord_values(lattice::Lattice)</code></pre><p>Generates a tuple of <code>LatticeValue</code>s representing coordinate functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_value.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.plot_fallback-Tuple{LatticeValue}" href="#LatticeModels.plot_fallback-Tuple{LatticeValue}"><code>LatticeModels.plot_fallback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_fallback(lv::LatticeValue)</code></pre><p>Creates a copy of <code>lv</code> lattice value with its <code>LatticeSym</code> overwritten to <code>:uncertain</code>. Use it to invoke the default plot recipe for <code>LatticeValues</code> when defining a custom one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_value.jl#L125-L130">source</a></section></article><h2 id="Lattice-operators"><a class="docs-heading-anchor" href="#Lattice-operators">Lattice operators</a><a id="Lattice-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-operators" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.Basis" href="#LatticeModels.Basis"><code>LatticeModels.Basis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Basis{LT} where {LT&lt;:Lattice}</code></pre><p>A basis on a lattice with some number of internal states on each site. Fields:</p><ul><li><code>lattice</code>: the <a href="#LatticeModels.Lattice"><code>Lattice</code></a> of the basis</li><li><code>internal_dim</code>: the number of internal states on each site</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LatticeArray" href="#LatticeModels.LatticeArray"><code>LatticeModels.LatticeArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeArray{LT, MT} where {LT&lt;:Lattice, MT&lt;:AbstractArray}</code></pre><p>A wrapper object for array representing a wave function or linear operator. Stores information about its basis to perform lattice checks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LatticeOperator-Tuple{LinearAlgebra.UniformScaling, Basis}" href="#LatticeModels.LatticeOperator-Tuple{LinearAlgebra.UniformScaling, Basis}"><code>LatticeModels.LatticeOperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LatticeOperator{LT, MT}</code></pre><p>The same as <code>LatticeArray{LT, MT}</code> where <code>MT&lt;:AbstractMatrix</code>.</p><hr/><pre><code class="nohighlight hljs">LatticeOperator(uniform_scaling, basis)</code></pre><p>Creates a <code>LatticeOperator</code> representation of a <code>UniformScaling</code> operator on given basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L44-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.TensorProduct" href="#LatticeModels.TensorProduct"><code>LatticeModels.TensorProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TensorProduct{LVT, MT} where {LVT&lt;:LatticeValue{&lt;:Number}, MT&lt;:AbstractMatrix}</code></pre><p>A lazy representation of an operator as a tensor product of two distinct phase spaces. One affects only the internal space, the other - only the lattice space.</p><p>The <code>lattice_value ⊗ matrix</code> notation computes the value of the <code>TensorProduct</code> eagerly, which means that the result will be a <code>LatticeOperator</code>. However, in the <code>@hamiltonian</code> macro lazy computation is forced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L84-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.coord_operators-Tuple{Basis}" href="#LatticeModels.coord_operators-Tuple{Basis}"><code>LatticeModels.coord_operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coord_operators(basis)</code></pre><p>Returns a <code>Tuple</code> of coordinate <code>LatticeOperator</code>s for given basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.coord_operators-Tuple{Lattice, Int64}" href="#LatticeModels.coord_operators-Tuple{Lattice, Int64}"><code>LatticeModels.coord_operators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coord_operators(lattice, ndims)</code></pre><p>The same as <code>coord_operators(Basis(lattice, ndims))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.diag_aggregate-Tuple{Function, LatticeModels.LatticeArray}" href="#LatticeModels.diag_aggregate-Tuple{Function, LatticeModels.LatticeArray}"><code>LatticeModels.diag_aggregate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diag_aggregate(function, lattice_operator)</code></pre><p>Creates a <code>LatticeValue</code> where a site maps to the result of <code>function</code> on the matrix of the operator narrowed to that site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.diag_operator-Tuple{Basis, LatticeValue{&lt;:Number}}" href="#LatticeModels.diag_operator-Tuple{Basis, LatticeValue{&lt;:Number}}"><code>LatticeModels.diag_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diag_operator(basis, lattice_value)</code></pre><p>Creates a diagonal operator which affects only the lattice space. The <code>lattice_value</code> argument must be a <code>LatticeValue</code> storing diagonal elements of the operator in lattice space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.diag_operator-Tuple{Function, Basis}" href="#LatticeModels.diag_operator-Tuple{Function, Basis}"><code>LatticeModels.diag_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diag_operator(site_fun, basis)</code></pre><p>Creates a diagonal operator which affects only the lattice space. The <code>site_fun</code> function must accept a <code>LatticeSite</code> and its coordinates and return a number which will be the diagonal element of the operator in lattice space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L167-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.diag_operator-Tuple{Function, Lattice}" href="#LatticeModels.diag_operator-Tuple{Function, Lattice}"><code>LatticeModels.diag_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diag_operator(site_fun, lattice)</code></pre><p>Creates a diagonal operator by applying the <code>site_fun</code> function to each site of <code>lattice</code>. The <code>site_fun</code> function must accept a <code>LatticeSite</code> and its coordinates and return a matrix which will be an operator affecting the internal state of the site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.diag_operator-Tuple{Lattice, AbstractMatrix}" href="#LatticeModels.diag_operator-Tuple{Lattice, AbstractMatrix}"><code>LatticeModels.diag_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diag_operator(lattice, matrix)</code></pre><p>Creates a diagonal operator which affects only the internal state the same way on every site. <code>matrix</code> is an <code>AbstractMatrix</code> representing the linear operator on the internal space.</p><p>Note that the matrix of the output <code>LatticeOperator</code> will be similar to <code>matrix</code>: for instance, if <code>matrix</code> is sparse, so will be the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L156-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.ptrace-Tuple{LatticeModels.LatticeArray}" href="#LatticeModels.ptrace-Tuple{LatticeModels.LatticeArray}"><code>LatticeModels.ptrace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ptrace(lattice_operator)</code></pre><p>Same as <code>diag_aggregate(tr, lattice_operator)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.@on_lattice-Tuple{Any}" href="#LatticeModels.@on_lattice-Tuple{Any}"><code>LatticeModels.@on_lattice</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@on_lattice</code></pre><p>Replaces all <code>LatticeArray</code>s in subsequent function calls with actual arrays stored inside them. Throws an error if lattice operators in one function call are defined on different lattices, shows a warning if a lattice array is used in one call with a normal array.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">l = SquareLattice(10, 10)
bas = Basis(l, 2)
X, Y = coord_operators(bas)
xexpypy = diag_operator(bas) do site, (x, y)
    x * exp(y) + y
end
xexpy == @on_lattice X * exp(Y) + Y     # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/lattice_operator.jl#L314-L331">source</a></section></article><h2 id="Hoppings"><a class="docs-heading-anchor" href="#Hoppings">Hoppings</a><a id="Hoppings-1"></a><a class="docs-heading-anchor-permalink" href="#Hoppings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.BondSet" href="#LatticeModels.BondSet"><code>LatticeModels.BondSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BondSet{LT} where {LT&lt;:Lattice}</code></pre><p>Represents the bonds on some lattice.</p><p><code>BondSet</code>s can be combined with the <code>|</code> operator and negated with the <code>!</code> operator. Also you can create a <code>BondSet</code> which connects sites that were connected by <code>≤n</code> bonds of the previous <code>BondSet</code> by taking its power: <code>bs2 = bs1 ^ n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hoppings.jl#L247-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.Hopping" href="#LatticeModels.Hopping"><code>LatticeModels.Hopping</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hopping{MT} where {MT&lt;:AbstractMatrix}</code></pre><p>A struct representing a bond in a lattice.</p><ul><li><code>site_indices</code>: a <code>NTuple{2, Int}</code> with indices of sites connected by the bond.</li><li><code>translate_uc</code>: the unit cell offset.</li><li><code>pbc</code>: a vector of boolean values indicating if the bonds should be applied periodically over each axis.</li><li><code>hop_operator</code>: a matrix of type <code>MT</code> representing the operator affecting the internal state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hoppings.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.bonds-Tuple{Lattice, Vararg{LatticeModels.Hopping}}" href="#LatticeModels.bonds-Tuple{Lattice, Vararg{LatticeModels.Hopping}}"><code>LatticeModels.bonds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bonds(lattice, hoppings...)</code></pre><p>Generates a <code>BondSet</code> for a given set of <code>Hopping</code>s on a given <code>Lattice</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hoppings.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.bonds-Tuple{LatticeOperator}" href="#LatticeModels.bonds-Tuple{LatticeOperator}"><code>LatticeModels.bonds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bonds(operator)</code></pre><p>Generates a <code>BondSet</code> for the provided operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hoppings.jl#L275-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.hopping" href="#LatticeModels.hopping"><code>LatticeModels.hopping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hopping([hop_operator,] kwargs...)</code></pre><p>A convenient constructor for a <code>Hopping</code> object. <code>hop_operator</code> can be either a matrix or a number (in that case a 1×1 matrix will be created automatically)</p><p>Keyword arguments:</p><ul><li><code>site_indices</code>: a <code>NTuple{2, Int}</code> (or <code>Int</code> if they are equal) with indices of sites connected by the bond. <code>(1, 1)</code> by default.</li><li><code>translate_uc</code>: the unit cell offset. Zeros by default.</li><li><code>axis</code>: overrides <code>translate_uc</code> and sets its components to zero on all axes except given.</li><li><code>pbc</code>: a vector of boolean values indicating if the bonds should be applied periodically over each axis.</li></ul><p>Can also be a single boolean, which will set all elements of the vector to given value. <code>false</code> by default.</p><p>If <code>site_indices</code> are equal and <code>translate_uc</code> is zero, this means that the bond connects each site with itself, in which case an error will be thrown. Note that the dimension count for the hopping is dynamic and will automatically change during runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hoppings.jl#L44-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.hopping_operator" href="#LatticeModels.hopping_operator"><code>LatticeModels.hopping_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hopping_operator(args...)</code></pre><p>Creates a hopping operator: <span>$\hat{A} = \sum_{pairs} \hat{t} \hat{c}^\dagger_j \hat{c}_i + h. c.$</span></p><hr/><pre><code class="nohighlight hljs">hopping_operator(function, lattice, hopping[, field])
hopping_operator(excl_function, lattice, hopping[, field])
hopping_operator(lattice, hopping, excl_value[, field])</code></pre><p>Arguments:</p><ul><li><code>excl_function</code>: takes a <code>LatticeSite</code> and its coordinate vector, returns whether the pair with this site should be included.</li><li><code>excl_value</code>: same as <code>excl_function</code>, but represented as a <code>LatticeValue{Bool}</code></li><li><code>lattice</code>: the lattice to create the operator on.</li><li><code>hopping</code>: the <code>Hopping</code> object describing the site pairs and the <span>$\hat{t}$</span> operator.</li><li><code>field</code>: the <code>AbstractField</code> object that defines the magnetic field to generate phase factors using Peierls substitution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hoppings.jl#L165-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.promote_dims!-Tuple{LatticeModels.Hopping, Int64}" href="#LatticeModels.promote_dims!-Tuple{LatticeModels.Hopping, Int64}"><code>LatticeModels.promote_dims!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_dims!(hopping, ndims)</code></pre><p>Changes dimension count of <code>hopping</code> to <code>ndims</code> if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hoppings.jl#L103-L107">source</a></section></article><h2 id="Magnetic-fields"><a class="docs-heading-anchor" href="#Magnetic-fields">Magnetic fields</a><a id="Magnetic-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Magnetic-fields" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.FluxField" href="#LatticeModels.FluxField"><code>LatticeModels.FluxField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FluxField &lt;: AbstractField</code></pre><p>An object representing a small magnetic flux through given point. The field is directed along z-axis. Fields:</p><ul><li><code>B</code>: The magnetic field value</li><li><code>point</code>: A <code>NTuple{2, Number}</code> representing the point where the magnetic flux is located.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L237-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.LandauField" href="#LatticeModels.LandauField"><code>LatticeModels.LandauField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LandauField &lt;: AbstractField</code></pre><p>An object representing Landau calibrated uniform magnetic field along z-axis. Fields:</p><ul><li><code>B</code>: The magnetic field value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L197-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.NoField" href="#LatticeModels.NoField"><code>LatticeModels.NoField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoField &lt;: AbstractField</code></pre><p>A stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SymmetricField" href="#LatticeModels.SymmetricField"><code>LatticeModels.SymmetricField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SymmetricField &lt;: AbstractField</code></pre><p>An object representing symmetrically calibrated uniform magnetic field along z-axis. Fields:</p><ul><li><code>B</code>: The magnetic field value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.apply_field!-Tuple{LatticeOperator, AbstractField}" href="#LatticeModels.apply_field!-Tuple{LatticeOperator, AbstractField}"><code>LatticeModels.apply_field!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_field!(hamiltonian, field[; nsteps])</code></pre><p>Applies magnetic field to given hamiltonian matrix by adjusting the phase factors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.trip_integral-Tuple{AbstractField, Any, Any}" href="#LatticeModels.trip_integral-Tuple{AbstractField, Any, Any}"><code>LatticeModels.trip_integral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trip_integral(field, p1, p2; n_steps=1)</code></pre><p>Calculates the <span>$\int_{p1}^{p2} \overrightarrow{A} \cdot \overrightarrow{dl}$</span> integral using the trapezoidal rule. Increase <code>n_steps</code> to improve accuracy (for linear fields like Landau or symmetrical calibrations the formula is accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.vector_potential-Union{Tuple{FT}, Tuple{FT, Any}} where FT&lt;:AbstractField" href="#LatticeModels.vector_potential-Union{Tuple{FT}, Tuple{FT, Any}} where FT&lt;:AbstractField"><code>LatticeModels.vector_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_potential(field, point)</code></pre><p>Returns vector potential <span>$\overrightarrow{A}$</span> for <code>field</code> in location <code>point</code>.</p><p>This function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.@field_def-Tuple{Any}" href="#LatticeModels.@field_def-Tuple{Any}"><code>LatticeModels.@field_def</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@field_def block</code></pre><p>Defines a new magnetic field type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/field.jl#L84-L88">source</a></section></article><h2 id="Hamiltonian-tools"><a class="docs-heading-anchor" href="#Hamiltonian-tools">Hamiltonian tools</a><a id="Hamiltonian-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.Spectrum" href="#LatticeModels.Spectrum"><code>LatticeModels.Spectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Spectrum{LT, MT} where {LT&lt;:Lattice, MT&lt;:AbstractMatrix}</code></pre><p>Eigenvalues and eigenvectors for some operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hamiltonian.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.filled_projector" href="#LatticeModels.filled_projector"><code>LatticeModels.filled_projector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">filled_projector(spectrum[, fermi_level])</code></pre><p>Creates a <code>LatticeOperator</code> that projects onto the eigenvectors which have eigenvalues less than <code>fermi_level</code> (0 by default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hamiltonian.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.projector-Tuple{Function, Spectrum}" href="#LatticeModels.projector-Tuple{Function, Spectrum}"><code>LatticeModels.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projector(fun, spectrum)</code></pre><p>Creates a <code>LatticeOperator</code> that projects onto the eigenvectors of the spectrum with amplitude defined by the <code>fun</code> functions, which takes the eigenvalue and returns a number (or a boolean).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hamiltonian.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.projector-Tuple{Spectrum}" href="#LatticeModels.projector-Tuple{Spectrum}"><code>LatticeModels.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projector(spectrum)</code></pre><p>Creates a <code>LatticeOperator</code> that projects onto the eigenvectors of the spectrum</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hamiltonian.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.spectrum-Tuple{LatticeModels.LatticeArray{LT, &lt;:Matrix} where LT}" href="#LatticeModels.spectrum-Tuple{LatticeModels.LatticeArray{LT, &lt;:Matrix} where LT}"><code>LatticeModels.spectrum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spectrum(operator)</code></pre><p>Finds eigenvalues and eigenvectors for a <code>LatticeOperator</code> and stores in in a Spectrum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hamiltonian.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.@hamiltonian-Tuple{Any}" href="#LatticeModels.@hamiltonian-Tuple{Any}"><code>LatticeModels.@hamiltonian</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@hamiltonian block</code></pre><p>Creates a hamiltonian according to the rules defined in the <code>block</code>.</p><p>Each line in the block must be a <code>:=</code> assignment or a macro-like diagonal/hopping operator description.</p><p>The lattice on and the magnetic field for the hamiltonian can be set by assigning <code>lattice</code> and <code>field</code>.</p><p><code>@diag</code> stands for a diagonal part of the hamiltonian - after this you can use a matrix (representing the operator affecting the internal state), a function or a <code>⊗</code> tensor product notation.</p><p><code>@hop</code> stands for a hopping part of the hamiltonian - list arguments to pass to the <code>hopping</code> function after this macrocall.</p><p><strong>Examples</strong></p><p>For example let&#39;s generate a Chern insulator hamiltonian.</p><pre><code class="language-julia hljs">l = SquareLattice(10, 10)
x, y = coord_values(l)
H = @hamiltonian begin
    lattice := l
    field := LandauField(0.5)   # Landau-calibrated uniform magnetic field, 0.5 flux quanta per 1×1
    @diag (@. abs(x) &lt; 2) ⊗ [1 0; 0 -1]
    @hop [1 im; im -1] / 2 axis = 1
    @hop [1 1; -1 -1] / 2 axis = 2
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/hamiltonian.jl#L92-L121">source</a></section></article><h2 id="Currents"><a class="docs-heading-anchor" href="#Currents">Currents</a><a id="Currents-1"></a><a class="docs-heading-anchor-permalink" href="#Currents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.AbstractCurrents" href="#LatticeModels.AbstractCurrents"><code>LatticeModels.AbstractCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCurrents</code></pre><p>Supertype for all type representing currents-like values on a lattice. Subtypes must implement <code>current_lambda</code> and <code>lattice</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/currents.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.DensityCurrents" href="#LatticeModels.DensityCurrents"><code>LatticeModels.DensityCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityCurrents &lt;: AbstractCurrents</code></pre><p>Density currents for given density matrix and given hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/currents.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.MaterializedCurrents" href="#LatticeModels.MaterializedCurrents"><code>LatticeModels.MaterializedCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaterializedCurrents &lt;: AbstractCurrents</code></pre><p>A <code>AbstractCurrents</code> instance that stores values for all currents explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/currents.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.SubCurrents" href="#LatticeModels.SubCurrents"><code>LatticeModels.SubCurrents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubCurrents{CT&lt;:AbstractCurrents} &lt;: AbstractCurrents</code></pre><p>A lazy wrapper for a <code>SubCurrents</code> object that representing the same currents but on a smaller lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/currents.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.current_lambda-Tuple{T} where T&lt;:AbstractCurrents" href="#LatticeModels.current_lambda-Tuple{T} where T&lt;:AbstractCurrents"><code>LatticeModels.current_lambda</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">current_lambda(::AbstractCurrents)</code></pre><p>Returns a function that takes two integer indices of sites in a lattice and returns the current between these two sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/currents.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.lattice-Tuple{T} where T&lt;:AbstractCurrents" href="#LatticeModels.lattice-Tuple{T} where T&lt;:AbstractCurrents"><code>LatticeModels.lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lattice(::AbstractCurrents)</code></pre><p>Gets the lattice where the given <code>AbstractCurrents</code> object is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/currents.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.materialize-Tuple{AbstractCurrents}" href="#LatticeModels.materialize-Tuple{AbstractCurrents}"><code>LatticeModels.materialize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">materialize([function, ]currents)</code></pre><p>Creates a <code>MaterializedCurrents</code> instance for <code>currents</code>.</p><p>If <code>function</code> is provided, it must accept a <code>Lattice</code> and two <code>LatticeSite</code>s and return if the current between this site must be calculated or not. This can be useful to avoid exsessive calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/currents.jl#L108-L115">source</a></section></article><h2 id="Unitary-evolution"><a class="docs-heading-anchor" href="#Unitary-evolution">Unitary evolution</a><a id="Unitary-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Unitary-evolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.evolution_operator-Tuple{Any, Real}" href="#LatticeModels.evolution_operator-Tuple{Any, Real}"><code>LatticeModels.evolution_operator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evolution_operator(H, t[, k])</code></pre><p>Calculates the unitary evolution operator using the formula</p><p>$ \mathcal{U}(t) = e^{-\frac{1}{i\hbar} \hat{H} t} $</p><p><strong>Arguments</strong></p><ul><li><code>H</code>: the hamiltonian matrix</li><li><code>t</code>: the evolution time</li><li><code>k</code>: if provided, the exponent will be calculated using a Taylor series expansion with order k</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/evolution.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LatticeModels.@evolution-Tuple" href="#LatticeModels.@evolution-Tuple"><code>LatticeModels.@evolution</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@evolution [kwargs...] {rules...} for_loop</code></pre><p>Generates an environment with defined hamiltonian and density matrices that evolve by certain laws. See <a href="../evolution/">Unitary evolution</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/283d71f73855d5f043d1501f591da1c46cae9399/src/evolution.jl#L185-L190">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced/">« Advanced options</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 9 November 2022 14:21">Wednesday 9 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

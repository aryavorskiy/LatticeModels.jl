var documenterSearchIndex = {"docs":
[{"location":"currents/#Usage","page":"Currents","title":"Usage","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents object is a lazy object that can calculate any current-like value between any pair of sites.  Usage is pretty simple:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"using LatticeModels, Plots","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"l = SquareLattice(10, 10)\nH = @hamiltonian begin   \n    lattice := l\n    @hop axis = 1\n    @hop axis = 2\n    field := FluxField(1, (5.5, 5.5))\nend\nP = filled_projector(spectrum(H), -0.5)\n\ncurr = DensityCurrents(H, P)                    # Create Currents object\nheatmap(site_density(P))\nplot!(curr, arrows_scale=25, arrows_rtol=0.1, color=:blue)    # Quiver-plot the currents","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"What happened here? The formula for the density current from site i to site j is J_ij = texttr(-i hath_ij hatc^dagger_i hatc_j hatrho + h c) = 2 textIm tr(hath_ij hatc^dagger_i hatc_j hatrho).  The curr object contains this formula inside and when this object is passed to the plot function, all needed currents are evaluated.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"A current between each pair of sites is shown as an arrow directed from one to another with its length proportional to the strength of the current. The arrows_scale keyword argument scales all arrows by given factor, while arrows_rtol hides all arrows that are shorter than some fraction of the distance between the sites.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"You can display currents between certain sites by using a boolean-typed LatticeValue and bracket-notation:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"x, y = coord_values(l)\nsub_curr = curr[x .< y]\nplot!(sub_curr, arrows_scale=25, arrows_rtol=0.1, color=:green)","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Here all currents between sites in the upper-left coordinate triangle are marked green.","category":"page"},{"location":"currents/#Interface","page":"Currents","title":"Interface","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"It is quite likely that you might want to define your own type of currents. All you need to do is inherit the AbstractCurrents type and define two functions:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"lattice(::MyCurrents) must return the lattice which the currents are defined on\ncurrents_lambda(::MyCurrents) must return a lambda which takes two integer site indices and returns the current between these two sites. Note that the function must be skew-symmetric, e. g. curr_lambda(i, j) == -curr_lambda(j, i).","category":"page"},{"location":"currents/#Materialized-currents","page":"Currents","title":"Materialized currents","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents is a lazy object. This allows to avoid excessive computation, but the computations that are needed will be repeated every time when we use that object. That's where the MaterializedCurrents come in, having all their values stored explicitly in an array.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"To convert any type of currents to MaterializedCurrents, simply use the materialize function. You can avoid evaluating some currents (for example, if you know beforehand that they must be zero) by passing a lambda as a first argument (or with do-syntax): it must take the Lattice and two LatticeSites and return whether the current between these sites must be evaluated.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"You can find it similar to the selector function we used back in Hopping operators, which indeed is. You may find the following selector functions useful:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Passing a PairSet produced by the bonds function will keep only the currents between adjacent sites.\npairs_by_distance will allow you to select pairs of sites depending on the distance between them. ","category":"page"},{"location":"currents/#Mapping-currents","page":"Currents","title":"Mapping currents","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"In some cases we want to find out how currents depend on some lattice properties: for example, the distance between sites. In such case, the map_currents function can be quite helpful.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Let's find the mean and the standard deviation for currents between sites given the distance between them:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"using LinearAlgebra, Statistics\n\ndist, adcurr = map_currents(\n    curr, \n    reduce_fn=(x -> [mean(abs.(x)), std(abs.(x))]),\n    sort=true\n) do l, site1, site2\n    norm(site_coords(l, site1) - site_coords(l, site2))\nend\n\nacurr, dcurr = eachcol(adcurr)\nscatter(dist, acurr, err=dcurr, xlims=(0, 14))","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"What happened here? The map_currents function found the distance and the current between each pair of sites. Then for each distance between sites it found the mean and standard deviation for the absolute value of the currents in such pairs, and stored it column-wise in a matrix automatically. In the next line we extracted the mean and standard deviation into separate lists, and plotted the obtained data.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"From this picture we can see that there are no density currents between non-adjacent sites, as one must have expected.","category":"page"},{"location":"library/#LatticeModels.jl","page":"Library","title":"LatticeModels.jl","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-creation","page":"Library","title":"Lattice creation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice.jl\"]","category":"page"},{"location":"library/#LatticeModels.Bravais","page":"Library","title":"LatticeModels.Bravais","text":"Bravais{N, NB}\n\nN-dimensional infinite Bravais lattice with NB sites in basis.\n\n\n\nBravais(translation_vectors[, basis])\n\nConstructs a Bravais lattice with given translation vectors and locations of basis sites relative to some unit cell. The basis argument can be omitted, in which case the lattice basis will consist of one site located in the bottom-left corner of the unit cell.\n\ntranslation_vectors argument must be an AbstractMatrix{<:Real} of size N×N, while basis must also be an  abstract matrix of size N×NB.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nType alias for Lattice{:honeycomb,2,2}.\n\n\n\nHoneycombLattice(sz::Vararg{Int, 2})\n\nConstructs a honeycomb lattice with a sz-size macro cell.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Lattice","page":"Library","title":"LatticeModels.Lattice","text":"Lattice{LatticeSym, N, NB}\n\nA finite subset of a Brvais{N, NB}. LatticeSym is a Symbol which represents the type of the lattice (e. g. :square, :honeycomb). This makes Lattice object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.\n\n\n\nLattice(sym, sz, bvs[, mask])\n\nConstructs a finite Lattice{sym, N, NB} as a subset of the bvs Bravais lattice. sz is a NTuple{N, Int} which represents how many times the unit cell of bvs was translated by each axis - these sites form a macro cell. mask, if defined, is a Vector{Bool} storing information about which of the sites from the macro cell are actually included in the lattice, and which are not.\n\nFor example, a 3×3 square lattice with its center site excluded is represented as Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])\n\nTo define a new type of lattice, create an alias for Lattice{YourSym, YourN, YourNB}. Refer to the docs for detailed explanation.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeSite","page":"Library","title":"LatticeModels.LatticeSite","text":"LatticeSite{N}\n\nA site of a Lattice{LatticeSym, N, NB} lattice.\n\nFields:\n\nunit_cell: a set of translations along all axes representing the unit cell the site is located in.\nbasis_index: the number of site in the lattice basis.\n\nThis type is used to iterate over all sites of a Lattice{LatticeSym, N, NB}. The exact location of a LatticeSite can be found using the site_coords(lattice, site) function.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nType alias for Lattice{:square,N,1}.\n\n\n\nSquareLattice(sz::Int...)\n\nConstructs a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.radius_vector-Union{Tuple{N}, Tuple{Lattice, LatticeSite{N}, LatticeSite{N}}} where N","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(l::Lattice, site1::LatticeSite, site2::LatticeSite) -> vector\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macro cell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_coords-Tuple{Lattice, LatticeSite}","page":"Library","title":"LatticeModels.site_coords","text":"site_coords(lattice::Lattice, site::LatticeSite) -> vector\n\nFinds the location in space of lattice site site on lattice lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_distance-Tuple{Lattice, LatticeSite, LatticeSite}","page":"Library","title":"LatticeModels.site_distance","text":"site_distance(l::Lattice, site1::LatticeSite, site2::LatticeSite[; pbc=false])\n\nReturns the distance between two sites on the l lattice.\n\nKeyword arguments:\n\npbc: if true, the boundary conditions will be considered periodic and\n\nthe distance will be measured on the shortest path.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_distance-Tuple{}","page":"Library","title":"LatticeModels.site_distance","text":"site_distance(; pbc)\n\nGenerates a function that finds the distance between sites (see site_distance(::Lattice, ::LatticeSite, ::LatticeSite)). This notation can be handy when passing this function as an argument.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_index-Tuple{Lattice, LatticeSite}","page":"Library","title":"LatticeModels.site_index","text":"site_index(l::Lattice, site::LatticeSite)\n\nReturns the integer index for given site in lattice. Returns nothing if the site is not present in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym","page":"Library","title":"LatticeModels.sublattice","text":"sublattice(lf::Function, l::Lattice) -> Lattice\n\nGenerates a a subset of lattice l by applying the lf function to its sites. The lf function must accept two positional arguments (a LatticeSite and a vector with its coordinates) and return a boolean value.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-values","page":"Library","title":"Lattice values","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_value.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LatticeSym}\n\nRepresents a value of type T on a Lattice{LatticeSym} lattice.\n\nFields:\n\nlattice: the Lattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeValue-Tuple{Lattice, AbstractVector}","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue(l::Lattice, v::AbstractVector)\n\nConstructs a LatticeValue object.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coord_values-Tuple{Lattice}","page":"Library","title":"LatticeModels.coord_values","text":"coord_values(l::Lattice)\n\nGenerates a tuple of LatticeValues representing spatial coordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.plot_fallback-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.plot_fallback","text":"plot_fallback(lv::LatticeValue)\n\nCreates a copy of lv lattice value with its LatticeSym overwritten to :plot_fallback. Use it to invoke the default plot recipe for LatticeValues when defining a custom one.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.project-Tuple{LatticeValue{<:Number, LT} where LT, Any}","page":"Library","title":"LatticeModels.project","text":"project(lv::LatticeValue, axis)\n\nCreates a mapping from site coordinates to values of lv. The coordinate axis to project the sites onto can be set with the axis argument - it can be either an integer from 1 to 3 or an axis descriptor Symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-arrays","page":"Library","title":"Lattice arrays","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_array.jl\"]","category":"page"},{"location":"library/#LatticeModels.Basis","page":"Library","title":"LatticeModels.Basis","text":"Basis{LT} where {LT<:Lattice}\n\nA basis on a lattice with some number of internal states on each site. Fields:\n\nlattice: the Lattice of the basis\ninternal_dim: the number of internal states on each site\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeArray","page":"Library","title":"LatticeModels.LatticeArray","text":"LatticeArray{AT, LT, N}\n\nA wrapper object for array representing a wave function or linear operator. Stores information about its basis to perform lattice checks.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeOperator-Tuple{Basis, LinearAlgebra.UniformScaling}","page":"Library","title":"LatticeModels.LatticeOperator","text":"LatticeOperator{MT, LT}\n\nThe same as LatticeArray{MT, LT, 2} where MT<:AbstractMatrix.\n\n\n\nLatticeOperator(uniform_scaling::UniformScaling, basis::Basis)\n\nCreates a LatticeOperator representation of a UniformScaling operator on given basis. For example, LatticeOperator(LinearAlgebra.I, basis) yields an identity operator on basis basis.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TensorProduct","page":"Library","title":"LatticeModels.TensorProduct","text":"TensorProduct{LVT, MT} where {LVT<:LatticeValue{<:Number}, MT<:AbstractMatrix}\n\nA lazy representation of an operator as a tensor product of two distinct phase spaces. One affects only the internal space, the other - only the lattice space.\n\nThe lattice_value ⊗ matrix notation computes the value of the TensorProduct eagerly, which means that the result will be a LatticeOperator. However, in the @hamiltonian macro lazy computation is forced.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coord_operators-Tuple{Basis}","page":"Library","title":"LatticeModels.coord_operators","text":"coord_operators(basis::Basis)\n\nReturns a Tuple of coordinate LatticeOperators for given basis.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coord_operators-Tuple{Lattice, Int64}","page":"Library","title":"LatticeModels.coord_operators","text":"coord_operators(lattice::Lattice, ndims::Tnt)\n\nThe same as coord_operators(Basis(lattice, ndims)).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(lv::LatticeValue, N::Int=1)\n\nCreates a diagonal operator which affects only the lattice space. The lv argument must be a LatticeValue storing diagonal elements of the operator in lattice space. N is the number of internal degrees of freedom on each site.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.diag_operator-Tuple{Function, Basis}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(f, bas::Basis)\ndiag_operator(f, l::Lattice, N::Int)\n\nCreates a diagonal operator by applying the f function to each site of the lattice of given basis. f must accept a LatticeSite and its coordinate vector and return a number or a matrix which represents operator affecting the internal state of the site.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Lattice, AbstractMatrix}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(lattice::Lattice, matrix::AbstractMatrix)\n\nCreates a diagonal operator which affects only the internal state the same way on every site. matrix is an AbstractMatrix representing the linear operator on the internal space.\n\nNote that the matrix of the output LatticeOperator will be similar to matrix: for instance, if matrix is sparse, so will be the output.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_reduce-Tuple{Function, LatticeOperator}","page":"Library","title":"LatticeModels.diag_reduce","text":"diag_reduce(f, lattice_operator::LatticeOperator)\n\nCreates a LatticeValue where a site maps to the result of f on the matrix of the operator narrowed to that site.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ptrace-Tuple{LatticeOperator, Symbol}","page":"Library","title":"LatticeModels.ptrace","text":"ptrace(lattice_operator::LatticeOperator, space)\n\nCalculates a matrix for the partial trace of given operator. space argument must take one of two values:\n\n:lattice for taking the partial trace over the lattice space.\n:internal for the same over the internal space.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_density-Tuple{LatticeOperator}","page":"Library","title":"LatticeModels.site_density","text":"site_density(lattice_vector::LatticeVector)\nsite_density(lattice_operator::LatticeOperator)\n\nA convenience function to find local density for wave functions (represented by lattice_vector) and density matrices (represented by lattice_operator).\n\nReturns a LatticeValue representing the total probability of the particle of being on every site.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@on_lattice-Tuple{Any}","page":"Library","title":"LatticeModels.@on_lattice","text":"@on_lattice expression\n\nReplaces all LatticeArrays in subsequent function calls with actual arrays stored inside them. Throws an error if lattice arrays in one function call are defined on different lattices, shows a warning if a lattice array is used in one call with a normal array.\n\nExample\n\nl = SquareLattice(10, 10)\nbas = Basis(l, 2)\nX, Y = coord_operators(bas)\nxexpypy = diag_operator(bas) do site, (x, y)\n    x * exp(y) + y\nend\nxexpypy == @on_lattice X * exp(Y) + Y     # true\n\n\n\n\n\n","category":"macro"},{"location":"library/#Hoppings","page":"Library","title":"Hoppings","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hoppings.jl\"]","category":"page"},{"location":"library/#LatticeModels.AbstractPairSelector","page":"Library","title":"LatticeModels.AbstractPairSelector","text":"AbstractPairSelector <: Function\n\nA function-like object that accepts a Lattice and two LatticeSites and returns whether the site pair is selected or not. Implements a built-in sanity check algorithm to make sure the pair set was defined on a correct lattice.\n\nDefine these functions for all subclasses:\n\nLatticeModels.lattice(::YourSelector) must return the lattice your selector was defined on.\nLatticeModels.match(::YourSelector, site1::LatticeSite, site2::LatticeSite) must return whether the (site1, site2) pair is selected.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.DomainsSelector","page":"Library","title":"LatticeModels.DomainsSelector","text":"DomainsSelector(domains::LatticeValue)\n\nA selector used for hopping operator definition or currents materialization.\n\nTakes a LatticeValue. A pair matches the selector if the value of domains is the same on two sites.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Hopping","page":"Library","title":"LatticeModels.Hopping","text":"Hopping{N} where N\n\nA struct representing a bond in a lattice.\n\nsite_indices: a NTuple{2, Int} with indices of sites connected by the bond.\ntranslate_uc: the unit cell offset.\npbc: a vector of boolean values indicating if the bonds should be applied periodically over each axis.\nhop_operator: a matrix of N×N representing the operator affecting the internal state.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PairLhsSelector","page":"Library","title":"LatticeModels.PairLhsSelector","text":"PairLhsSelector(lhs::LatticeValue)\n\nA selector used for hopping operator definition or currents materialization.\n\nTakes a LatticeValue. A pair matches the selector if the value of lhs is true on the first site of the pair.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PairRhsSelector","page":"Library","title":"LatticeModels.PairRhsSelector","text":"PairRhsSelector(rhs::LatticeValue)\n\nA selector used for hopping operator definition or currents materialization.\n\nTakes a LatticeValue. A pair matches the selector if the value of rhs is true on the first site of the pair.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PairSet","page":"Library","title":"LatticeModels.PairSet","text":"PairSet{LT} where {LT<:Lattice}\n\nRepresents the bonds on some lattice.\n\nPairSets can be combined with the | operator and negated with the ! operator. Also you can create a PairSet which connects sites that were connected by ≤n bonds of the previous PairSet by taking its power: bs2 = bs1 ^ n.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.bonds-Tuple{Lattice, Vararg{LatticeModels.Hopping}}","page":"Library","title":"LatticeModels.bonds","text":"bonds(l::Lattice, hoppings::Hopping...)\n\nGenerates a PairSet for a given set of Hoppings on a given Lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.bonds-Tuple{LatticeOperator}","page":"Library","title":"LatticeModels.bonds","text":"bonds(op::LatticeOperator)\n\nGenerates a PairSet for the provided operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.hopping","page":"Library","title":"LatticeModels.hopping","text":"hopping([hop_operator,] kwargs...)\n\nA convenient constructor for a Hopping object. hop_operator can be either a matrix or a number (in that case a 1×1 matrix will be created automatically)\n\nKeyword arguments:\n\nsite_indices: a NTuple{2, Int} (or Int if they are equal) with indices of sites connected by the bond. (1, 1) by default.\ntranslate_uc: the unit cell offset. Zeros by default.\naxis: overrides translate_uc and sets its components to zero on all axes except given.\npbc: a vector of boolean values indicating if the bonds should be applied periodically over each axis.\n\nCan also be a single boolean, which will set all elements of the vector to given value. false by default.\n\nIf site_indices are equal and translate_uc is zero, this means that the bond connects each site with itself, in which case an error will be thrown. Note that the dimension count for the hopping is dynamic and will automatically change during runtime.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.hopping_dest-Tuple{Lattice, LatticeModels.Hopping, LatticeSite}","page":"Library","title":"LatticeModels.hopping_dest","text":"hopping_dest(l::Lattice, hop::Hopping, site::LatticeSite)\n\nFinds the destination site of the hop hopping, given the lattice and the source site site.\n\nReturns a tuple containing the destination site and a SVector with integer numbers describing the macrocell shift.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.hopping_operator","page":"Library","title":"LatticeModels.hopping_operator","text":"hopping_operator([f, ]lattice::Lattice, hopping::Hopping[, field::AbstractField])\n\nCreates a hopping operator: hatA = sum_pairs hatt hatc^dagger_j hatc_i + h c\n\nArguments:\n\nf: a function that takes a Lattice and two LatticeSites, returns whether this pair should be included.\n\nCan also be a PairSelector,\n\nlattice: the lattice to create the operator on.\nhopping: the Hopping object describing the site pairs and the hatt operator.\nfield: the AbstractField object that defines the magnetic field to generate phase factors using Peierls substitution.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.promote_dims!-Tuple{LatticeModels.Hopping, Int64}","page":"Library","title":"LatticeModels.promote_dims!","text":"promote_dims!(h::Hopping, ndims::Int)\n\nChanges dimension count of hopping to ndims if possible.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.radius_vector-Tuple{Lattice, LatticeModels.Hopping}","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(l::Lattice, hop::Hopping)\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macro cell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#Magnetic-fields","page":"Library","title":"Magnetic fields","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"field.jl\"]","category":"page"},{"location":"library/#LatticeModels.FluxField","page":"Library","title":"LatticeModels.FluxField","text":"FluxField <: AbstractField\n\nAn object representing a small magnetic flux through given point. The field is directed along z-axis. Fields:\n\nB: The magnetic field value\npoint: A NTuple{2, Number} representing the point where the magnetic flux is located.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LandauField","page":"Library","title":"LatticeModels.LandauField","text":"LandauField <: AbstractField\n\nAn object representing Landau calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NoField","page":"Library","title":"LatticeModels.NoField","text":"NoField <: AbstractField\n\nA stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SymmetricField","page":"Library","title":"LatticeModels.SymmetricField","text":"SymmetricField <: AbstractField\n\nAn object representing symmetrically calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.apply_field!-Tuple{LatticeOperator, AbstractField}","page":"Library","title":"LatticeModels.apply_field!","text":"apply_field!(hamiltonian, field[; nsteps])\n\nApplies magnetic field to given hamiltonian matrix by adjusting the phase factors.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.path_integral-Tuple{AbstractField, Any, Any}","page":"Library","title":"LatticeModels.path_integral","text":"path_integral(field, p1, p2[, n_steps=1])\n\nCalculates the int_p1^p2 overrightarrowA cdot overrightarrowdl integral using the trapezoidal rule. Increase n_steps to improve accuracy (for linear fields like Landau or symmetrical calibrations the formula is accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.vector_potential-Tuple{AbstractField, Any}","page":"Library","title":"LatticeModels.vector_potential","text":"vector_potential(field, point)\n\nReturns vector potential overrightarrowA for field in location point.\n\nThis function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@field_def-Tuple{Any}","page":"Library","title":"LatticeModels.@field_def","text":"@field_def block\n\nDefines a new magnetic field type.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Hamiltonian-tools","page":"Library","title":"Hamiltonian tools","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hamiltonian.jl\"]","category":"page"},{"location":"library/#LatticeModels.Spectrum","page":"Library","title":"LatticeModels.Spectrum","text":"Spectrum{LT, MT} where {LT<:Lattice, MT<:AbstractMatrix}\n\nEigenvalues and eigenvectors for some operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Haldane","page":"Library","title":"LatticeModels.Haldane","text":"Haldane([f, ]l::HoneycombLattice, t1::Real, t2::Real[, m::Real=0; field::AbstractField])\n\nhatH =\nsum_i^textsublattice A m c^dagger_i c_i +\nsum_j^textsublattice B m c^dagger_j c_j +\nsum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) +\nsum_i j^text2-connectedcounter-clockwise left( i cdot t_2 c^dagger_i c_j + h c right)\n\nGenerates a Haldane topological insulator hamiltonian operator.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.SpinTightBinding-Tuple{Any, LatticeValue{<:Number, :square}}","page":"Library","title":"LatticeModels.SpinTightBinding","text":"SpinTightBinding([f, ]mv::LatticeValue[; field::AbstractField, pbc=false])\nSpinTightBinding([f, ]l::SquareLattice[, m::Number=1; field::AbstractField, pbc=false])\n\nhatH =\nsum_i^textsites m_i c^dagger_i sigma_z c_i +\nsum_i^textsites left(\nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i +\nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i +\nh c right)\n\nGenerates a spin-orbital tight-binding hamiltonian operator with set magnetic field and boundary conditions. If the m_i values are set by the mv::LatticeValue, which must be defined on a SquareLattice. Otherwise they will all be set to m.\n\nf here must be a function or a PairSelector describing which hoppings will be excluded.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TightBinding-Tuple{Any, LatticeValue{<:Number}}","page":"Library","title":"LatticeModels.TightBinding","text":"TightBinding([f, ]lv::LatticeValue[; field::AbstractField, pbc=false])\n\nSame as TightBinding(f, lattice(lv)), but adds a diagonal part sum_i^sites V_i c_i^dagger c_i with V_i set by lv.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TightBinding-Union{Tuple{N}, Tuple{Any, SquareLattice{N}}} where N","page":"Library","title":"LatticeModels.TightBinding","text":"TightBinding([f, ]l::Lattice[, field::AbstractField; pbc=false])\n\nhatH = sum_i^textsites sum_hatr^textbonds c_i^dagger c_i+hatr + hc\n\nGenerates a tight-binding hamiltonian operator on given lattice l with set magnetic field and boundary conditions. l must be a SquareLattice or a HoneycombLattice.\n\nf here must be a function or a PairSelector describing which hoppings will be excluded.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.bose_einstein-Tuple{Any, Any}","page":"Library","title":"LatticeModels.bose_einstein","text":"bose_einstein(μ, T)\n\nGenerates a function that takes the energy and returns the state density acccording to Bose-Einstein statistics.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.dos-Tuple{Spectrum, Real}","page":"Library","title":"LatticeModels.dos","text":"dos(sp::Spectrum, δ)\n\nGenerates a function to calculate the DOS (Density of States), which is defined as texttrleft(frac1hatH - E - ideltaright) and can be understood as a sum of Lorenz distributions with width equal to delta.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.fermi_dirac-Tuple{Any, Any}","page":"Library","title":"LatticeModels.fermi_dirac","text":"fermi_dirac(μ, T)\n\nGenerates a function that takes the energy and returns the state density acccording to Fermi-Dirac statistics.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.filled_projector","page":"Library","title":"LatticeModels.filled_projector","text":"filled_projector(sp::Spectrum[, fermi_level=0])\n\nCreates a LatticeOperator that projects onto the eigenvectors which have eigenvalues E_i less than fermi_level (0 by default).\n\nSame as projector(<(fermi_level), sp), see\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.ldos-Tuple{Spectrum, Real, Real}","page":"Library","title":"LatticeModels.ldos","text":"ldos(sp::Spectrum, E, δ)\n\nCalculates the LDOS (Local Density of States), which is defined as the imaginary part of partial trace of frac1hatH - E - idelta operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ldos-Tuple{Spectrum, Real}","page":"Library","title":"LatticeModels.ldos","text":"ldos(sp::Spectrum, δ)\n\nGenerates a function that accepts the energy E and returns ldos(sp, E, δ). Use this if you want to find the LDOS for the same Spectrum, but for many different values of E - the produced function is optimized and reduces overall computation time dramatically.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{Function, Spectrum}","page":"Library","title":"LatticeModels.projector","text":"projector(f, sp::Spectrum)\n\nhatmathcalP = sum_i p_i psi_ipsi_i\n\nCreates a LatticeOperator that projects onto the eigenvectors of the spectrum, described by the formula above. The p_i amplitudes are defined by the f function, which takes the eigenvalue E_i and returns a number (or a boolean).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{Spectrum}","page":"Library","title":"LatticeModels.projector","text":"projector(sp::Spectrum)\n\nhatmathcalP = sum_i psi_ipsi_i\n\nCreates a LatticeOperator that projects onto the eigenvectors of the spectrum, described by the formula above.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.spectrum-Tuple{LatticeOperator}","page":"Library","title":"LatticeModels.spectrum","text":"spectrum(op::LatticeOperator)\n\nFinds eigenvalues and eigenvectors for a LatticeOperator and stores in in a Spectrum.\n\nnote: Note\nThis method finds eigenvalues and eigenvectors using LinearAlgebra.eigen, which can be not defined for some array types. Consider redefining it for your array type or constructing the Spectrum object explicitly.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@hamiltonian-Tuple{Any}","page":"Library","title":"LatticeModels.@hamiltonian","text":"@hamiltonian block\n\nCreates a hamiltonian according to the rules defined in the block.\n\nEach line in the block must be a := assignment or a macro-like diagonal/hopping operator description.\n\nThe lattice on and the magnetic field for the hamiltonian can be set by assigning lattice and field. You may also need to set the internal dimension count if it is not equal to 1 - use the dims_internal keyword. The arrtype key sets the type of the returned array.\n\n@diag stands for a diagonal part of the hamiltonian - after this you can use a matrix (representing the operator affecting the internal state), a function or a ⊗ tensor product notation.\n\n@hop stands for a hopping part of the hamiltonian - list arguments to pass to the hopping function after this macrocall.\n\nExamples\n\nThis is how a Chern insulator hamiltonian is generated.\n\nl = SquareLattice(10, 10)\nx, y = coord_values(l)\nH = @hamiltonian begin\n    lattice := l\n    field := LandauField(0.5)   # Landau-calibrated uniform magnetic field, 0.5 flux quanta per 1×1\n    dims_internal := 2\n    @diag (@. abs(x) < 2) ⊗ [1 0; 0 -1]\n    @diag randn(l) .* 0.1       # Add Gaussian noise\n    @hop [1 im; im -1] / 2 axis = 1\n    @hop [1 1; -1 -1] / 2 axis = 2\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"currents.jl\"]","category":"page"},{"location":"library/#LatticeModels.AbstractCurrents","page":"Library","title":"LatticeModels.AbstractCurrents","text":"AbstractCurrents\n\nSupertype for all type representing currents-like values on a lattice. Subtypes must implement current_lambda and lattice functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.DensityCurrents","page":"Library","title":"LatticeModels.DensityCurrents","text":"DensityCurrents <: AbstractCurrents\n\nDensity currents for given density matrix and given hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.MaterializedCurrents","page":"Library","title":"LatticeModels.MaterializedCurrents","text":"MaterializedCurrents <: AbstractCurrents\n\nA AbstractCurrents instance that stores values for all currents explicitly.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SubCurrents","page":"Library","title":"LatticeModels.SubCurrents","text":"SubCurrents{CT<:AbstractCurrents} <: AbstractCurrents\n\nA lazy wrapper for a SubCurrents object that representing the same currents but on a smaller lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.current_lambda-Tuple{AbstractCurrents}","page":"Library","title":"LatticeModels.current_lambda","text":"current_lambda(::AbstractCurrents)\n\nReturns a function that takes two integer indices of sites in a lattice and returns the current between these two sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.lattice-Tuple{AbstractCurrents}","page":"Library","title":"LatticeModels.lattice","text":"lattice(::AbstractCurrents)\n\nGets the lattice where the given AbstractCurrents object is defined.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.map_currents-Tuple{Function, AbstractCurrents}","page":"Library","title":"LatticeModels.map_currents","text":"map_currents(map_fn, currs::AnstractCurrents[; reduce_fn, sort=false])\n\nAccepts a function that takes a Lattice and two LatticeSites and returns any value. Applies map_fn to every site pair and returns two Vectors: one with currents, one with results of map_fn.\n\nKeyword arguments:\n\nreduce_fn: if a function is provided, all currents with the same mapped value will be reduced into one value.\n\nFor example, if aggr_fn=(x -> mean(abs.(x))), and map_fn finds the distance between the sites, the returned lists will store the distance between sites and the average absolute current between sites with such distance.\n\nsort: if true, the output arrays will be sorted by mapped value.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.materialize-Tuple{AbstractCurrents}","page":"Library","title":"LatticeModels.materialize","text":"materialize([function, ]currents)\n\nCreates a MaterializedCurrents instance for currents.\n\nIf function is provided, it must accept a Lattice and two LatticeSites and return if the current between this site must be calculated or not. This can be useful to avoid exsessive calculations.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.pairs_by_distance-Tuple{Any}","page":"Library","title":"LatticeModels.pairs_by_distance","text":"pairs_by_distance(f)\n\nA selector function used for hopping operator definition or currents materialization.\n\nTakes a function and generates a lambda which accepts a lattice and two LatticeSites, returning whether f applied to distance between the two sites returned true.\n\n\n\n\n\n","category":"method"},{"location":"library/#Unitary-evolution","page":"Library","title":"Unitary evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"evolution.jl\"]","category":"page"},{"location":"library/#LatticeModels.evolution_operator","page":"Library","title":"LatticeModels.evolution_operator","text":"evolution_operator(H, t[, k, p])\n\nCalculates the unitary evolution operator using the formula\n\n$ \\mathcal{U}(t) = e^{-\\frac{1}{i\\hbar} \\hat{H} t} $\n\nArguments\n\nH: the hamiltonian matrix\nt: the evolution time\nk: if provided, the matrix exponent will be calculated using a Taylor series expansion with order k\np: if set to true, the matrix exponent will be calculated using a Padé approximant, which is\n\nmore precise than Taylor expansion but can also be slower and uses matrix inversion.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.@evolution-Tuple","page":"Library","title":"LatticeModels.@evolution","text":"@evolution [kwargs...] {rules...} for_loop\n\nGenerates an environment with defined hamiltonian and density matrices that evolve by certain laws. See Unitary evolution for more details.\n\nKeyword arguments:\n\nk: order of the Taylor expansion for matrix exponent. If omitted, the default exp function will be used.\npade: set this to true to use Padé approximant formula instead of Taylor expansion.\nrtol: the relative tolerance to decide whether the Δt changed between iterations or not. 1e-12 by default.\nshow_progress: defines whether the progress informer must be displayed or not. true by default.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Value-records","page":"Library","title":"Value records","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"record.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeRecord","page":"Library","title":"LatticeModels.LatticeRecord","text":"LatticeRecord{Eltype}\n\nA struct providing the interface for storing information about how some LatticeValue, LatticeArray or MaterializedCurrents depended on time.\n\nBehaves like a vector of (time, value) tuples, supports time-based indexing (via call syntax, returns a stored record) and site-based indexing (via bracket syntax, returns a vector or a new LatticeRecord, depending on the return type).\n\n\n\n\n\n","category":"type"},{"location":"library/#Base.diff-Union{Tuple{LatticeRecord{ET}}, Tuple{ET}} where ET","page":"Library","title":"Base.diff","text":"diff(lr::LatticeRecord)\n\nDifferentiate the values stored in the record by time using the symmetric difference formula.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate-Union{Tuple{LatticeRecord{ET}}, Tuple{ET}} where ET","page":"Library","title":"LatticeModels.integrate","text":"integrate(lr::LatticeRecord)\n\nIntegrates the values stored in the record over time using the trapezoidal rule.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.time_domain-Tuple{LatticeRecord}","page":"Library","title":"LatticeModels.time_domain","text":"time_domain(lr::LatticeRecord)\n\nReturns the timestamps of the snapshots.\n\n\n\n\n\n","category":"method"},{"location":"hamiltonian/#Hamiltonian-macro","page":"Hamiltonian generation","title":"Hamiltonian macro","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"A hamiltonian operator usually consists of a diagonal part and a hopping part.  Sometimes a magnetic field is applied, in which case additional phase factors emerge according to Peierls substitution. ","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Taking all this into account, the operator will now look something like this:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"hatH = \nsum_i^textsites hats_i hatc^dagger_i hatc_i + left( sum_i j^textadjacent hatt_ij hatc^dagger_j hatc_i\ncdot e^frac2pi iphi_0 int_r_i^r_j overrightarrowA cdot overrightarrowdl + h c right)","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Such an operator can be easily constructed using the @hamiltonian macro.  All you have to do is assign lattice and also field if needed, and then define the diagonal and hopping members using @diag and @hop.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Let's take a look at the example on the Usage examples page:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"A simple tight-binding model hamiltonian for a square lattice is defined by the formula  hatH = sum_i^textsites left( c^dagger_i + hatx c_i + c^dagger_i + haty c_i + h c right)","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"We can create a matrix for this operator on a xsize×ysize square lattice with the following code:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"using LatticeModels","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"TightBinding(xsize, ysize, field=NoField()) = @hamiltonian begin\n    lattice := SquareLattice(xsize, ysize)\n    field := field\n    @hop axis = 1   # x-bonds\n    @hop axis = 2   # y-bonds\nend\nnothing # hide","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Note that the keyword arguments for hopping operators are written as if they were passed to the hopping function.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"For a Chern insulator the hamiltonian looks like this:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"hatH = \nsum_i^textsites m_i c^dagger_i sigma_z c_i + \nsum_i^textsites left( \nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + \nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i + \nh c right)","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Here we want the m_i values to be represented by any number-typed LatticeValue, so the most convenient way to do it is to use tensor product notation:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"# The Pauli matrices\nconst σ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\n\n# Initial hamiltonian: m=1 everywhere\nChernInsulator(m::LatticeValue{<:Number, :square}, field=NoField()) = @hamiltonian begin   \n    lattice := lattice(m)\n    field := field\n    dims_internal := 2\n    @diag m ⊗ σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\nnothing # hide","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Here we must explicitly set the internal phase space dimension count via dims_internal := 2.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Some default hamiltonian formulas are already implemented - see TightBinding, SpinTightBinding, Haldane docstrings for more info.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"tip: Tip\nIt is possible to set the matrix type of the hamiltonian operator at the generation time - use arrtype := <Preferred type> notation, this can be used e. g to reduce memory usage by switching to sparse arrays. Note however that some array types may not support this feature, in which case use the @on_lattice macro.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Note that the field parameter is defaulted to NoField() (this is a magnetic field object representing zero field). Other available magnetic field objects are:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"LandauField(B::Real) - Landau-calibrated uniform magnetic field\nSymmetricField(B::Real) - symmetrically calibrated uniform magnetic field\nFluxField(Φ::Real, point::NTuple{2, Number}) - point magnetic field flux through point.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Most of these fields are designed for 2D lattices, but may also be applied to lattices with other dimensionality. You can define your own field types, see Custom magnetic fields.","category":"page"},{"location":"hamiltonian/#Operator-spectrum-utilities","page":"Hamiltonian generation","title":"Operator spectrum utilities","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"A Spectrum object contains eigenvalues and eigenvectors of some hermitian operator. ","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"It is a very convenient way to work with eigenvectors. Check this out:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"sp = spectrum(TightBinding(5, 5))\nsp[1]       # Get the first eigenstate (e. g. the state with lowest energy)\nsp[3]       # Get the third eigenstate\nsp[E = 0]   # Get eigenstate with energy nearest to 0\nsp[1:3]     # Create a new Spectrum with states from #1 to #3\nE = eigvals(sp) # Get eigenvalues\nsp_filled = sp[E .< 0]  # Create a new Spectrum with filled bands only","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"if you need an operator that projects onto some states, use projector or filled_projector functions:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"P = projector(E -> E < 0, sp)\nP = projector(sp_filled)                # The same thing\nP = filled_projector(sp, 0)             # The same thing\nP = filled_projector(sp)                # The same thing","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Pass a lambda as a first argument to filled_projector to induce arbitrary state density.  The lambda must take the energy and return the density as a real number. The fermi_dirac and bose_einstein helper functions will generate such lambdas for the respective statistics.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"PT = projector(E -> 1 / (exp(E) + 1), sp)\nPT = projector(fermi_dirac(0, 1), sp)   # The same thing","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"warning: Warning\nThe spectrum function finds the eigenvalues and eigenvectors using LinearAlgebra.eigen. You will probably have to define it for array types that do not support default LinearAlgebra routines.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"One more thing you can do with Spectrums is finding the density of states (DOS) and the local density of states (LDOS).  The DOS is the imaginary part of texttrleft(frac1hatH - E - ideltaright) operator, whereas the LDOS is its partial trace.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"It's highly recommended to use the built-in dos and ldos functions, because the Spectrum object stores the hatH operator already diagonalized, which makes calculations much faster.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"using Plots\n\np = plot(layout=@layout[_ a{0.5w} _; grid(1, 2)], size=(800, 800))\nplot!(p[1], -4:0.1:4, dos(sp, 0.2), title=\"DOS with δ = 0.2\")\nplot!(p[2], ldos(sp, 1, 0.2), title=\"LDOS at E = 1 with δ = 0.2\")\n\n# These two lines produce exactly the same result as the previous\nldos_fun = ldos(sp, 0.2)\nplot!(p[3], ldos_fun(1), title=\"LDOS at E = 1 with δ = 0.2 (via function)\")","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"tip: Tip\nIf you want to find the LDOS for the same spectrum and delta, but for many different energy values, consider using ldos(spectrum, delta): it improves performance dramatically.","category":"page"},{"location":"advanced/#PairSelector-API","page":"Advanced options","title":"PairSelector API","text":"","category":"section"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"A PairSelector, as described in the Pair selectors paragraph, is a lambda-like object.  Actually, everything that differs is a built-in sanity check algorithm ensuring that the lattice it is used on is a subset of the lattice it was defined on.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"To implement this interface, you must inherit the LatticeModels.AbstractPairSelector class and define two methods:","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"LatticeModels.lattice(::YourSelector) must return the lattice your selector was defined on.\nLatticeModels.match(::YourSelector, site1::LatticeSite, site2::LatticeSite) must return whether the (site1, site2) pair is selected.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"Let's take a look at the built-in DomainsSelector:","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"struct DomainsSelector <: LatticeModels.AbstractPairSelector\n    domains::LatticeValue\nend\nLatticeModels.lattice(ps::DomainsSelector) = lattice(ps.domains)\nLatticeModels.match(ps::DomainsSelector, site1::LatticeSite, site2::LatticeSite) =\n    ps.domains[site1] == ps.domains[site2]","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"It's quite likely though that the built-in PairSelectors will cover all your needs:","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"DomainsSelector can split your lattice into different domains: pass a LatticeValue and the pair will be selected only if the values on both sites match.\nPairLhsSelector takes a boolean-typed LatticeValue and selects a site pair only if the value on the first site of the pair is true. Can be useful for creating a slit in the lattice sample.\nPairRhsSelector is the same as previous, but selects pairs by the second site of the pair.\nPairSet is an arbitrary set of site pairs - you can generate one by yourself or use the bonds function.\nYou may also find the pairs_by_distance function useful: it is not a PairSelector because it is lattice-independent, but you may find it convenient if you want to select site pairs depending on the distance between the sites in the pair.","category":"page"},{"location":"advanced/#Custom-magnetic-fields","page":"Advanced options","title":"Custom magnetic fields","text":"","category":"section"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"You can induce magnetic field by setting the vector potential overrightarrowA in every point of the space. This can be done by creating an AbstractField object: this is a lazy object that stores information about the magnetic field and implements the LatticeModels.vector_potential function that calculates the above-mentioned vector potential.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"The int_r_1^r_2 overrightarrowA cdot overrightarrowdl integral is found automatically with the LatticeModels.path_integral function. The number of steps can be adjusted, but it is recommended to redefine this method for each new magnetic field type using an exact formula: this will improve performance and accuracy in most cases.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"You can use a convenience macro to simplify definition of new field types:","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"@field_def struct LandauField(B::Number=1)\n    # Define the vector potential function\n    vector_potential(x) = (0, x*B)\n\n    # Redefine the integrating function\n    path_integral(p1, p2) = ((p1[1] + p2[1]) / 2) * (p2[2] - p1[2]) * B\nend","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"Let's see what happened here.  This macro created a new struct LandauField <: AbstractField with only one field B::Number and a constructor LandauField(B::Number=1).","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"It also defined a suitable LatticeModels.vector_potential function. The only parameter in this function definition is x, which will be the X coordinate of the point (all other coordinate values will not be passed).  The return type must be Tuple or SVector to ensure that it can be converted to SVector by the default LatticeModels.path_integral implementation.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"This field object is compatible with lattices of any dimension count. Undefined elements of the overrightarrowA vector will be set to zero, and \"excessive\" ones will be discarded.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"tip: Tip\nTo handle dimension-dependent behavior, you can use vector_potential(p...) = (0, p[1]*B) notation. Here p is a SVector which will allow you to yield different values depending on the dimension count.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"You may notice that here the LatticeModels.path_integral function was also redefined. It simply takes two SVectors describing the coordinates of p_1 and p_2 and returns the value of the int_p_1^p_2 overrightarrowA cdot overrightarrowdl path integral between them.","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"tip: Tip\nTo control the accuracy and performance of the integration without redefining LatticeModels.path_integral,  set the default number of integration steps by adding n_steps := <desired number> to the struct definition.","category":"page"},{"location":"advanced/#Custom-array-backends","page":"Advanced options","title":"Custom array backends","text":"","category":"section"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"You can freely change the type of underlying arrays in LatticeArrays by using the @on_lattice macro. It will convert the internal array to the desired type and wrap it with the same Basis:","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"using LatticeModels # hide\nX, Y = coord_operators(SquareLattice(50, 50), 2)\nXY = X * Y\nusing SparseArrays\nsp_XY = @on_lattice sparse(XY)","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"In this example the @on_lattice macro transformed the call to sparse so that the internal array was passed to it,  and its output was wrapped into a LatticeArray. Thus, sp_XY here is an operator on a sparse matrix, but equal to XY. ","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"Same way, you can send LatticeArrays to your GPU by calling @on_lattice cu(XY) from CUDA.jl.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"We often  want to study the behavior of some quantum system in time-dependent conditions. We can use the unitary evolution operator to describe how the density matrix depends on time:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"mathcalU(t) = Tleft e^frac1ihbar int_t_0^t hatH(tau) dtau righthspace05cm\nmathcalP(t) = mathcalU(t) mathcalP_0 mathcalU^dagger (t)","category":"page"},{"location":"evolution/#The-evolution-macro","page":"Unitary evolution","title":"The evolution macro","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro can be quite useful if your hamiltonian depends on time or if there are multiple hamiltonians in your experiment. It avoids excessive computation in several cases automatically:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian does not change, the mathcalU(t dt) operator will not be re-evaluated.\nIf several wave functions or density matrices evolve using the same hamiltonian, neither the hamiltonian nor the evolution operator matrix will be re-evaluated.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us define a function that generates a Chern insulator hamiltonian:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"using LatticeModels, Plots\nσ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\nChern(l, B) = @hamiltonian begin\n    lattice := l\n    field := LandauField(B)\n    dims_internal := 2\n    @diag σ[3]\n    @hop axis=1 (σ[3] - im * σ[1]) / 2\n    @hop axis=2 (σ[3] - im * σ[2]) / 2\nend\nnothing # hide","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The @evolution macro creates a scope where the hamiltonian and wave functions (or density matrices) are evaluated for the given time interval.  It takes two arguments: a braced list with evolution specifiers and a for-loop that iterates over the time interval:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"l = SquareLattice(10, 10)\nτ = 30\na = Animation()\nB = 0.01\nP0 = filled_projector(spectrum(Chern(l, 0)))\n\n@evolution {\n    H := Chern(l, B * min(t, τ) / τ),\n    P0 --> H --> P\n} for t in 0:0.1:2τ\n    cur = DensityCurrents(H, P)\n    heatmap(site_density(P), title=\"Local density, t = $t\", clims=(0.9, 1.1))\n    plot!(cur, arrows_scale=20, color=:blue)\n    frame(a)\nend\ngif(a, \"animation.gif\")","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us make it clear what an evolution specifier is. In fact, there are two possible variants:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"It is an evolution rule describing the initial state, the hamiltonian it will evolve accroding to, and the name of the variable to write the result. These three arguments must be written in a chain delimited by --> like this: \nP0 --> Chern(l, B * min(t, τ) / τ) --> P\nNote that you can use a hamiltonian alias instead of an expression if it was previously defined.\nIt is an alias declaration, which means that a certain expression will be evaluated on every iteration and assigned to a variable with a given name. For example, H := Chern(l, B * min(t, τ) / τ) evaluates the Chern insulator hamiltonian and writes the result to the H variable.","category":"page"},{"location":"evolution/#Compatibility","page":"Unitary evolution","title":"Compatibility","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro is designed to be compatible with arbitrary array types. This means that hamiltonian expressions or initial states needn't to be LatticeArrays, but they can be of any array type instead, as long as it supports linear algebra operations such as matrix multiplication.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here are the functions that must be defined for the desired array type:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Equality operator: ==\nBasic arithmetic functions: +, -, *, adjoint\nThe identity matrix one(A)\nThe matrix exponent exp(A)\nIf it is not possible to implement this function you can set the k keyword argument (see below) to calculate the matrix exponent as a partial sum of Taylor series.\nIf the inverse matrix inv(A) function is defined, you can use the Padé approximant for the matrix exponent, which is generally more accurate.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"warning: Warning\nIf you use LatticeArrays, you still have to make sure these functions and operators are defined for the underlying array type.","category":"page"},{"location":"evolution/#Performance","page":"Unitary evolution","title":"Performance","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The evolution macro avoids calculations where possible to improve performance. It is important to know how it achieves this result:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian matrix has not changed between two iterations and the time step remained approximately the same, mathcalU(t dt) will not be re-evaluated, because the matrix exponent is the most time-consuming operation compared to others like matrix multiplication or addition.\nThe relative tolerance used to check if the time step has changed can be set via rtol keyword.\nIf the hamiltonian expression does not explicitly depend on the loop variable (t in the example), it will be considered constant and evaluated only once at the beginning. Otherwise it will be evaluated on every iteration in the loop scope.\nIf several states evolve according to the same hamiltonian, both the hamiltonian and the mathcalU(t dt) evolution operator will be evaluated only once per iteration.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"To improve performance with small time intervals you can calculate the matrix exponent as a Taylor polynomial. Its order can be set via k keyword.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"For more precise calculation add pade=true - this will enable matrix exponent calculation via Padé approximant. Note that this formula requires finding an inverse matrix, so this option is not compatible with sparse matrices.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"By default the macro shows a progress informer that shows the task progress, the estimated time remaining and the fraction of time that was spent to perform evolution. To disable it add show_progress=false to the keyword arguments.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Keyword assignments should be placed before the rules list:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"@evolution k=2 rtol=1e-6 show_progress=false {...} for t in ...","category":"page"},{"location":"evolution/#Lattice-records","page":"Unitary evolution","title":"Lattice records","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"A LatticeRecord is a struct that stores information about how some value of storable type (only LatticeValue, LatticeArray or MaterializedCurrents are storable) changed during time. It simplifies working with time-dependent values by allowing you to run the computation pass only once and re-evaluate all visualization code as much as you want.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here is an example:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"P0 = filled_projector(spectrum(Chern(l, 0)))\ndensity_rec = LatticeValueRecord(l)\nderiv_rec = LatticeValueRecord(l)\n\n@evolution {\n    H := Chern(l, B * min(t, τ) / τ),\n    P0 --> H --> P\n} for t in 0:0.1:2τ\n    insert!(density_rec, t, site_density(P))\n    insert!(deriv_rec, t, site_density(-im * (H * P - P * H)))\nend\n\nsite = l[50]\np = plot(layout=(2,1))\nplot!(p[1], density_rec[site], lab=\"p\")\n\n# Compare computed time derivative with Heisenberg equation\nplot!(p[2], diff(density_rec)[site], lw=5, alpha=0.3, lab=\"dp/dt\")\nplot!(p[2], deriv_rec[site], lab=\"Heisenberg\") ","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Note that LatticeRecords support two kinds of indexing:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Calling the record with a numeric value selects the time and returns the object in nearest snapshot.  Calling it with two numeric values yields a new LatticeRecord with all timestamps between given values.\nIndexing it with square brackets will apply this index to all snapshots. The output will be a LatticeRecord if the results of the indexing will be storable; otherwise a time => value dictionary will be returned.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let's see how it works:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"p = plot(layout=(1,3), size=(800, 250))\nplot!(p[1], density_rec(10))                        # The snapshot with time nearest to 10\ntypeof(density_rec(10))                             # LatticeValue{Float64}\nplot!(p[2], density_rec[l[25]])                     # The value on the 25-th site depending on time \ntypeof(density_rec[l[25]])                          # Dict{Float64, Float64}\nplot!(p[3], (density_rec(15, 25) |> diff)[l[25]])   # Derivative of the value by time where 15 ≤ t ≤ 25","category":"page"},{"location":"lattice/#Simple-Bravais-lattice","page":"Defining a lattice","title":"Simple Bravais lattice","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The simplest variant of a finite Bravais lattice is a macro cell,  which is the lattice basis translated finite number of times along every translation vector.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"using LatticeModels, Plots, LinearAlgebra","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Constructing a macro cell is simple: the lattice constructor accepts positional arguments which will be translation ranges along all dimensions.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Note that lattices of some types can be of any dimensionality, while others can not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"julia> SquareLattice(10, 10)\n100-site square lattice on 10×10 macro cell\n\njulia> SquareLattice(3, 3, 3)\n27-site square lattice on 3×3×3 macro cell\n\njulia> HoneycombLattice(5, 5)\n50-site honeycomb lattice on 5×5 macro cell (2-site basis)\n\njulia> HoneycombLattice(3, 3, 2)\nERROR: MethodError: no method matching HoneycombLattice(::Int64, ::Int64, ::Int64)\n[...]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A lattice can be scatter-plotted to see how its sites are located and which index is assigned to each site:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"p = plot(size=(800, 350), layout=2)\nplot!(p[1], SquareLattice(10, 5))\nplot!(p[2], HoneycombLattice(8, 4))","category":"page"},{"location":"lattice/#axis_descriptors","page":"Defining a lattice","title":"Lattice sites and axis descriptors","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A LatticeSite is a struct describing where a site of some Bravais lattice is located:  it stores the location of the unit cell and the site's number in the lattice basis. No information about its spatial coordinates is stored explicitly, but it can be obtained by passing the corresponding Lattice and the site to the site_coords function.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Iterating over any Lattice will yield LatticeSites.  You can also get them by indexing the Lattice object with integers or coordinate keywords:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = SquareLattice(5, 5)\nsite1 = l[7]\nsite2 = l[x = 2, y = 2]\nsite1 == site2","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"These keywords are called axis descriptors. There are two types of them:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Coordinate axes are described by integers or symbols of form :x$i (where $i is the integer index of the axis). For indices 1-3 descriptors :x, :y and :z respectively are also allowed. Use these to select lattice sites by coordinate.\nLattice axes parallel to lattice translation vectors are described by symbols of form :j$i (where $i is the integer index of the axis). Use these to select lattice sites by unit cell index.\nA special basis index descriptor :index can be used to select sites by basis index.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Axis descriptors can also be used for selecting sites (or sublattices) by lattice indices. Take a look at the example:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = HoneycombLattice(5, 5)\nplot(l, leg=:bottomright)\nplot!(l[j1=2], pretty=false, lab=\"Select a unitcell row\")\nplot!(l[index=1], pretty=false, ms=10, alpha=0.3, lab=\"Select a Bravais sublattice\")","category":"page"},{"location":"lattice/#Sublattices","page":"Defining a lattice","title":"Sublattices","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Suppose we want to create a lattice with non-trivial geometry (for example, with holes).  This can be done by deleting some of the sites from the macro cell. There are three ways ways to do this:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Convenient way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = SquareLattice(10, 10)\n\nx, y = coord_values(l)\nl1 = l[@. x > 5 || y > 5]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Here we first create the macro cell, then find the coordinate values for its sites. After that we use LatticeValue broadcasting, see Lattice values for more detail.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"tip: Tip\nThis way to define sublattices is preferred, because code like this is the most readable. The x, y coordinate values will be also helpful to create other sublattices or slices.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Low-level way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l2 = sublattice(l) do site, (x, y); x > 5 || y > 5; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The lambda must accept a LatticeSite and a coordinate vector as positional arguments  and return whether the site should be included or not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The In-place way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l3 = SquareLattice(10, 10) do site, (x, y); x > 5 || y > 5; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"This notation is exactly the same as the low-level way, but done in one line.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warning: Warning\nThis notation should be used only if you need to access site indices or if the x, y coordinate values will not be needed further in the program.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The plot recipe for sublattices shows excluded sites with translucent markers by default and also prints out integer indices for all included sites. Pass keyword argument pretty=false to suppress this behavior.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = HoneycombLattice(6, 6)\nx, y = coord_values(l)\nplot(l[@. 7 < x * √3 + y < 18])","category":"page"},{"location":"lattice/#Custom-lattice-types","page":"Defining a lattice","title":"Custom lattice types","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"It is quite likely that you will need more types of lattices than this package provides by default. In such cases you need to define a new type. Follow these steps:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Create an exact alias","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Select a Symbol that will be the LatticeSym for this type and define an alias for the Lattice{LatticeSym, N, NB} type. The alias must not have any type parameters except for the dimension count if needed:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const HoneycombLattice = Lattice{:honeycomb, 2, 2}\nconst SquareLattice{N} = Lattice{:square, N, 1}","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Define the constructor","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The only positional arguments allowed are the macro cell size.[1] The Bravais object must be generated in the constructor and passed to the default constructor Lattice(sym, sz, bvs).","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"[1]: This is done with purpose to achieve code consistency. Also in-place sublattice generation will almost certainly be broken. Use keyword arguments if you need additional parameters for some lattice type.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Let us define our own lattice type:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const GrapheneLattice = Lattice{:graphene, 3, 2}\nfunction GrapheneLattice(sz::Vararg{Int, 3})\n    bvs = Bravais([1 1/2 0; 0 √3/2 0; 0 0 2], [0 1/2; 0 √3/6; 0 0])\n    Lattice(:graphene, sz, bvs)\nend\nnothing # hide","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A sublattice constructor will be generated by default:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"gl = GrapheneLattice(6, 6, 3) do site, (x, y, z)\n    7 < x * √3 + y < 18\nend\nplot(gl, pretty=false)","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warning: Warning\nPlease note that if the type alias is dimension-parametric, you must define the constructor for a concrete type, otherwise you will almost definitely break the lattice constructor dispatch:SquareLattice(sz::Vararg{Int, N}) where N = ...     # Wrong!\nSquareLattice{N}(sz::Vararg{Int, N}) where N = ...  # CorrectIn the second example SquareLattice(sz::Vararg{Int, N}) where N constructor will be generated automatically.","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/aryavorskiy/LatticeModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/aryavorskiy/LatticeModels.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Compat\nThis package has tested compatibility with Julia v1.6. Use with caution on lower versions.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry and any possible count of internal states on one sites.\nVersatile hamiltonian generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nSmart unitary evolution macro reducing excessive computations where possible.\nPlots.jl integration.","category":"page"},{"location":"#Usage-examples","page":"Home","title":"Usage examples","text":"","category":"section"},{"location":"#Local-density-for-lowest-states-in-a-tight-binding-model","page":"Home","title":"Local density for lowest states in a tight-binding model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The tight-binding model hamiltonian is defined by this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = sum_i^textsites left( c^dagger_i + hatx c_i + c^dagger_i + haty c_i + h c right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we will find its eigenstates and plot their local density on heatmaps.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing Plots\n# Generate a 40x40 square lattice\nl = SquareLattice(40, 40)\n# Define the tight-binding model hamiltonian\nH = TightBinding(l)\n\n# Calculate eigenvalues and eigenvectors\nsp = spectrum(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    E_rounded = round(eigvals(sp)[i], sigdigits=4)\n    plot!(p[i], site_density(sp[i]), title=\"\\$E_{$i} = $E_rounded\\$\", clims=clims, cbar=:none)\nend\n\n# The following 2 lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, background_subplot=:transparent, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), subplot=n^2+2)","category":"page"},{"location":"#Currents-in-a-tight-binding-model-on-a-ring-shaped-sample","page":"Home","title":"Currents in a tight-binding model on a ring-shaped sample","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this example we delete part of the sites in the middle of a square lattice.  Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The tight-binding hamiltonian is the same as in the example above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing Plots\n\nl = SquareLattice(10, 10) do site, (x, y)\n    !(4 < x < 7 && 4 < y < 7)\nend\nh(B) = TightBinding(l, field=FluxField(B))\nsp = spectrum(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = filled_projector(sp)\n# Perform unitary evolution\nτ = 10\na = Animation()\n@evolution {\n    H := h(0.1 * min(t, τ) / τ)\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    # Find the partial trace and plot it\n    plot(site_density(P), clims=(0,1))\n\n    # Show currents on the plot\n    plot!(DensityCurrents(H, P), arrows_scale=7, arrows_rtol=0.1)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"#Local-Chern-marker-with-hamiltonian-quench","page":"Home","title":"Local Chern marker with hamiltonian quench","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Chern insulator hamiltonian is described by this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = \nsum_i^textsites m_i c^dagger_i sigma_z c_i + \nsum_i^textsites left( \nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + \nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i + \nh c right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this experiment we create a filled state density matrix for a system with m_i = 1.  After that we change the m_i in the center of the lattice to -1 and start the evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing Plots\n\nl = SquareLattice(11, 11)\nx, y = coord_values(l)\n\n# Initial hamiltonian: m=1 everywhere\nH1 = SpinTightBinding(ones(l))\n\n# Quenched hamiltonian: m=-1 in the central 3x3 square\nM = ones(l)\nM[@. 4 < x < 8 && 4 < y < 8] .= -1\nH2 = SpinTightBinding(M)\nX, Y = coord_operators(l, 2)\n\nsp = spectrum(H1)\nP_0 = filled_projector(sp)\n\nτ = 10\na = Animation()\n@evolution {\n    H := H2\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    p = plot(layout=2, size=(900, 400))\n\n    # Local Chern marker heatmap\n    lcm_operator = 4pi * im * P * X * P * Y * P\n    chern_marker = site_density(lcm_operator)\n    plot!(p[1], chern_marker, clims=(-2, 2))\n\n    # Select sites on y=6 line\n    chern_marker_on_sw = chern_marker[y = 6]\n    # Mark selected sites on the heatmap\n    plot!(p[1], lattice(chern_marker_on_sw), high_contrast=true)\n    # Add a line plot\n    plot!(p[2], project(chern_marker_on_sw, :x), ylims=(-3, 3), lab=:none)\n\n    plot!(plot_title=\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"#LDOS-animation","page":"Home","title":"LDOS animation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Local density can be a bit ambiguous for degenerate eigenstates. That's where the LDOS (Refer to ldos documentation) will be helpful.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's take the same hamiltonian from the previous example and create a LDOS animation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing Plots\nl = SquareLattice(40, 40)\nH = SpinTightBinding(ones(l))\n\nsp = spectrum(H)\nδ = 0.1\nEs = -4:0.1:4\nEs_d = -4:0.01:4\nldosf = ldos(sp, δ)\na = @animate for E in Es\n    print(\"\\rE = $E\") # hide\n    p = plot(layout=2, size=(800, 400))\n    plot!(p[1], Es_d, dos(sp, δ), lab=\"\", title=\"DOS\")\n    vline!(p[1], [E], lab=\"\")\n    plot!(p[2], ldosf(E), clims=(0, NaN), title=\"LDOS\")\n    plot!(p, plot_title=\"E = $E, δ = $δ\")\nend\n\ngif(a, \"animation.gif\", fps=10)","category":"page"},{"location":"lattice_arrays/#Lattice-arrays","page":"Lattice arrays","title":"Lattice arrays","text":"","category":"section"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"using LatticeModels","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"A LatticeArray is a wrapper type that maps an array representing an operator matrix or a wave function vector to a basis it is defined on.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"A Basis, in turn, is generally a pair of a Lattice and an Int which is the number of internal states on every lattice site. In future releases, however, this definition may be extended to a more complex combination of states of several particles.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"Constructing a LatticeArray is simple. Note that an array size check will be performed automatically:","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"l = SquareLattice(3, 2)\nlarr = LatticeArray(Basis(l, 1), [1, 2, 3, 4, 5])       # Error\nlarr = LatticeArray(Basis(l, 1), [1, 2, 3, 4, 5, 6])    # LatticeVector constructed\nlarr.array                  # Access the array object wrapped by the LatticeArray","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"You can create LatticeArray representations of coordinate operators by using the coord_operators function. ","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"l = SquareLattice(5, 5)\nbas = Basis(l, 2)\nX, Y = coord_operators(bas) # Same as coord_operators(l, 2)","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"You can use arithmetic operators with LatticeArrays freely: after checking that the bases match they will be applied to the contained arrays, and the result will be wrapped into a new LatticeArray.  However, if you want to apply some other array operations (like exp), you can use the @on_lattice macro which will wrap the call as needed.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"julia> X, Y = coord_operators(SquareLattice(5, 5), 2);\n\njulia> X * sin(Y)\nERROR: MethodError: no method matching sin\n\njulia> @on_lattice X * sin(Y)\n50×50 LatticeOperator with inner type Matrix{Float64}\non Basis with 2-dimensional internal phase space\non 25-site square lattice on 5×5 macro cell","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"warning: Warning\nPlease be careful when defining new functions using the @on_lattice macro. Type-pirating methods will lead to a stack overflow error once called.*(a::Union{LatticeArray, Number}...) = @on_lattice *(a...)This definition is likely to overwrite the *(n::Number...) builtin, which will lead to an endless recursion if *(2, 3) is called.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"In the next few paragraphs we will review two main ways to define linear operators that form most tight-binding hamiltonians.","category":"page"},{"location":"lattice_arrays/#Diagonal-operators","page":"Lattice arrays","title":"Diagonal operators","text":"","category":"section"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"A lattice-diagonal operator can be represented as  hatA = sum_i^textsites hats_i hatc^dagger_i hatc_i , where hats_i is an operator defined on the internal space and hatc^dagger_i hatc_i are standard quantization operators.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"Such an operator can be defined generally in two ways: ","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"As a tensor product","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"The hatB operator, being diagonal in the site basis, can easily be represented as a LatticeValue, while the hatC operator can be defined by a matrix.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"l = HoneycombLattice(5, 5);\nx, y = coord_values(l);\nX, Y = coord_operators(l, 2);\nop = (@. x + y) ⊗ [1 0; 0 1]\nX + Y == op","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"As a function call","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"The diag_operator function is a low-level way to create a site-diagonal LatticeOperator.  It accepts two arguments: one is a Lattice or a Basis, and the other is a function that can be written in the do-syntax same way as before - it must return a matrix which will affect the internal degrees of freedom on the site.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"There are more possible ways to use this function, refer to diag_operator docstrings to find out more.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"op1 = diag_operator(l) do site, (x, y)\n    (x + y) * [1 0; 0 1]\nend\nop2 = diag_operator(Basis(l, 2), x .+ y)\nX + Y == op1 == op2","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"Note that you can appply a function to every lattice-diagonal block of the operator matrix to create a LatticeValue with the diag_reduce function.  For example, you can find a partial trace like this:","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"using LinearAlgebra\nlv = diag_reduce(tr, op) # same as site_density(op)\nlv == 2 .* x","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"site_density function is also applicable to wave functions represented as LatticeVectors.","category":"page"},{"location":"lattice_arrays/#Hopping-operators","page":"Lattice arrays","title":"Hopping operators","text":"","category":"section"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"A hopping operator is described by the following formula:","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"hatA = sum_textadjacent (i j) hath hatc^dagger_j hatc_i + h c","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"The Hopping struct is a lazy representation of such an operator: it stores a matrix of the hath operator  and information about which sites should be considered adjacent.  The relative location of the connected sites is defined by their respective indices in the lattice basis  and the relative location of their unit cells as translations along lattice axes (represented as an integer vector).","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"A Hopping object can be created with the hopping function. Its only positional argument is  the hath operator matrix and keyword arguments site_indices and translate_uc. ","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"l = HoneycombLattice(5, 5)\nhop1 = hopping(site_indices=(2, 1), translate_uc=[1, 0])","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"If the unit-cell translation is a single move along some lattice axis, you can instead set the axis keyword to the number of the translation axis.  If there is no unit cell translation between the two sites, this argument can be omitted.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"hop2 = hopping(site_indices=(2, 1), axis=2) # same as translate_uc=[0, 1]\nhop3 = hopping(site_indices=(2, 1))","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"Note that no operator matrix argument was passed in the example above, which means that it was set to a 1×1 eye matrix automatically.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"To generate a LatticeOperator, invoke the hopping_operator function with a Lattice and a Hopping:","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"hop_op = hopping_operator(l, hop1) + \n         hopping_operator(l, hop2) + \n         hopping_operator(l, hop3)","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"The bonds defined by the operator can be displayed on a plot in the following way:","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"bs = bonds(hop_op)\n\nusing Plots\nplot(bs)\nplot!(l, pretty=false)","category":"page"},{"location":"lattice_arrays/#Pair-selectors","page":"Lattice arrays","title":"Pair selectors","text":"","category":"section"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"You can remove some of the hoppings by using a pair selector: a pair selector is a lambda-like object which accepts a Lattice and two LatticeSites to return whether the site pair is selected or not. Passing such an object to the hopping_operator function as the first argument will remove the hoppings connecting non-selected pairs.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"You can always write any lambda that accepts a Lattice and two LatticeSites with similar aim to achieve similar results - but it's safer to use the PairSelector API, because this allows to define a selector for a greater lattice and use it for all sublattices safely.","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"For example, let's consider we want to split the lattice into two domains which are not connected to each other. In such case we must firstly generate a LatticeValue defining which site corresponds to which domain:","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"domains = @. abs(x) < 1 && abs(y) < 1 # A 2x2 square in the center of the lattice\nselector = DomainsSelector(domains)\nhop_op2 = hopping_operator(selector, l, hop1) + \n          hopping_operator(selector, l, hop2) + \n          hopping_operator(selector, l, hop3)\n\nplot(bonds(hop_op2))\nplot!(domains, cbar=false)","category":"page"},{"location":"lattice_arrays/","page":"Lattice arrays","title":"Lattice arrays","text":"See also DomainsSelector, PairLhsSelector, PairLhsSelector.","category":"page"},{"location":"lattice_values/#LatticeValue-basics","page":"Lattice values","title":"LatticeValue basics","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"A LatticeValue is a struct that maps sites of a certain Lattice to values of some type.  One can be generated using a do-syntax similar to one in Sublattices:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"using LatticeModels, Plots","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"l = SquareLattice(10, 10)\nlv = LatticeValue(l) do site, (x, y); x + y + 1; end    # arbitrary site-dependent\nlv2 = rand(l)                               # uniformly distributed random numbers\nlv3 = randn(l)                              # normally distributed random numbers\nlv4 = ones(l)                               # 1 on all sites. Also zeros(l) is possible","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"To generate a tuple of LatticeValues for site coordinates, you can use the coord_values function. Note that LatticeValues support broadcasting, which means you can create coordinate-dependent lattice values in-place:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"x, y = coord_values(l)\nlv == x .+ y .+ 1","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"note: Note\nA wave function cannot and must not be stored as a LatticeValue, use LatticeVector instead.  The reason is that a LatticeValue does not take one-site phase spaces into account, which renders them unusable for these purposes.Linear algebra operations and @on_lattice wrapping are deliberately unsupported for LatticeValues.","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Lattice values implement a scatter plot recipe, which colors the plot markers according to the value:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"scatter(lv, markersize=10)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Depending on the lattice type, additional plot recipes can be available. For example, a lattice value on a square lattice can be plotted as a heatmap (which will be enabled by default if you do not specify the series type):","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"plot(lv, markersize=10)","category":"page"},{"location":"lattice_values/#Indexing","page":"Lattice values","title":"Indexing","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"It is often required to select some sites by certain condition.  This can be done using a LatticeValue{Bool} and broadcasting (like with Sublattices).","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"In the example below we will delete all sites from the circle of radius 3 in the center of the lattice  (which will make the according heatmap regions blank).","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"heatmap(lv[@. √(x^2 + y^2) ≥ 10])","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"The approach from above provides a flexible way to edit LatticeValues:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"lv2 = ones(l)\nlv2[@. x < y] = x .* y          # Assign another LatticeValue\nlv2[@. x ≥ y && x ≥ -y] .= 20   # or a number\nheatmap(lv2)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that a LatticeValue can be projected to some coordinate axis to create line plots. The projection axis is set by an axis descriptor (see Axis descriptors)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"lv_on_line = lv[x = 5]\np = plot(layout=(2, 1))\n\nheatmap!(p[1], lv)\nplot!(p[1], lattice(lv_on_line), high_contrast=true)\nplot!(p[2], project(lv_on_line, :y))","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that we can show the sites we selected by plotting the lattice of the selected values with high_contrast=true. This options hides the indices and translucent marks, and also makes the plot markers black-and-white, which prevents them from blending in with the heatmap in the background.","category":"page"}]
}

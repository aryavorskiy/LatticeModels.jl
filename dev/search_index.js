var documenterSearchIndex = {"docs":
[{"location":"currents/","page":"Currents","title":"Currents","text":"TODO","category":"page"},{"location":"library/#LatticeModels.jl","page":"Library","title":"LatticeModels.jl","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-creation","page":"Library","title":"Lattice creation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice.jl\"]","category":"page"},{"location":"library/#LatticeModels.Bravais","page":"Library","title":"LatticeModels.Bravais","text":"Bravais{N, NB}\n\nN-dimensional infinite Bravais lattice with NB sites in basis.\n\n\n\nBravais(translation_vectors[, basis])\n\nConstructs a Bravais lattice with given translation vectors and locations of basis sites relative to some unit cell. The basis argument can be omitted, in which case the lattice basis will consist of one site located in the bottom-left corner of the unit cell.\n\ntranslation_vectors argument must be an AbstractMatrix{<:Real} of size N×N, while basis must also be an  abstract matrix of size N×NB.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nType alias for Lattice{:honeycomb,2,2}.\n\n\n\nHoneycombLattice(sz::Vararg{Int, 2})\n\nConstructs a honeycomb lattice with a sz-size macro cell.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Lattice","page":"Library","title":"LatticeModels.Lattice","text":"Lattice{LatticeSym, N, NB}\n\nA finite subset of a Brvais{N, NB}. LatticeSym is a Symbol which represents the type of the lattice (e. g. :square, :honeycomb). This makes Lattice object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.\n\n\n\nLattice(sym, sz, bvs[, mask])\n\nConstructs a finite Lattice{sym, N, NB} as a subset of the bvs Bravais lattice. sz is a NTuple{N, Int} which represents how many times the unit cell of bvs was translated by each axis - these sites form a macro cell. mask, if defined, is a Vector{Bool} storing information about which of the sites from the macro cell are actually included in the lattice, and which are not.\n\nFor example, a 3×3 square lattice with its center site excluded is represented as Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])\n\nTo define a new type of lattice, create an alias for Lattice{YourSym, YourN, YourNB}. Refer to the docs for detailed explanation.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeSite","page":"Library","title":"LatticeModels.LatticeSite","text":"LatticeSite{N}\n\nA site of a Lattice{LatticeSym, N, NB} lattice.\n\nFields:\n\nunit_cell: a set of translations along all axes representing the unit cell the site is located in.\nbasis_index: the number of site in the lattice basis.\n\nThis type is used to iterate over all sites of a Lattice{LatticeSym, N, NB}. The exact location of a LatticeSite can be found using the coords(lattice, site) function.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nType alias for Lattice{:square,N,1}.\n\n\n\nSquareLattice(sz::Int...)\n\nConstructs a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coords-Tuple{Lattice, LatticeSite}","page":"Library","title":"LatticeModels.coords","text":"coords(lattice::Lattice, site::LatticeSite) -> vector\n\nFinds the location in space of lattice site site on lattice lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.radius_vector-Tuple{Lattice, LatticeSite, LatticeSite}","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(lattice::Lattice, site1::LatticeSite, site2::LatticeSite) -> vector\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macro cell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym","page":"Library","title":"LatticeModels.sublattice","text":"sublattice(lf::Function, l::Lattice) -> Lattice\n\nGenerates a a subset of lattice l by applying the lf function to its sites. The lf function must accept two positional arguments (a LatticeSite and a vector with its coordinates) and return a boolean value.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-values","page":"Library","title":"Lattice values","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_value.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LatticeSym}\n\nRepresents a value of type T on a Lattice{LatticeSym} lattice.\n\nFields:\n\nlattice: the Lattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coord_values-Tuple{Lattice}","page":"Library","title":"LatticeModels.coord_values","text":"coord_values(lattice::Lattice)\n\nGenerates a tuple of LatticeValues representing coordinate functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.plot_fallback-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.plot_fallback","text":"plot_fallback(lv::LatticeValue)\n\nCreates a copy of lv lattice value with its LatticeSym overwritten to :uncertain. Use it to invoke the default plot recipe for LatticeValues when defining a custom one.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-operators","page":"Library","title":"Lattice operators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_operator.jl\"]","category":"page"},{"location":"library/#LatticeModels.Basis","page":"Library","title":"LatticeModels.Basis","text":"Basis{LT} where {LT<:Lattice}\n\nA basis on a lattice with some number of internal states on each site. Fields:\n\nlattice: the Lattice of the basis\ninternal_dim: the number of internal states on each site\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeArray","page":"Library","title":"LatticeModels.LatticeArray","text":"LatticeArray{LT, MT} where {LT<:Lattice, MT<:AbstractArray}\n\nA wrapper object for array representing a wave function or linear operator. Stores information about its basis to perform lattice checks.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeOperator-Tuple{LinearAlgebra.UniformScaling, Basis}","page":"Library","title":"LatticeModels.LatticeOperator","text":"LatticeOperator{LT, MT}\n\nThe same as LatticeArray{LT, MT} where MT<:AbstractMatrix.\n\n\n\nLatticeOperator(uniform_scaling, basis)\n\nCreates a LatticeOperator representation of a UniformScaling operator on given basis.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TensorProduct","page":"Library","title":"LatticeModels.TensorProduct","text":"TensorProduct{LVT, MT} where {LVT<:LatticeValue{<:Number}, MT<:AbstractMatrix}\n\nA lazy representation of an operator as a tensor product of two distinct phase spaces. One affects only the internal space, the other - only the lattice space.\n\nThe lattice_value ⊗ matrix notation computes the value of the TensorProduct eagerly, which means that the result will be a LatticeOperator. However, in the @hamiltonian macro lazy computation is forced.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coord_operators-Tuple{Basis}","page":"Library","title":"LatticeModels.coord_operators","text":"coord_operators(basis)\n\nReturns a Tuple of coordinate LatticeOperators for given basis.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coord_operators-Tuple{Lattice, Int64}","page":"Library","title":"LatticeModels.coord_operators","text":"coord_operators(lattice, ndims)\n\nThe same as coord_operators(Basis(lattice, ndims)).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_aggregate-Tuple{Function, LatticeModels.LatticeArray}","page":"Library","title":"LatticeModels.diag_aggregate","text":"diag_aggregate(function, lattice_operator)\n\nCreates a LatticeValue where a site maps to the result of function on the matrix of the operator narrowed to that site.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Basis, LatticeValue{<:Number}}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(basis, lattice_value)\n\nCreates a diagonal operator which affects only the lattice space. The lattice_value argument must be a LatticeValue storing diagonal elements of the operator in lattice space.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Function, Basis}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(site_fun, basis)\n\nCreates a diagonal operator which affects only the lattice space. The site_fun function must accept a LatticeSite and its coordinates and return a number which will be the diagonal element of the operator in lattice space.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Function, Lattice}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(site_fun, lattice)\n\nCreates a diagonal operator by applying the site_fun function to each site of lattice. The site_fun function must accept a LatticeSite and its coordinates and return a matrix which will be an operator affecting the internal state of the site.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Lattice, AbstractMatrix}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(lattice, matrix)\n\nCreates a diagonal operator which affects only the internal state the same way on every site. matrix is an AbstractMatrix representing the linear operator on the internal space.\n\nNote that the matrix of the output LatticeOperator will be similar to matrix: for instance, if matrix is sparse, so will be the output.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@on_lattice-Tuple{Any}","page":"Library","title":"LatticeModels.@on_lattice","text":"@on_lattice\n\nReplaces all LatticeArrays in subsequent function calls with actual arrays stored inside them. Throws an error if lattice operators in one function call are defined on different lattices, shows a warning if a lattice array is used in one call with a normal array.\n\nExample\n\nl = SquareLattice(10, 10)\nbas = Basis(l, 2)\nX, Y = coord_operators(bas)\nxexpypy = diag_operator(bas) do site, (x, y)\n    x * exp(y) + y\nend\nxexpy == @on_lattice X * exp(Y) + Y     # true\n\n\n\n\n\n","category":"macro"},{"location":"library/#Hoppings","page":"Library","title":"Hoppings","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hoppings.jl\"]","category":"page"},{"location":"library/#Magnetic-fields","page":"Library","title":"Magnetic fields","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"field.jl\"]","category":"page"},{"location":"library/#Hamiltonian-tools","page":"Library","title":"Hamiltonian tools","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hamiltonian.jl\"]","category":"page"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"currents.jl\"]","category":"page"},{"location":"library/#Unitary-evolution","page":"Library","title":"Unitary evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"evolution.jl\"]","category":"page"},{"location":"library/#LatticeModels.evolution_operator-Tuple{Any, Real}","page":"Library","title":"LatticeModels.evolution_operator","text":"evolution_operator(H, t[, k])\n\nCalculates the unitary evolution operator using the formula\n\n$ \\mathcal{U}(t) = e^{-\\frac{1}{i\\hbar} \\hat{H} t} $\n\nArguments\n\nH: the hamiltonian matrix\nt: the evolution time\nk: if provided, the exponent will be calculated using a Taylor series expansion with order k\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@evolution-Tuple","page":"Library","title":"LatticeModels.@evolution","text":"@evolution [kwargs...] {rules...} for_loop\n\nGenerates an environment with defined hamiltonian and density matrices that evolve by certain laws. See Unitary evolution for more details.\n\n\n\n\n\n","category":"macro"},{"location":"hamiltonian/#Lattice-operators","page":"Hamiltonian generation","title":"Lattice operators","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"TODO","category":"page"},{"location":"hamiltonian/#Diagonal-operators","page":"Hamiltonian generation","title":"Diagonal operators","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"TODO","category":"page"},{"location":"hamiltonian/#Hopping-operators","page":"Hamiltonian generation","title":"Hopping operators","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"TODO","category":"page"},{"location":"hamiltonian/#Hamiltonian-macro","page":"Hamiltonian generation","title":"Hamiltonian macro","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"TODO","category":"page"},{"location":"plot/","page":"Visualization","title":"Visualization","text":"TODO","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"TODO","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"TODO","category":"page"},{"location":"lattice/#Simple-Bravais-lattice","page":"Defining a lattice","title":"Simple Bravais lattice","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The simplest variant of a finite Bravais lattice is a macro cell,  which is the lattice basis translated finite number of times along every translation vector.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"using LatticeModels, Plots, LinearAlgebra","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Constructing a macro cell is simple: the lattice constructor accepts positional arguments which will be translation ranges along all dimensions.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Note that lattices of some types can be of any dimensionality, while others can not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"julia> SquareLattice(10, 10)\n100-site square lattice on 10×10 base\n\njulia> SquareLattice(3, 3, 3)\n27-site square lattice on 3×3×3 base\n\njulia> HoneycombLattice(5, 5)\n50-site honeycomb lattice on 5×5 base (2-site basis)\n\njulia> HoneycombLattice(3, 3, 2)\nERROR: MethodError: no method matching HoneycombLattice(::Int64, ::Int64, ::Int64)\n[...]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A lattice can be scatter-plotted to see how its sites are located.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"p = plot(size=(800, 350), layout=2)\nplot!(p[1], SquareLattice(10, 5))\nplot!(p[2], HoneycombLattice(8, 4))","category":"page"},{"location":"lattice/#Sublattices","page":"Defining a lattice","title":"Sublattices","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Suppose we want to create a lattice with non-trivial geometry (for example, with holes).  This can be done by deleting some of the sites from the macro cell. There are three ways ways to do this:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Convenient way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = SquareLattice(10, 10)\n\nx, y = coord_values(l)\nl1 = l[@. abs(x) > 3 || abs(y) > 3]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Here we first create the macro cell, then find the coordinate values for its sites. After that we use LatticeValue broadcasting - see Lattice values for more detail.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"tip: Tip\nThis way to define sublattices is preferred, because code like this is the most readable. The x, y coordinate values will be also helpful to create other sublattices or slices.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Low-level way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l2 = sublattice(l) do site, (x, y); abs(x) > 3 || abs(y) > 3; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The lambda must accept a LatticeSite and a coordinate vector as positional arguments  and return whether the site should be included or not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The In-place way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l3 = SquareLattice(10, 10) do site, (x, y); abs(x) > 3 || abs(y) > 3; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"This notation is exactly the same as the low-level way, but done in one line.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warning: Warning\nThis notation should be used only if you need to access site indices or if the x, y coordinate values will not be needed further in the program.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The plot recipe for sublattices shows excluded sites with translucent markers by default. Passing keyword argument show_excluded_sites=false disables this.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = HoneycombLattice(6, 6)\nx, y = coord_values(l)\nplot(l[@. -5 < x * √3 + y < 5.5])","category":"page"},{"location":"lattice/#Custom-lattice-types","page":"Defining a lattice","title":"Custom lattice types","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"It is quite likely that you will need more types of lattices than this package provides by default. In such cases you need to define a new type. Follow these steps:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Create an exact alias","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Select a Symbol that will be the LatticeSym for this type and define an alias for the Lattice{LatticeSym, N, NB} type. The alias must not have any type parameters except for the dimension count if needed:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const HoneycombLattice = Lattice{:honeycomb, 2, 2}\nconst SquareLattice{N} = Lattice{:square, N, 1}","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Define the constructor","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The only positional arguments allowed are the macro cell size.[1] The Bravais object must be generated in the constructor and passed to the default constructor Lattice(sym, sz, bvs).","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"[1]: This is done with purpose to achieve code consistency. Also in-place sublattice generation will almost certainly be broken. Use keyword arguments if you need additional parameters for some lattice type.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Let us define our own lattice type:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const GrapheneLattice = Lattice{:graphene, 3, 2}\nfunction GrapheneLattice(sz::Vararg{Int, 3})\n    bvs = Bravais([1 1/2 0; 0 √3/2 0; 0 0 2], [0 1/2; 0 √3/6; 0 0])\n    Lattice(:graphene, sz, bvs)\nend","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A sublattice constructor will be generated by default:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"gl = GrapheneLattice(6, 6, 3) do site, (x, y, z)\n    -5 < x * √3 + y < 5.5\nend\nplot(gl, show_excluded_sites=false)","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warning: Warning\nPlease note that if the type alias is dimension-parametric, you must define the constructor for a concrete type:SquareLattice(sz::Vararg{Int, N}) where N = ...     # Wrong!\nSquareLattice{N}(sz::Vararg{Int, N}) where N = ...  # Correct","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry and any possible count of internal states on one sites.\nVersatile hamiltonian generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nSmart unitary evolution macro reducing excessive computations where possible.\nPlots.jl integration.","category":"page"},{"location":"#Usage-examples","page":"Home","title":"Usage examples","text":"","category":"section"},{"location":"#Currents-in-Hofstadter-model-on-a-ring-shaped-sample","page":"Home","title":"Currents in Hofstadter model on a ring-shaped sample","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this example we delete part of the sites in the middle of a square lattice.  Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Hofstadter model hamiltonian is evaluated according to this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = sum_textx-links c^dagger_i c_j + sum_texty-links c^dagger_i c_j + h c","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing LinearAlgebra, Plots\n\nl = SquareLattice(10, 10) do site, (x, y)\n    abs(x) > 1 || abs(y) > 1\nend\n\n# Define a Hofstadter model hamiltonian\nh(B) = @hamiltonian begin   \n    lattice := l\n    # Add hoppings along axis x and y\n    @hop axis = 1\n    @hop axis = 2\n    # Add magnetic field through (0, 0) point\n    field := FluxField(B, (0, 0))\nend\n\n# Calculate eigenvalues and eigenvectors\nsp = spectrum(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = filled_projector(sp)\n# Perform unitary evolution\nτ = 10\na = Animation()\n@evolution {\n    H := h(0.1 * min(t, τ) / τ)\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    # Find the partial trace and plot it\n    density = diag_aggregate(m -> real(tr(m)), P)\n    heatmap(density, clims=(0,1))\n\n    # Show currents on the plot\n    plot!(DensityCurrents(H, P), arrows_scale=7, arrows_rtol=0.1)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"#Local-Chern-marker-with-hamiltonian-quench","page":"Home","title":"Local Chern marker with hamiltonian quench","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Chern insulator hamiltonian is described by this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = \nsum_i m_i c^dagger_i sigma_z c_i + left(\nsum_textx-links c^dagger_i fracsigma_z - i sigma_x2 c_j + \nsum_texty-links c^dagger_i fracsigma_z - i sigma_y2 c_j + \nh c right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this experiment we create a filled state density matrix for a system with m_i = 1.  After that we change the m_i in the center of the lattice to -1 and start the evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing LinearAlgebra, Plots\n\nl = SquareLattice(11, 11)\nx, y = coord_values(l)\n\n# The Pauli matrices\nσ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\n\n# Initial hamiltonian: m=1 everywhere\nH1 = @hamiltonian begin   \n    lattice := l\n    @diag σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\n\n# Quenched hamiltonian: m=-1 in the central 3x3 square\nM = @. (abs(x) < 1.5 && abs(y) < 1.5) * -2 + 1\nH2 = @hamiltonian begin\n    lattice := l\n    @diag M ⊗ σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\nX, Y = coord_operators(l, 2)\n\nsp = spectrum(H1)\nP_0 = filled_projector(sp)\n\nτ = 10\na = Animation()\n@evolution {\n    H := H2\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    p = plot(layout=2, size=(900, 500))\n\n    # Local Chern marker heatmap\n    lcm_operator = 4pi * im * P * X * P * Y * P\n    chern_marker = diag_aggregate(tr, lcm_operator) .|> real\n    heatmap!(p[1], chern_marker, clims=(-2, 2))\n\n    # Select sites on y=0 line (use ≈ to avoid rounding errors)\n    chern_marker_on_sw = chern_marker[@. y ≈ 0]\n    # Mark selected sites on the heatmap\n    plot!(p[1], lattice(chern_marker_on_sw), high_contrast=true)\n    # Add a line plot\n    plot!(p[2], chern_marker_on_sw, project_axis=:x, ylims=(-3, 3), lab=:none)\n\n    plot!(plot_title=\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"lattice_values/#LatticeValue-basics","page":"Lattice values","title":"LatticeValue basics","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"A LatticeValue is a struct that maps sites of a certain Lattice to values of some type.  One can be generated using a do-syntax similar to one in Sublattices:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"using LatticeModels, Plots","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"l = SquareLattice(5, 5)\nlv = LatticeValue(l) do site, (x, y); x + y + 1; end","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"To generate LatticeValues for site coordinates, you can use the coord_values function. Note that LatticeValues support broadcasting, which means you can create coordinate-dependent lattice values in-place:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"x, y = coord_values(l)\nlv == x .+ y .+ 1","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Lattice values implement a scatter plot recipe, which colors the plot markers according to the value:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"plot(lv, markersize=20)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"note: Note\nA wave function cannot and must not be stored as a LatticeValue - use LatticeVector instead.  The reason is that a LatticeValues does not take one-site phase spaces into account.","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Depending on the lattice type, additional plot recipes can be available. For example, a lattice value on a square lattice can be plotted as a heatmap:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"heatmap(lv)","category":"page"},{"location":"lattice_values/#Indexing","page":"Lattice values","title":"Indexing","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"It is often required to select some sites by certain condition.  This can be done using a LatticeValue{Bool} and broadcasting (like with Sublattices).","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"heatmap(lv[@. √(x^2 + y^2) > 1.2])","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that a LatticeValue can be projected to some coordinate axis to create line plots.","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"lv_on_line = lv[@. x ≈ 0]   # Use approximate comparison to avoid rounding errors\np = plot(layout=(2, 1))\n\nheatmap!(p[1], lv)\nplot!(p[1], lattice(lv_on_line), high_contrast=true)\nplot!(p[2], lv_on_line, project_axis=:y)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that we can show the sites we selected by plotting the lattice of the selected values with high_contrast=true. This options make the plot markers black-and-white, which prevents them from blending in with the heatmap in the background.","category":"page"}]
}

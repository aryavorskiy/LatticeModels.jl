var documenterSearchIndex = {"docs":
[{"location":"currents/#Usage","page":"Currents","title":"Usage","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"A AbstractCurrents object is a lazy object that can calculate any current-like value between any pair of sites.  Usage is pretty simple:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"using LatticeModels, Plots","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"l = SquareLattice(10, 10)\nH = @hamiltonian begin   \n    lattice := l\n    @hop axis = 1\n    @hop axis = 2\n    field := FluxField(1, (0, 0))\nend\nP = filled_projector(spectrum(H), -0.5)\n\ncurr = DensityCurrents(H, P)                    # Create Currents object\nheatmap(ptrace(P) .|> real)\nplot!(curr, arrows_scale=5, arrows_rtol=0.1, color=:blue)    # Quiver-plot the currents","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"What happened here? The formula for the density current from site i to site j is J_ij = texttr(-i hath_ij hatc^dagger_i hatc_j hatrho + h c) = 2 textIm tr(hath_ij hatc^dagger_i hatc_j hatrho).  The curr object contains this formula inside - and when this object is passed to the plot function, all needed currents are evaluated.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"A current between each pair of sites is shown as an arrow directed from one to another with its length proportional to the strength of the current. The arrows_scale keyword argument scales all arrows by given factor, while arrows_rtol hides all arrows that are shorter than some fraction of the distance between the sites.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"You can display currents between certain sites by using a boolean-typed LatticeValue and bracket-notation:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"x, y = coord_values(l)\nsub_curr = curr[x .< y]\nplot!(sub_curr, color=:green)","category":"page"},{"location":"currents/#Interface","page":"Currents","title":"Interface","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"It is quite likely that you might want to define your own type of currents. All you need to do is inherit the AbstractCurrents type and define two functions:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"lattice(::MyCurrents) must return the lattice which the currents are defined on\ncurrents_lambda(::MyCurrents) must return a lambda which takes two integer site indices and returns the current between these two sites. Note that the function must be skew-symmetric, e. g. curr_lambda(i, j) == -curr_lambda(j, i)","category":"page"},{"location":"currents/#Materialized-currents","page":"Currents","title":"Materialized currents","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents is a lazy object - this allows to avoid excessive computation, but the computations that are needed will be repeated every time when we use the object. That's where the MaterializedCurrents come in, having all their values stored explicitly in an array.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"To convert any type of currents to MaterializedCurrents, simply use the materialize function. You can avoid evaluating some currents (for example, if you know beforehand that they must be zero) by passing a lambda as a first argument (or with do-syntax): it must take the Lattice and two LatticeSites and return whether the current between these sites must be evaluated.","category":"page"},{"location":"library/#LatticeModels.jl","page":"Library","title":"LatticeModels.jl","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-creation","page":"Library","title":"Lattice creation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice.jl\"]","category":"page"},{"location":"library/#LatticeModels.Bravais","page":"Library","title":"LatticeModels.Bravais","text":"Bravais{N, NB}\n\nN-dimensional infinite Bravais lattice with NB sites in basis.\n\n\n\nBravais(translation_vectors[, basis])\n\nConstructs a Bravais lattice with given translation vectors and locations of basis sites relative to some unit cell. The basis argument can be omitted, in which case the lattice basis will consist of one site located in the bottom-left corner of the unit cell.\n\ntranslation_vectors argument must be an AbstractMatrix{<:Real} of size N×N, while basis must also be an  abstract matrix of size N×NB.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nType alias for Lattice{:honeycomb,2,2}.\n\n\n\nHoneycombLattice(sz::Vararg{Int, 2})\n\nConstructs a honeycomb lattice with a sz-size macro cell.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Lattice","page":"Library","title":"LatticeModels.Lattice","text":"Lattice{LatticeSym, N, NB}\n\nA finite subset of a Brvais{N, NB}. LatticeSym is a Symbol which represents the type of the lattice (e. g. :square, :honeycomb). This makes Lattice object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.\n\n\n\nLattice(sym, sz, bvs[, mask])\n\nConstructs a finite Lattice{sym, N, NB} as a subset of the bvs Bravais lattice. sz is a NTuple{N, Int} which represents how many times the unit cell of bvs was translated by each axis - these sites form a macro cell. mask, if defined, is a Vector{Bool} storing information about which of the sites from the macro cell are actually included in the lattice, and which are not.\n\nFor example, a 3×3 square lattice with its center site excluded is represented as Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])\n\nTo define a new type of lattice, create an alias for Lattice{YourSym, YourN, YourNB}. Refer to the docs for detailed explanation.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeSite","page":"Library","title":"LatticeModels.LatticeSite","text":"LatticeSite{N}\n\nA site of a Lattice{LatticeSym, N, NB} lattice.\n\nFields:\n\nunit_cell: a set of translations along all axes representing the unit cell the site is located in.\nbasis_index: the number of site in the lattice basis.\n\nThis type is used to iterate over all sites of a Lattice{LatticeSym, N, NB}. The exact location of a LatticeSite can be found using the coords(lattice, site) function.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nType alias for Lattice{:square,N,1}.\n\n\n\nSquareLattice(sz::Int...)\n\nConstructs a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coords-Tuple{Lattice, LatticeSite}","page":"Library","title":"LatticeModels.coords","text":"coords(lattice::Lattice, site::LatticeSite) -> vector\n\nFinds the location in space of lattice site site on lattice lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.radius_vector-Tuple{Lattice, LatticeSite, LatticeSite}","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(lattice::Lattice, site1::LatticeSite, site2::LatticeSite) -> vector\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macro cell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym","page":"Library","title":"LatticeModels.sublattice","text":"sublattice(lf::Function, l::Lattice) -> Lattice\n\nGenerates a a subset of lattice l by applying the lf function to its sites. The lf function must accept two positional arguments (a LatticeSite and a vector with its coordinates) and return a boolean value.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-values","page":"Library","title":"Lattice values","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_value.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LatticeSym}\n\nRepresents a value of type T on a Lattice{LatticeSym} lattice.\n\nFields:\n\nlattice: the Lattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coord_values-Tuple{Lattice}","page":"Library","title":"LatticeModels.coord_values","text":"coord_values(lattice::Lattice)\n\nGenerates a tuple of LatticeValues representing coordinate functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.plot_fallback-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.plot_fallback","text":"plot_fallback(lv::LatticeValue)\n\nCreates a copy of lv lattice value with its LatticeSym overwritten to :uncertain. Use it to invoke the default plot recipe for LatticeValues when defining a custom one.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-operators","page":"Library","title":"Lattice operators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_operator.jl\"]","category":"page"},{"location":"library/#LatticeModels.Basis","page":"Library","title":"LatticeModels.Basis","text":"Basis{LT} where {LT<:Lattice}\n\nA basis on a lattice with some number of internal states on each site. Fields:\n\nlattice: the Lattice of the basis\ninternal_dim: the number of internal states on each site\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeArray","page":"Library","title":"LatticeModels.LatticeArray","text":"LatticeArray{LT, MT} where {LT<:Lattice, MT<:AbstractArray}\n\nA wrapper object for array representing a wave function or linear operator. Stores information about its basis to perform lattice checks.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeOperator-Tuple{LinearAlgebra.UniformScaling, Basis}","page":"Library","title":"LatticeModels.LatticeOperator","text":"LatticeOperator{LT, MT}\n\nThe same as LatticeArray{LT, MT} where MT<:AbstractMatrix.\n\n\n\nLatticeOperator(uniform_scaling, basis)\n\nCreates a LatticeOperator representation of a UniformScaling operator on given basis.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TensorProduct","page":"Library","title":"LatticeModels.TensorProduct","text":"TensorProduct{LVT, MT} where {LVT<:LatticeValue{<:Number}, MT<:AbstractMatrix}\n\nA lazy representation of an operator as a tensor product of two distinct phase spaces. One affects only the internal space, the other - only the lattice space.\n\nThe lattice_value ⊗ matrix notation computes the value of the TensorProduct eagerly, which means that the result will be a LatticeOperator. However, in the @hamiltonian macro lazy computation is forced.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coord_operators-Tuple{Basis}","page":"Library","title":"LatticeModels.coord_operators","text":"coord_operators(basis)\n\nReturns a Tuple of coordinate LatticeOperators for given basis.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coord_operators-Tuple{Lattice, Int64}","page":"Library","title":"LatticeModels.coord_operators","text":"coord_operators(lattice, ndims)\n\nThe same as coord_operators(Basis(lattice, ndims)).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_aggregate-Tuple{Function, LatticeModels.LatticeArray}","page":"Library","title":"LatticeModels.diag_aggregate","text":"diag_aggregate(function, lattice_operator)\n\nCreates a LatticeValue where a site maps to the result of function on the matrix of the operator narrowed to that site.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Basis, LatticeValue{<:Number}}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(basis, lattice_value)\n\nCreates a diagonal operator which affects only the lattice space. The lattice_value argument must be a LatticeValue storing diagonal elements of the operator in lattice space.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Function, Basis}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(site_fun, basis)\n\nCreates a diagonal operator which affects only the lattice space. The site_fun function must accept a LatticeSite and its coordinates and return a number which will be the diagonal element of the operator in lattice space.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Function, Lattice}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(site_fun, lattice)\n\nCreates a diagonal operator by applying the site_fun function to each site of lattice. The site_fun function must accept a LatticeSite and its coordinates and return a matrix which will be an operator affecting the internal state of the site.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diag_operator-Tuple{Lattice, AbstractMatrix}","page":"Library","title":"LatticeModels.diag_operator","text":"diag_operator(lattice, matrix)\n\nCreates a diagonal operator which affects only the internal state the same way on every site. matrix is an AbstractMatrix representing the linear operator on the internal space.\n\nNote that the matrix of the output LatticeOperator will be similar to matrix: for instance, if matrix is sparse, so will be the output.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ptrace-Tuple{LatticeModels.LatticeArray}","page":"Library","title":"LatticeModels.ptrace","text":"ptrace(lattice_operator)\n\nSame as diag_aggregate(tr, lattice_operator)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@on_lattice-Tuple{Any}","page":"Library","title":"LatticeModels.@on_lattice","text":"@on_lattice\n\nReplaces all LatticeArrays in subsequent function calls with actual arrays stored inside them. Throws an error if lattice operators in one function call are defined on different lattices, shows a warning if a lattice array is used in one call with a normal array.\n\nExample\n\nl = SquareLattice(10, 10)\nbas = Basis(l, 2)\nX, Y = coord_operators(bas)\nxexpypy = diag_operator(bas) do site, (x, y)\n    x * exp(y) + y\nend\nxexpy == @on_lattice X * exp(Y) + Y     # true\n\n\n\n\n\n","category":"macro"},{"location":"library/#Hoppings","page":"Library","title":"Hoppings","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hoppings.jl\"]","category":"page"},{"location":"library/#LatticeModels.BondSet","page":"Library","title":"LatticeModels.BondSet","text":"BondSet{LT} where {LT<:Lattice}\n\nRepresents the bonds on some lattice.\n\nBondSets can be combined with the | operator and negated with the ! operator. Also you can create a BondSet which connects sites that were connected by ≤n bonds of the previous BondSet by taking its power: bs2 = bs1 ^ n.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Hopping","page":"Library","title":"LatticeModels.Hopping","text":"Hopping{MT} where {MT<:AbstractMatrix}\n\nA struct representing a bond in a lattice.\n\nsite_indices: a NTuple{2, Int} with indices of sites connected by the bond.\ntranslate_uc: the unit cell offset.\npbc: a vector of boolean values indicating if the bonds should be applied periodically over each axis.\nhop_operator: a matrix of type MT representing the operator affecting the internal state.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.bonds-Tuple{Lattice, Vararg{LatticeModels.Hopping}}","page":"Library","title":"LatticeModels.bonds","text":"bonds(lattice, hoppings...)\n\nGenerates a BondSet for a given set of Hoppings on a given Lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.bonds-Tuple{LatticeOperator}","page":"Library","title":"LatticeModels.bonds","text":"bonds(operator)\n\nGenerates a BondSet for the provided operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.hopping","page":"Library","title":"LatticeModels.hopping","text":"hopping([hop_operator,] kwargs...)\n\nA convenient constructor for a Hopping object. hop_operator can be either a matrix or a number (in that case a 1×1 matrix will be created automatically)\n\nKeyword arguments:\n\nsite_indices: a NTuple{2, Int} (or Int if they are equal) with indices of sites connected by the bond. (1, 1) by default.\ntranslate_uc: the unit cell offset. Zeros by default.\naxis: overrides translate_uc and sets its components to zero on all axes except given.\npbc: a vector of boolean values indicating if the bonds should be applied periodically over each axis.\n\nCan also be a single boolean, which will set all elements of the vector to given value. false by default.\n\nIf site_indices are equal and translate_uc is zero, this means that the bond connects each site with itself, in which case an error will be thrown. Note that the dimension count for the hopping is dynamic and will automatically change during runtime.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.hopping_operator","page":"Library","title":"LatticeModels.hopping_operator","text":"hopping_operator(args...)\n\nCreates a hopping operator: hatA = sum_pairs hatt hatc^dagger_j hatc_i + h c\n\n\n\nhopping_operator(function, lattice, hopping[, field])\nhopping_operator(excl_function, lattice, hopping[, field])\nhopping_operator(lattice, hopping, excl_value[, field])\n\nArguments:\n\nexcl_function: takes a LatticeSite and its coordinate vector, returns whether the pair with this site should be included.\nexcl_value: same as excl_function, but represented as a LatticeValue{Bool}\nlattice: the lattice to create the operator on.\nhopping: the Hopping object describing the site pairs and the hatt operator.\nfield: the AbstractField object that defines the magnetic field to generate phase factors using Peierls substitution.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.promote_dims!-Tuple{LatticeModels.Hopping, Int64}","page":"Library","title":"LatticeModels.promote_dims!","text":"promote_dims!(hopping, ndims)\n\nChanges dimension count of hopping to ndims if possible.\n\n\n\n\n\n","category":"method"},{"location":"library/#Magnetic-fields","page":"Library","title":"Magnetic fields","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"field.jl\"]","category":"page"},{"location":"library/#LatticeModels.FluxField","page":"Library","title":"LatticeModels.FluxField","text":"FluxField <: AbstractField\n\nAn object representing a small magnetic flux through given point. The field is directed along z-axis. Fields:\n\nB: The magnetic field value\npoint: A NTuple{2, Number} representing the point where the magnetic flux is located.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LandauField","page":"Library","title":"LatticeModels.LandauField","text":"LandauField <: AbstractField\n\nAn object representing Landau calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NoField","page":"Library","title":"LatticeModels.NoField","text":"NoField <: AbstractField\n\nA stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SymmetricField","page":"Library","title":"LatticeModels.SymmetricField","text":"SymmetricField <: AbstractField\n\nAn object representing symmetrically calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.apply_field!-Tuple{LatticeOperator, AbstractField}","page":"Library","title":"LatticeModels.apply_field!","text":"apply_field!(hamiltonian, field[; nsteps])\n\nApplies magnetic field to given hamiltonian matrix by adjusting the phase factors.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.trip_integral-Tuple{AbstractField, Any, Any}","page":"Library","title":"LatticeModels.trip_integral","text":"trip_integral(field, p1, p2; n_steps=1)\n\nCalculates the int_p1^p2 overrightarrowA cdot overrightarrowdl integral using the trapezoidal rule. Increase n_steps to improve accuracy (for linear fields like Landau or symmetrical calibrations the formula is accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.vector_potential-Union{Tuple{FT}, Tuple{FT, Any}} where FT<:AbstractField","page":"Library","title":"LatticeModels.vector_potential","text":"vector_potential(field, point)\n\nReturns vector potential overrightarrowA for field in location point.\n\nThis function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@field_def-Tuple{Any}","page":"Library","title":"LatticeModels.@field_def","text":"@field_def block\n\nDefines a new magnetic field type.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Hamiltonian-tools","page":"Library","title":"Hamiltonian tools","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hamiltonian.jl\"]","category":"page"},{"location":"library/#LatticeModels.Spectrum","page":"Library","title":"LatticeModels.Spectrum","text":"Spectrum{LT, MT} where {LT<:Lattice, MT<:AbstractMatrix}\n\nEigenvalues and eigenvectors for some operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.filled_projector","page":"Library","title":"LatticeModels.filled_projector","text":"filled_projector(spectrum[, fermi_level])\n\nCreates a LatticeOperator that projects onto the eigenvectors which have eigenvalues less than fermi_level (0 by default).\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.projector-Tuple{Function, Spectrum}","page":"Library","title":"LatticeModels.projector","text":"projector(fun, spectrum)\n\nCreates a LatticeOperator that projects onto the eigenvectors of the spectrum with amplitude defined by the fun functions, which takes the eigenvalue and returns a number (or a boolean).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{Spectrum}","page":"Library","title":"LatticeModels.projector","text":"projector(spectrum)\n\nCreates a LatticeOperator that projects onto the eigenvectors of the spectrum\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.spectrum-Tuple{LatticeModels.LatticeArray{LT, <:Matrix} where LT}","page":"Library","title":"LatticeModels.spectrum","text":"spectrum(operator)\n\nFinds eigenvalues and eigenvectors for a LatticeOperator and stores in in a Spectrum.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@hamiltonian-Tuple{Any}","page":"Library","title":"LatticeModels.@hamiltonian","text":"@hamiltonian block\n\nCreates a hamiltonian according to the rules defined in the block.\n\nEach line in the block must be a := assignment or a macro-like diagonal/hopping operator description.\n\nThe lattice on and the magnetic field for the hamiltonian can be set by assigning lattice and field.\n\n@diag stands for a diagonal part of the hamiltonian - after this you can use a matrix (representing the operator affecting the internal state), a function or a ⊗ tensor product notation.\n\n@hop stands for a hopping part of the hamiltonian - list arguments to pass to the hopping function after this macrocall.\n\nExamples\n\nFor example let's generate a Chern insulator hamiltonian.\n\nl = SquareLattice(10, 10)\nx, y = coord_values(l)\nH = @hamiltonian begin\n    lattice := l\n    field := LandauField(0.5)   # Landau-calibrated uniform magnetic field, 0.5 flux quanta per 1×1\n    @diag (@. abs(x) < 2) ⊗ [1 0; 0 -1]\n    @hop [1 im; im -1] / 2 axis = 1\n    @hop [1 1; -1 -1] / 2 axis = 2\nend\n\n\n\n\n\n","category":"macro"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"currents.jl\"]","category":"page"},{"location":"library/#LatticeModels.AbstractCurrents","page":"Library","title":"LatticeModels.AbstractCurrents","text":"AbstractCurrents\n\nSupertype for all type representing currents-like values on a lattice. Subtypes must implement current_lambda and lattice functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.DensityCurrents","page":"Library","title":"LatticeModels.DensityCurrents","text":"DensityCurrents <: AbstractCurrents\n\nDensity currents for given density matrix and given hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.MaterializedCurrents","page":"Library","title":"LatticeModels.MaterializedCurrents","text":"MaterializedCurrents <: AbstractCurrents\n\nA AbstractCurrents instance that stores values for all currents explicitly.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SubCurrents","page":"Library","title":"LatticeModels.SubCurrents","text":"SubCurrents{CT<:AbstractCurrents} <: AbstractCurrents\n\nA lazy wrapper for a SubCurrents object that representing the same currents but on a smaller lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.current_lambda-Tuple{T} where T<:AbstractCurrents","page":"Library","title":"LatticeModels.current_lambda","text":"current_lambda(::AbstractCurrents)\n\nReturns a function that takes two integer indices of sites in a lattice and returns the current between these two sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.lattice-Tuple{T} where T<:AbstractCurrents","page":"Library","title":"LatticeModels.lattice","text":"lattice(::AbstractCurrents)\n\nGets the lattice where the given AbstractCurrents object is defined.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.materialize-Tuple{AbstractCurrents}","page":"Library","title":"LatticeModels.materialize","text":"materialize([function, ]currents)\n\nCreates a MaterializedCurrents instance for currents.\n\nIf function is provided, it must accept a Lattice and two LatticeSites and return if the current between this site must be calculated or not. This can be useful to avoid exsessive calculations.\n\n\n\n\n\n","category":"method"},{"location":"library/#Unitary-evolution","page":"Library","title":"Unitary evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"evolution.jl\"]","category":"page"},{"location":"library/#LatticeModels.evolution_operator-Tuple{Any, Real}","page":"Library","title":"LatticeModels.evolution_operator","text":"evolution_operator(H, t[, k])\n\nCalculates the unitary evolution operator using the formula\n\n$ \\mathcal{U}(t) = e^{-\\frac{1}{i\\hbar} \\hat{H} t} $\n\nArguments\n\nH: the hamiltonian matrix\nt: the evolution time\nk: if provided, the exponent will be calculated using a Taylor series expansion with order k\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@evolution-Tuple","page":"Library","title":"LatticeModels.@evolution","text":"@evolution [kwargs...] {rules...} for_loop\n\nGenerates an environment with defined hamiltonian and density matrices that evolve by certain laws. See Unitary evolution for more details.\n\n\n\n\n\n","category":"macro"},{"location":"hamiltonian/#Hamiltonian-macro","page":"Hamiltonian generation","title":"Hamiltonian macro","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"A hamiltonian operator usually consists of a diagonal part and a hopping part.  Sometimes a magnetic field is applied, in which case additional phase factors emerge according to Peierls substitution. ","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Taking all this into account, the operator will now look something like this:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"hatH = \nsum_i hats_i hatc^dagger_i hatc_i + left( sum_textadjacent i j hatt_ij hatc^dagger_j hatc_i\ncdot e^frac2pi iphi_0 int_r_i^r_j overrightarrowA cdot overrightarrowdl + h c right)","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Such an operator can be easily constructed using the @hamiltonian macro.  All you have to do is assign lattice and also field if needed, and then define the diagonal and hopping members using @diag and @hop.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Let's take a look at the example on the Usage examples page:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"A simple Hubbard model hamiltonian for a square lattice is defined by the formula  hatH = sum_textx-bonds c^dagger_i c_j + sum_texty-bonds c^dagger_i c_j + h c","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"We can create a matrix for this operator on a xsize×ysize square lattice with the following code:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"using LatticeModels","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Hubbard(xsize, ysize, field=NoField()) = @hamiltonian begin\n    lattice := SquareLattice(xsize, ysize)\n    field := field\n    @hop axis = 1   # x-bonds\n    @hop axis = 2   # y-bonds\nend\nnothing # hide","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Note that the keyword arguments for hopping operators are written as if they were passed to the hopping function.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"For a Chern insulator the hamiltonian looks like this:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"hatH = \nsum_i m_i c^dagger_i sigma_z c_i + left(\nsum_textx-bonds c^dagger_i fracsigma_z - i sigma_x2 c_j + \nsum_texty-bonds c^dagger_i fracsigma_z - i sigma_y2 c_j + \nh c right)","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Here we want the m_i values to be represented by any number-typed LatticeValue - so the most convenient way to do it is to use tensor product notation:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"# The Pauli matrices\nconst σ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\n\n# Initial hamiltonian: m=1 everywhere\nChernInsulator(m::LatticeValue{<:Number, :square}, field=NoField()) = @hamiltonian begin   \n    lattice := lattice(m)\n    field := field\n    @diag m ⊗ σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\nnothing # hide","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Note that the field parameter is defaulted to NoField() - this is a magnetic field object representing zero field. Other available magnetic field objects are:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"LandauField(B::Real) - Landau-calibrated uniform magnetic field\nSymmetricField(B::Real) - symmetrically calibrated uniform magnetic field\nFluxField(Φ::Real, point::NTuple{2, Number}) - point magnetic field flux through point.","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"Most of these fields are designed for 2D lattices, but may also be applied to lattices with other dimensionality.","category":"page"},{"location":"hamiltonian/#Operator-spectrum-utilities","page":"Hamiltonian generation","title":"Operator spectrum utilities","text":"","category":"section"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"A Spectrum object contains eigenvalues and eigenvectors of some hermitian operator. ","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"It is a very convenient way to work with eigenvectors. Check this out:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"sp = spectrum(Hubbard(5, 5))\nsp[1]       # Get the first eigenstate (e. g. ground state)\nsp[3]       # Get the third eigenstate\nsp[E = 0]   # Get eigenstate with energy nearest to 0\nsp[1:3]     # Create a new Spectrum with states from #1 to #3\nE = eigvals(sp) # Get eigenvalues\nsp_filled = sp[E .< 0]  # Create a new Spectrum with filled bands only","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"if you need an operator that projects onto some states, use projector or filled_projector functions:","category":"page"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"P = projector(E -> E < 0, sp)\nP = projector(sp_filled)    # The same thing\nP = filled_projector(sp, 0) # The same thing\nP = filled_projector(sp)    # The same thing","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"TODO","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"We often  want to study the behavior of some quantum system in time-dependent conditions. We can use the unitary evolution operator to describe how the density matrix depends on time:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"mathcalU(t) = Tleft e^frac1ihbar int_t_0^t hatH(tau) dtau righthspace05cm\nmathcalP(t) = mathcalU(t) mathcalP_0 mathcalU^dagger (t)","category":"page"},{"location":"evolution/#The-evolution-macro","page":"Unitary evolution","title":"The evolution macro","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro can be quite useful if your hamiltonian depends on time or if there are multiple hamiltonians in your experiment. It avoids excessive computation in several cases automatically:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian does not change, the mathcalU(t dt) operator will not be re-evaluated.\nIf several wave functions or density matrices evolve using the same hamiltonian, neither the hamiltonian nor the evolution operator matrix will be re-evaluated.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us define a function that generates a Chern insulator hamiltonian:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"using LatticeModels, Plots\nσ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\nChern(l, B) = @hamiltonian begin\n    lattice := l\n    field := LandauField(B)\n    @diag σ[3]\n    @hop axis=1 (σ[3] - im * σ[1]) / 2\n    @hop axis=2 (σ[3] - im * σ[2]) / 2\nend\nnothing # hide","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The @evolution macro creates a scope where the hamiltonian and wave functions (or density matrices) are evaluated for the given time interval.  It takes two arguments - a braced list with evolution specifiers and a for-loop that iterates over the time interval:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"l = SquareLattice(10, 10)\nτ = 30\na = Animation()\nB = 0.01\nP0 = filled_projector(spectrum(Chern(l, 0)))\n\n@evolution {\n    H := Chern(l, B * min(t, τ) / τ),\n    P0 --> H --> P\n} for t in 0:0.1:2τ\n    cur = DensityCurrents(H, P)\n    heatmap(ptrace(P) .|> real, title=\"Local density, t = $t\", clims=(0.9, 1.1))\n    plot!(cur, arrows_scale=20, color=:blue)\n    frame(a)\nend\ngif(a, \"animation.gif\")","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us make it clear what an evolution specifier is. In fact, there are two possible variants:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"It is an evolution rule describing the initial state, the hamiltonian it will evolve accroding to, and the name of the variable to write the result. These three arguments must be written in a chain delimited by --> like this: \nP0 --> Chern(l, B * min(t, τ) / τ) --> P\nNote that you can use a hamiltonian alias instead of an expression if it was previously defined.\nIt is an alias declaration, which means that a certain expression will be evaluated on every iteration and assigned to a variable with a given name. For example, H := Chern(l, B * min(t, τ) / τ) evaluates the Chern insulator hamiltonian and writes the result to the H variable.","category":"page"},{"location":"evolution/#Compatibility","page":"Unitary evolution","title":"Compatibility","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro is designed to be compatible with arbitrary array types. This means that hamiltonian expressions or initial states needn't to be LatticeArrays, but they can be of any array type instead, as long as it supports linear algebra operations such as matrix multiplication.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here are the functions that must be defined for the desired array type:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Equality operator: ==\nBasic arithmetic functions: +, -, *, adjoint\nThe matrix exponent exp(A)\nIf it is not possible to implement this function you can define the one(A) function which returns the identity matrix with the size same as A. This will allow to calculate the matrix exponent as a partial sum of Taylor series.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"warning: Warning\nIf you use LatticeArrays, you still have to make sure these functions and operators are defined for the underlying array type.","category":"page"},{"location":"evolution/#Performance","page":"Unitary evolution","title":"Performance","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The evolution macro avoids calculations where possible to improve performance. It is important to know how it achieves this result:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian has not changed between two iterations and the time step remained approximately the same, mathcalU(t dt) will not be re-evaluated, because the matrix exponent is the most time-consuming operation compared to others like matrix multiplication or addition.\nThe relative tolerance used to check if the time step has changed can be set via rtol keyword.\nIf the hamiltonian expression does not explicitly depend on the loop variable (t in the example), it will be considered constant and evaluated only once at the beginning. Otherwise it will be evaluated on every iteration in the loop scope.\nIf several states evolve according to the same hamiltonian, both the hamiltonian and the mathcalU(t dt) evolution operator will be evaluated only once per iteration.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"To improve performance with small time intervals you can calculate the matrix exponent as a Taylor polynomial - its order can be set via k keyword.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Keyword assignments should be placed before the rules list:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"@evolution k=2 rtol=1e-6 {...} for t in ...","category":"page"},{"location":"lattice/#Simple-Bravais-lattice","page":"Defining a lattice","title":"Simple Bravais lattice","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The simplest variant of a finite Bravais lattice is a macro cell,  which is the lattice basis translated finite number of times along every translation vector.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"using LatticeModels, Plots, LinearAlgebra","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Constructing a macro cell is simple: the lattice constructor accepts positional arguments which will be translation ranges along all dimensions.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Note that lattices of some types can be of any dimensionality, while others can not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"julia> SquareLattice(10, 10)\n100-site square lattice on 10×10 base\n\njulia> SquareLattice(3, 3, 3)\n27-site square lattice on 3×3×3 base\n\njulia> HoneycombLattice(5, 5)\n50-site honeycomb lattice on 5×5 base (2-site basis)\n\njulia> HoneycombLattice(3, 3, 2)\nERROR: MethodError: no method matching HoneycombLattice(::Int64, ::Int64, ::Int64)\n[...]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A lattice can be scatter-plotted to see how its sites are located.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"p = plot(size=(800, 350), layout=2)\nplot!(p[1], SquareLattice(10, 5))\nplot!(p[2], HoneycombLattice(8, 4))","category":"page"},{"location":"lattice/#Sublattices","page":"Defining a lattice","title":"Sublattices","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Suppose we want to create a lattice with non-trivial geometry (for example, with holes).  This can be done by deleting some of the sites from the macro cell. There are three ways ways to do this:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Convenient way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = SquareLattice(10, 10)\n\nx, y = coord_values(l)\nl1 = l[@. abs(x) > 3 || abs(y) > 3]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Here we first create the macro cell, then find the coordinate values for its sites. After that we use LatticeValue broadcasting - see Lattice values for more detail.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"tip: Tip\nThis way to define sublattices is preferred, because code like this is the most readable. The x, y coordinate values will be also helpful to create other sublattices or slices.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Low-level way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l2 = sublattice(l) do site, (x, y); abs(x) > 3 || abs(y) > 3; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The lambda must accept a LatticeSite and a coordinate vector as positional arguments  and return whether the site should be included or not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The In-place way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l3 = SquareLattice(10, 10) do site, (x, y); abs(x) > 3 || abs(y) > 3; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"This notation is exactly the same as the low-level way, but done in one line.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warning: Warning\nThis notation should be used only if you need to access site indices or if the x, y coordinate values will not be needed further in the program.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The plot recipe for sublattices shows excluded sites with translucent markers by default. Passing keyword argument show_excluded_sites=false disables this.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = HoneycombLattice(6, 6)\nx, y = coord_values(l)\nplot(l[@. -5 < x * √3 + y < 5.5])","category":"page"},{"location":"lattice/#Custom-lattice-types","page":"Defining a lattice","title":"Custom lattice types","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"It is quite likely that you will need more types of lattices than this package provides by default. In such cases you need to define a new type. Follow these steps:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Create an exact alias","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Select a Symbol that will be the LatticeSym for this type and define an alias for the Lattice{LatticeSym, N, NB} type. The alias must not have any type parameters except for the dimension count if needed:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const HoneycombLattice = Lattice{:honeycomb, 2, 2}\nconst SquareLattice{N} = Lattice{:square, N, 1}","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Define the constructor","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The only positional arguments allowed are the macro cell size.[1] The Bravais object must be generated in the constructor and passed to the default constructor Lattice(sym, sz, bvs).","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"[1]: This is done with purpose to achieve code consistency. Also in-place sublattice generation will almost certainly be broken. Use keyword arguments if you need additional parameters for some lattice type.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Let us define our own lattice type:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const GrapheneLattice = Lattice{:graphene, 3, 2}\nfunction GrapheneLattice(sz::Vararg{Int, 3})\n    bvs = Bravais([1 1/2 0; 0 √3/2 0; 0 0 2], [0 1/2; 0 √3/6; 0 0])\n    Lattice(:graphene, sz, bvs)\nend\nnothing # hide","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A sublattice constructor will be generated by default:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"gl = GrapheneLattice(6, 6, 3) do site, (x, y, z)\n    -5 < x * √3 + y < 5.5\nend\nplot(gl, show_excluded_sites=false)","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warning: Warning\nPlease note that if the type alias is dimension-parametric, you must define the constructor for a concrete type, otherwise you will almost definitely break the lattice constructor dispatch:SquareLattice(sz::Vararg{Int, N}) where N = ...     # Wrong!\nSquareLattice{N}(sz::Vararg{Int, N}) where N = ...  # CorrectIn the second example SquareLattice(sz::Vararg{Int, N}) constructor will be generated automatically.","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry and any possible count of internal states on one sites.\nVersatile hamiltonian generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nSmart unitary evolution macro reducing excessive computations where possible.\nPlots.jl integration.","category":"page"},{"location":"#Usage-examples","page":"Home","title":"Usage examples","text":"","category":"section"},{"location":"#Currents-in-Hubbard-model-on-a-ring-shaped-sample","page":"Home","title":"Currents in Hubbard model on a ring-shaped sample","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this example we delete part of the sites in the middle of a square lattice.  Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Hubbard model hamiltonian is defined by this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = sum_textx-bonds c^dagger_i c_j + sum_texty-bonds c^dagger_i c_j + h c","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing LinearAlgebra, Plots\n\nl = SquareLattice(10, 10) do site, (x, y)\n    abs(x) > 1 || abs(y) > 1\nend\n\n# Define a spinless Hubbard model hamiltonian\nh(B) = @hamiltonian begin   \n    lattice := l\n    # Add hoppings along axis x and y\n    @hop axis = 1\n    @hop axis = 2\n    # Add magnetic field through (0, 0) point\n    field := FluxField(B, (0, 0))\nend\n\n# Calculate eigenvalues and eigenvectors\nsp = spectrum(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = filled_projector(sp)\n# Perform unitary evolution\nτ = 10\na = Animation()\n@evolution {\n    H := h(0.1 * min(t, τ) / τ)\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    # Find the partial trace and plot it\n    heatmap(real.(ptrace(P)), clims=(0,1))\n\n    # Show currents on the plot\n    plot!(DensityCurrents(H, P), arrows_scale=7, arrows_rtol=0.1)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"#Local-Chern-marker-with-hamiltonian-quench","page":"Home","title":"Local Chern marker with hamiltonian quench","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Chern insulator hamiltonian is described by this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = \nsum_i m_i c^dagger_i sigma_z c_i + left(\nsum_textx-bonds c^dagger_i fracsigma_z - i sigma_x2 c_j + \nsum_texty-bonds c^dagger_i fracsigma_z - i sigma_y2 c_j + \nh c right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this experiment we create a filled state density matrix for a system with m_i = 1.  After that we change the m_i in the center of the lattice to -1 and start the evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing LinearAlgebra, Plots\n\nl = SquareLattice(11, 11)\nx, y = coord_values(l)\n\n# The Pauli matrices\nσ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\n\n# Initial hamiltonian: m=1 everywhere\nH1 = @hamiltonian begin   \n    lattice := l\n    @diag σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\n\n# Quenched hamiltonian: m=-1 in the central 3x3 square\nM = @. (abs(x) < 1.5 && abs(y) < 1.5) * -2 + 1\nH2 = @hamiltonian begin\n    lattice := l\n    @diag M ⊗ σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\nX, Y = coord_operators(l, 2)\n\nsp = spectrum(H1)\nP_0 = filled_projector(sp)\n\nτ = 10\na = Animation()\n@evolution {\n    H := H2\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    p = plot(layout=2, size=(900, 500))\n\n    # Local Chern marker heatmap\n    lcm_operator = 4pi * im * P * X * P * Y * P\n    chern_marker = ptrace(lcm_operator) .|> real\n    heatmap!(p[1], chern_marker, clims=(-2, 2))\n\n    # Select sites on y=0 line (use ≈ to avoid rounding errors)\n    chern_marker_on_sw = chern_marker[@. y ≈ 0]\n    # Mark selected sites on the heatmap\n    plot!(p[1], lattice(chern_marker_on_sw), high_contrast=true)\n    # Add a line plot\n    plot!(p[2], chern_marker_on_sw, project_axis=:x, ylims=(-3, 3), lab=:none)\n\n    plot!(plot_title=\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"lattice_operator/#Lattice-operators","page":"Lattice operators","title":"Lattice operators","text":"","category":"section"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"using LatticeModels","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"A LatticeArray is a wrapper type that maps an operator matrix or a wave function vector to a basis it is defined on.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"A Basis, in turn, is generally a pair of a Lattice and an Int which is the number of internal states on every lattice site.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"You can create LatticeArray representations of coordinate operators by using the coord_operators function. ","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"l = SquareLattice(5, 5)\nbas = Basis(l, 2)\nX, Y = coord_operators(bas) # Same as coord_operators(l, 2)","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"You can use arithmetic operators with LatticeArrays freely - after checking that the bases match they will be applied to the contained arrays, and the result will be wrapped into a new LatticeArray.  However, if you want to apply some other array operations (like exp), you can use the @on_lattice macro which will wrap the call as needed.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"julia> X, Y = coord_operators(SquareLattice(5, 5), 2);\n\njulia> X * sin(Y)\nERROR: MethodError: no method matching sin\n\njulia> @on_lattice X * sin(Y)\n50×50 LatticeOperator with inner type Matrix{Float64}\non Basis with 2-dimensional internal phase space\non 25-site square lattice on 5×5 base","category":"page"},{"location":"lattice_operator/#Diagonal-operators","page":"Lattice operators","title":"Diagonal operators","text":"","category":"section"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"A lattice-diagonal operator can be represented as  hatA = sum_i hats_i hatc^dagger_i hatc_i , where hats_i is an operator defined on the internal space and hatc^dagger_i hatc_i are standard quantization operators.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"Such an operator can be defined generally in two ways: ","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"As a tensor product","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"The hatB operator, being diagonal in the site basis, can easily be represented as a LatticeValue, while the hatC operator can be defined by a matrix.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"l = HoneycombLattice(5, 5);\nx, y = coord_values(l);\nX, Y = coord_operators(l, 2);\nop = (@. x + y) ⊗ [1 0; 0 1]\nX + Y == op","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"As a function call","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"The diag_operator function is a low-level way to create a LatticeOperator.  It accepts two arguments: one is a Lattice or a Basis, and the other is a function that can be written in the do-syntax same way as before.  There are more possible ways to use this function, refer to diag_operator docstring to find out more.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"op1 = diag_operator(l) do site, (x, y)\n    (x + y) * [1 0; 0 1]\nend\nop2 = diag_operator(Basis(l, 2)) do site, (x, y)\n    x + y\nend\nop3 = diag_operator(Basis(l, 2), x .+ y)\nX + Y == op1 == op2 == op3","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"Note that you can appply a function to every lattice-diagonal block of the operator matrix to create a LatticeValue with the diag_aggregate function.  For example, you can find a partial trace like this:","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"using LinearAlgebra\nlv = diag_aggregate(tr, op) # same as ptrace(op)\nlv == 2 .* x","category":"page"},{"location":"lattice_operator/#Hopping-operators","page":"Lattice operators","title":"Hopping operators","text":"","category":"section"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"A hopping operator is described by the following formula:","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"hatA = sum_textadjacent (i j) hath hatc^dagger_j hatc_i + h c","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"The Hopping struct is a lazy representation of such an operator - it stores a matrix of the hath operator  and information about which sites should be considered adjacent.  The relative location of the connected sites is defined by their indices in the lattice basis  and the relative location of their unit cells as translations along lattice axes (represented as an integer vector).","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"A Hopping object can be created with the hopping function - its only positional argument is  the hath operator matrix and keyword arguments site_indices and translate_uc. ","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"l = HoneycombLattice(5, 5)\nhop1 = hopping(site_indices=(2, 1), translate_uc=[1, 0])","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"If the unit-cell translation is a single move along some lattice axis, you can instead set the axis keyword to the number of the translation axis.  If there is no unit cell translation between the two sites, this argument can be omitted.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"hop2 = hopping(site_indices=(2, 1), axis=2) # same as translate_uc=[0, 1]\nhop3 = hopping(site_indices=(2, 1))","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"Note that no operator matrix argument was passed in the example above, which means that it was set to a 1×1 eye matrix automatically.","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"To generate a LatticeOperator, invoke the hopping_operator function with a Lattice and a Hopping:","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"hop_op = hopping_operator(l, hop1) + \n         hopping_operator(l, hop2) + \n         hopping_operator(l, hop3)","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"The bonds defined by the operator can be displayed on a plot in the following way:","category":"page"},{"location":"lattice_operator/","page":"Lattice operators","title":"Lattice operators","text":"bs = bonds(hop_op)\n\nusing Plots\nplot(bs)\nplot!(l, show_excluded_sites=false)","category":"page"},{"location":"lattice_values/#LatticeValue-basics","page":"Lattice values","title":"LatticeValue basics","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"A LatticeValue is a struct that maps sites of a certain Lattice to values of some type.  One can be generated using a do-syntax similar to one in Sublattices:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"using LatticeModels, Plots","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"l = SquareLattice(5, 5)\nlv = LatticeValue(l) do site, (x, y); x + y + 1; end","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"To generate LatticeValues for site coordinates, you can use the coord_values function. Note that LatticeValues support broadcasting, which means you can create coordinate-dependent lattice values in-place:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"x, y = coord_values(l)\nlv == x .+ y .+ 1","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Lattice values implement a scatter plot recipe, which colors the plot markers according to the value:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"plot(lv, markersize=20)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"note: Note\nA wave function cannot and must not be stored as a LatticeValue - use LatticeVector instead.  The reason is that a LatticeValues does not take one-site phase spaces into account.","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Depending on the lattice type, additional plot recipes can be available. For example, a lattice value on a square lattice can be plotted as a heatmap:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"heatmap(lv)","category":"page"},{"location":"lattice_values/#Indexing","page":"Lattice values","title":"Indexing","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"It is often required to select some sites by certain condition.  This can be done using a LatticeValue{Bool} and broadcasting (like with Sublattices).","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"heatmap(lv[@. √(x^2 + y^2) > 1.2])","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that a LatticeValue can be projected to some coordinate axis to create line plots.","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"lv_on_line = lv[@. x ≈ 0]   # Use approximate comparison to avoid rounding errors\np = plot(layout=(2, 1))\n\nheatmap!(p[1], lv)\nplot!(p[1], lattice(lv_on_line), high_contrast=true)\nplot!(p[2], lv_on_line, project_axis=:y)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that we can show the sites we selected by plotting the lattice of the selected values with high_contrast=true. This options make the plot markers black-and-white, which prevents them from blending in with the heatmap in the background.","category":"page"}]
}

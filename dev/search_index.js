var documenterSearchIndex = {"docs":
[{"location":"manual/currents/#Currents","page":"Currents","title":"Currents","text":"","category":"section"},{"location":"manual/currents/#Basics","page":"Currents","title":"Basics","text":"","category":"section"},{"location":"manual/currents/#Common-Operations","page":"Currents","title":"Common Operations","text":"","category":"section"},{"location":"manual/currents/#Visualization","page":"Currents","title":"Visualization","text":"","category":"section"},{"location":"manual/lattice/#Lattices","page":"Defining the lattice","title":"Lattices","text":"","category":"section"},{"location":"manual/lattice/#Basics","page":"Defining the lattice","title":"Basics","text":"","category":"section"},{"location":"manual/lattice/#Sites","page":"Defining the lattice","title":"Sites","text":"","category":"section"},{"location":"manual/lattice/#Custom-UnitCell","page":"Defining the lattice","title":"Custom UnitCell","text":"","category":"section"},{"location":"manual/lattice/#Shapes","page":"Defining the lattice","title":"Shapes","text":"","category":"section"},{"location":"manual/lattice/#Boundary-conditions","page":"Defining the lattice","title":"Boundary conditions","text":"","category":"section"},{"location":"manual/evolution/#Evolution","page":"Unitary evolution","title":"Evolution","text":"","category":"section"},{"location":"manual/evolution/#Basics","page":"Unitary evolution","title":"Basics","text":"","category":"section"},{"location":"manual/evolution/#Solvers","page":"Unitary evolution","title":"Solvers","text":"","category":"section"},{"location":"manual/evolution/#TimeSequence","page":"Unitary evolution","title":"TimeSequence","text":"","category":"section"},{"location":"library/#Internals","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-basics","page":"Library","title":"Lattice basics","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/lattice.jl\", \"lattices/genericlattice.jl\", \"lattices/bravais/unitcell.jl\", \n    \"lattices/bravais/lattice.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractLattice, LatticeModels.AbstractSite)","category":"page"},{"location":"library/#LatticeModels.IncompatibleLattices","page":"Library","title":"LatticeModels.IncompatibleLattices","text":"IncompatibleLattices([header, ]lat1, lat2)\n\nAn exception thrown when two lattices are incompatible.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteProperty","page":"Library","title":"LatticeModels.SiteProperty","text":"SiteProperty\n\nAn abstract type for a property of a site.\n\nThis interface is used to define various properties of a site. They can be accessed using getsiteproperty. This interface is used in following places:\n\nlattice[...] syntax to access sites with specific properties.\nlattice_value[...] syntax to access values defined on sites with specific properties.\nFunctions to generate LatticeValues and operators for specific properties.\n\nExamples\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(3, 3);\n\njulia> l[x = 1, y = 2]          # Get site with x = 1 and y = 2\n2-dim Bravais lattice site in 2D space at [1.0, 2.0]\n\njulia> l[x = 1]                 # Get sublattice with x = 1\n3-site 2-dim Bravais lattice in 2D space\nUnit cell:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\nLattice type: SquareLattice{2}\nDefault translations:\n  :axis1 → Bravais[3, 0]\n  :axis2 → Bravais[0, 3]\nNearest neighbor hoppings:\n  1.00000 =>\n    Bravais[1, 0]\n    Bravais[0, 1]\n  1.41421 =>\n    Bravais[1, -1]\n    Bravais[1, 1]\n  2.00000 =>\n    Bravais[2, 0]\n    Bravais[0, 2]\nBoundary conditions: none\n\njulia> l[x = 1, y = 2, z = 3]   # No site with defined z property on a 2D lattice\nERROR: ArgumentError: Invalid axis index 3 of a 2-dim site\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.check_issublattice-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.check_issublattice","text":"Checks if l1 is sublattice of l2. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samelattice-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samelattice","text":"Checks if l1 and l2 objects are defined on the same lattice. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samesites-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samesites","text":"Checks if l1 and l2 objects are defined on the same sites. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.lattice","text":"lattice(any)\n\nReturn the lattice of the given object (an operator, LatticeValue, ...)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_index","page":"Library","title":"LatticeModels.site_index","text":"site_index(lat, site[, range])\n\nReturn the index of the site in the lattice lat. If range is given, only search in the given range. Return nothing if the site is not found.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.GenericLattice","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice{SiteT}\n\nA generic lattice of SiteT sites.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = GenericLattice{2}()\n0-site 2-dim GenericLattice{GenericSite{2}}\n\njulia> push!(l, GenericSite(0, 0))  # Add a site at (0, 0)\n1-site 2-dim GenericLattice{GenericSite{2}}:\n  Site at [0.0, 0.0]\n\njulia> push!(l, (0, 1))             # Add a site at (0, 1)\n2-site 2-dim GenericLattice{GenericSite{2}}:\n  Site at [0.0, 0.0]\n  Site at [0.0, 1.0]\n\njulia> push!(l, [1, 0])             # Add a site at (1, 0)\n3-site 2-dim GenericLattice{GenericSite{2}}:\n  Site at [0.0, 0.0]\n  Site at [0.0, 1.0]\n  Site at [1.0, 0.0]\n\njulia> l[2]\n2-dim GenericSite{2} at [0.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.GenericLattice-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice(lat)\n\nConstructs a GenericLattice from some other lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{N}} where N","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice{N}()\n\nConstructs an empty N-dimensional GenericLattice of GenericSites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{SiteT}} where SiteT<:LatticeModels.AbstractSite","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice{SiteType}()\n\nConstructs an empty GenericLattice of SiteType sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericSite","page":"Library","title":"LatticeModels.GenericSite","text":"GenericSite{N}\n\nA generic site in an N-dimensional lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisSite","page":"Library","title":"LatticeModels.BravaisSite","text":"BravaisSite{N,NU,B}\n\nA site of a BravaisLattice{N,NU,B} lattice.\n\nFields\n\nunitcell: a UnitCell object representing the lattice unit cell.\nlatcoords: a SVector of size N representing the lattice coordinates of the site.\nbasindex: an Int representing the index of the site in the lattice basis.\ncoords: a SVector of size N representing the spatial coordinates of the site.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.UnitCell","page":"Library","title":"LatticeModels.UnitCell","text":"UnitCell(translations[, basis; offset, rotate])\n\nConstructs a Bravais lattice unit cell with given translation vectors and locations of basis sites.\n\nArguments\n\ntranslations: an AbstractMatrix of size N×N representing the translation vectors of the lattice.\nbasis: an AbstractMatrix of size N×NB representing the locations of basis sites.   If not provided, the lattice basis will consist of one site located in the bottom-left corner of the unit cell.\n\nKeyword arguments\n\noffset: a keyword argument that specifies how to shift the lattice basis.   Possible values:\n:origin: no shift (default).\n:center: shift the lattice so that the center of the basis is at the origin of the unit cell.\n:centeralign: shift the lattice so that the center of the basis is at the center of the unit cell.\nAlso accepts an AbstractVector of size N to shift the lattice by a custom vector.\nrotate: a keyword argument that specifies how to rotate the lattice basis.   Possible values:\nnothing: no rotation (default).\nAn AbstractMatrix of size N×N to rotate the lattice.\nA Real number to rotate the lattice by this angle in radians.\nAlso accepts an AbstractMatrix of size N×N to rotate the lattice basis.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{<:Integer, <:Integer}}, NU}}} where {N, NU, NB}","page":"Library","title":"LatticeModels.span_unitcells","text":"span_unitcells([f, ]unitcell, dims...[; boundaries, offset])\n\nConstruct a Bravais lattice by spanning unitcell in dims dimensions, filtered by f.\n\nArguments\n\nf: a function that defines if the site is included in the lattice. Takes a BravaisSite, returns a Bool.\nunitcell: a UnitCell object.\ndims: a list of Integers or Ranges specifying the size of the lattice in each dimension.\n\nKeyword arguments\n\ndefault_translations: a list of BravaisTranslations to add to the lattice as default boundary condition axes.\nboundaries: a BoundaryConditions object specifying the boundary conditions of the lattice.\nrmdup: a Bool specifying whether to remove sites that are equivalent after applying the boundary conditions.\noffset: the offset of the lattice from the origin. See UnitCell for details.\nrotate: a rotation matrix to apply to the lattice. See UnitCell for details.\n\nKeep in mind that the offset and rotation are applied to the unit cell before the lattice is spanned (and f is applied). To apply them after the lattice is spanned, use the postoffset and postrotate keywords.\n\nExamples\n\njulia> using LatticeModels\n\njulia> using LatticeModels\n\njulia> uc = UnitCell([[1, 0] [0, 1]])\n1-site Unit cell of a 2-dim Bravais lattice in 2D space:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\n\njulia> span_unitcells(uc, 3, 3) == SquareLattice(3, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-constructors","page":"Library","title":"Lattice constructors","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"zoo/lattices.jl\", \"zoo/shapes.jl\"]","category":"page"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nRepresents a honeycomb lattice.\n\nLattice vectors: [1, 0] and [0.5, √3/2], two sites at [0, 0] and [0.5, √3/6] in each unit cell.\n\n\n\nHoneycombLattice(a, b)\n\nConstruct a honeycomb lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.KagomeLattice","page":"Library","title":"LatticeModels.KagomeLattice","text":"KagomeLattice\n\nRepresents a kagome lattice.\n\nLattice vectors: [1, 0] and [0.5, √3/2], three sites at [0, 0], [0.5, 0] and [0.25, √3/4] in each unit cell.\n\n\n\nKagomeLattice(a, b)\n\nConstruct a kagome lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nRepresents a square lattice in N dimensions.\n\n\n\nSquareLattice(sz...)\n\nConstruct a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TriangularLattice","page":"Library","title":"LatticeModels.TriangularLattice","text":"TriangularLattice\n\nRepresents a triangular lattice. Lattice vectors: [1, 0] and [0.5, √3/2].\n\n\n\nTriangularLattice(a, b)\n\nConstruct a triangular lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Chain-Tuple{Function, Any}","page":"Library","title":"LatticeModels.Chain","text":"Chain(sz)\n\nConstruct a 1D chain lattice of size sz.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GrapheneRibbon","page":"Library","title":"LatticeModels.GrapheneRibbon","text":"GrapheneRibbon(len, wid[, center; kw...])\n\nConstruct a graphene ribbon sample with zigzag edges. To get armchair edges, simply rotate the lattice by 90 degrees.\n\nArguments\n\nlen: the length of the ribbon.\nwid: the width of the ribbon.\ncenter: the unit cell coordinates of the bottom-left corner of the ribbon. Default is (0, 0).\n\nAll other keyword arguments are passed to span_unitcells (see its documentation for details).\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.@bravaisdef-Tuple{Any, Any}","page":"Library","title":"LatticeModels.@bravaisdef","text":"@bravaisdef MyBravaisLattice UnitCell(...)\n@bravaisdef MyBravaisLattice N -> UnitCell(...)\n\nDefine a new Bravais lattice type MyBravaisLattice with a unit cell constructor UnitCell(expr). If the notation is N -> UnitCell(expr), the unit cell constructor will be dependent on the dimensionality N. otherwise, the dimensionality will be inferred from the unit cell. N is the dimensionality of the lattice.\n\nExamples\n\njulia> using LatticeModels\n\njulia> @bravaisdef MyBravaisLattice UnitCell([1 0; 0 1]);   # 2D square lattice\n\njulia> MyBravaisLattice(3, 3)\n9-site 2-dim Bravais lattice in 2D space\nUnit cell:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\nLattice type: MyBravaisLattice\nDefault translations:\n  :axis1 → Bravais[3, 0]\n  :axis2 → Bravais[0, 3]\nNearest neighbor hoppings:\n  1.00000 =>\n    Bravais[1, 0]\n    Bravais[0, 1]\n  1.41421 =>\n    Bravais[1, -1]\n    Bravais[1, 1]\n  2.00000 =>\n    Bravais[2, 0]\n    Bravais[0, 2]\nBoundary conditions: none\n\n\n\n\n\n","category":"macro"},{"location":"library/#LatticeModels.BallND","page":"Library","title":"LatticeModels.BallND","text":"BallND{N}([radius, center])\n\nConstruct a N-dimensional ball with a given radius and center. Note the aliases: Circle and Ball are BallND{2} and BallND{3} respectively.\n\nArguments\n\nradius: The radius of the ball.\ncenter: The center of the ball.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Path","page":"Library","title":"LatticeModels.Path","text":"Path(start, stop)\n\nConstruct a path from start to stop.\n\nArguments\n\nstart: The start of the path.\nstop: The end of the path.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Polygon","page":"Library","title":"LatticeModels.Polygon","text":"Polygon{N}([radius, center])\nPolygon{N}([center; h])\n\nConstruct a regular N-sided polygon with a given (circumscribed) radius and center. Note the aliases: Triangle, Square, and Hexagon are Polygon{3}, Polygon{4}, and Polygon{6} respectively.\n\nArguments\n\nradius: The (circumscribed) radius of the polygon.\ncenter: The center of the polygon.\n\nKeyword Arguments\n\nh: The distance from the center to the vertices. If given, the radius is calculated as h / cos(pi / N).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Rectangle","page":"Library","title":"LatticeModels.Rectangle","text":"Rectangle(w, h)\n\nConstruct a rectangle with given horizontal and vertical intervals. Usage: Rectangle(1..3, 2..4).\n\nArguments\n\nw: The horizontal range.\nh: The vertical range.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteAt","page":"Library","title":"LatticeModels.SiteAt","text":"SiteAt(coords)\n\nRepresents a single site at the given coordinates.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.removedangling!-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.removedangling!","text":"removedangling!(lat[; maxdepth])\n\nRemove dangling sites from the lattice. A site is considered dangling if it has less than 2 neighbors. The function will remove all dangling sites and their neighbors recursively up to maxdepth levels.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.shaperadius-Tuple{UnitCell, LatticeModels.AbstractShape, Int64}","page":"Library","title":"LatticeModels.shaperadius","text":"shape_radius(unitcell, shape, sites)\nshape_radius(lat, shape)\n\nCalculate the radius of a shape such that it contains appriximately sites sites.\n\nArguments\n\nunitcell: The UnitCell of the lattice. Might also be a lattice type.\nlat: The lattice. It is considered that the lattice was constructed in the same shape.\nshape: The shape to calculate the radius for.\nsites: The number of sites the shape should contain.\n\n\n\n\n\n","category":"method"},{"location":"library/#Bonds","page":"Library","title":"Bonds","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/bonds.jl\", \"lattices/bravais/bonds.jl\", \"lattices/bravais/nearestneighbor.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractBonds, LatticeModels.AbstractTranslation, \n    LatticeModels.DirectedBonds)","category":"page"},{"location":"library/#LatticeModels.AdjacencyMatrix","page":"Library","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix{LT} where {LT<:Lattice}\n\nRepresents the bonds on some lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteDistance","page":"Library","title":"LatticeModels.SiteDistance","text":"SiteDistance(f, lat)\n\nA bonds type that connects sites based on the distance between them.\n\nArguments\n\nf: A function that takes a distance and returns if the distance is allowed.\nlat: The lattice where the bonds are defined.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Translation","page":"Library","title":"LatticeModels.Translation","text":"Translation <: AbstractTranslation\n\nA spatial translation on some lattice.\n\nFields\n\nlat: The lattice where the translations are defined.\nR: The vector of the translation.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.UndefinedLattice","page":"Library","title":"LatticeModels.UndefinedLattice","text":"UndefinedLattice\n\nA lattice that is not defined. The bonds can be 'defined' on it in context where the lattice is already defined before, e. g. in construct_operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.adapt_bonds-Tuple{Any, LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.adapt_bonds","text":"adapt_bonds(bonds, lat)\n\nAdapt the bonds to the lattice lat. The output can be a different type of bonds, more fitting for the concrete type of lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.adjacencymatrix-Tuple{LatticeModels.AbstractBonds, Vararg{LatticeModels.AbstractBonds}}","page":"Library","title":"LatticeModels.adjacencymatrix","text":"adjacencymatrix([lat, ]bonds...)\n\nConstructs an adjacency matrix from the bonds. If lat is not provided, it is inferred from the bonds.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.adjacentsites-Tuple{AdjacencyMatrix, LatticeModels.AbstractSite}","page":"Library","title":"LatticeModels.adjacentsites","text":"adjacentsites(bonds, site)\n\nReturns the sites that are connected to site by the bonds.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sitedistance-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}","page":"Library","title":"LatticeModels.sitedistance","text":"sitedistance([lat, ]site1, site2)\n\nReturns the distance between two sites on the lat lattice, taking boundary conditions into account.\n\nArguments\n\nlat: The lattice where the sites are defined.\nsite1 and site2: The sites to measure the distance between.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.Bravais","page":"Library","title":"LatticeModels.Bravais","text":"Bravais[ lattice_coords ]\n\nA convenient constructor for a BravaisTranslation that does not permute sublattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisTranslation","page":"Library","title":"LatticeModels.BravaisTranslation","text":"BravaisTranslation([site_indices, ]translate_uc)\nBravaisTranslation(site_indices)\nBravaisTranslation([site_indices; ]axis[, dist=1])\n\nA convenient constructor for a BravaisTranslation object.\n\nArguments\n\nsite_indices: a ::Int => ::Int pair with indices of sites connected by the bond;\n\nif omitted, the bond connects sites with the same sublattice index.\n\ntranslate_uc: The unit cell offset.\n\nKeyword arguments\n\naxis: The hopping direction axis in terms of unit cell vectors.\ndist: The hopping distance in terms of unit cell vectors.\n\nIf site_indices are equal or undefined and translate_uc is zero, the translation is considered to be a translation of all sites to themselves. An error will be thrown in this case.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisTranslation-2","page":"Library","title":"LatticeModels.BravaisTranslation","text":"BravaisTranslation{T, N}\n\nA struct representing bonds in some direction in a lattice.\n\nNote that though the dimension count for the bond is static, it is automatically compatible with higher-dimensional lattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NearestNeighbor","page":"Library","title":"LatticeModels.NearestNeighbor","text":"NearestNeighbor(lat[, N=1])\n\nReturns the nearest neighbor bonds of order N for the lattice lat.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = HoneycombLattice(5, 5);\n\njulia> NearestNeighbor(lat)\nBravaisSiteMapping with 3 translations:\n  1 => 2, [0, -1]\n  1 => 2, [-1, 0]\n  1 => 2, [0, 0]\n on 50-site 2-dim Bravais lattice in 2D space (2-site basis)\n\njulia> lat = SquareLattice(3, 3, 3, 3);\n\njulia> NearestNeighbor(lat, 4)\nBravaisSiteMapping with 12 translations:\n  Bravais[1, -1, -1, -1]\n  Bravais[1, 1, -1, -1]\n  Bravais[1, -1, 1, -1]\n  Bravais[1, 1, 1, -1]\n  Bravais[2, 0, 0, 0]\n  Bravais[0, 2, 0, 0]\n  Bravais[0, 0, 2, 0]\n  Bravais[1, -1, -1, 1]\n  Bravais[1, 1, -1, 1]\n   ⋮\n on 81-site 4-dim Bravais lattice in 4D space\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NearestNeighbor-2","page":"Library","title":"LatticeModels.NearestNeighbor","text":"NearestNeighbor{N}\n\nA bonds type that connects sites that are nearest neighbors of order N on some lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.getnnbonds-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.getnnbonds","text":"getnnbonds(lat)\n\nReturns the nearest neighbor bonds of the lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#Boundary-conditions","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/boundaries.jl\"]","category":"page"},{"location":"library/#LatticeModels.BoundaryConditions","page":"Library","title":"LatticeModels.BoundaryConditions","text":"BoundaryConditions\n\nA collection of boundary conditions for a lattice.\n\nFields\n\nbcs: A tuple of boundary conditions.\ndepth: The upper limit of the depth of the boundary conditions (used for routing).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.FunctionBoundary","page":"Library","title":"LatticeModels.FunctionBoundary","text":"FunctionBoundary <: Boundary\n\nA boundary condition with a function that returns the phase factor for a given site. The boundary condition is encoded in form ψ(x + R) = f(x)ψ(x), where f(x) is the function and R is the translation vector.\n\n\n\nFunctionBoundary(f, translation)\n\nConstruct a FunctionBoundary with a given function and translation.\n\nArguments\n\nf: The function that returns the phase factor for a given site.\ntranslation: The translation vector of the boundary representad as AbstractTranslation.   If an array is passed, it is converted to Translation automatically.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TwistedBoundary","page":"Library","title":"LatticeModels.TwistedBoundary","text":"TwistedBoundary <: Boundary\n\nA boundary condition with a phase twist. A PeriodicBoundary is a special case of TwistedBoundary with zero twist.\n\n\n\nTwistedBoundary(translation, Θ)\n\nConstruct a TwistedBoundary with a given translation and twist angle.\n\nArguments\n\ntranslation: The translation vector of the boundary representad as AbstractTranslation.   If an array is passed, it is converted to Translation automatically.\nΘ: The twist angle in radians.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PeriodicBoundary-Tuple{Any}","page":"Library","title":"LatticeModels.PeriodicBoundary","text":"PeriodicBoundary(translation)\n\nConstruct a PeriodicBoundary with a given translation.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.setboundaries-Tuple{LatticeModels.AbstractLattice, BoundaryConditions}","page":"Library","title":"LatticeModels.setboundaries","text":"setboundaries(lat, boundaries...[; checkboundaries=true, rmdup=false])\n\nSet the boundary conditions for the lattice lat.\n\nArguments\n\nlat: The lattice.\nboundaries: The boundary conditions. It can be a single Boundary or a Tuple of Boundary objects.\n\nKeyword arguments\n\ncheckboundaries: If true, check if the boundary conditions overlap within the lattice sites.\nrmdup: If true, remove duplicate sites from the lattice.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(4, 4);\n\njulia> l2 = setboundaries(l, [4, 0] => true, [0, 4] => pi);\n\njulia> l2.boundaries\nBoundary conditions (depth = 1):\n  Bravais[4, 0] → periodic\n  Bravais[0, 4] → twist θ = 3.14\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.translate_to_nearest-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}","page":"Library","title":"LatticeModels.translate_to_nearest","text":"translate_to_nearest(lat, site1, site2)\n\nTranslate site2 to its equivalent nearest to site1 in the lattice lat, taking the boundary conditions into account.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeValue","page":"Library","title":"LatticeValue","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/latticevalue.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LT}\n\nRepresents a value of type T on a LT lattice.\n\nFields\n\nlattice: the AbstractLattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, AbstractVector}","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue(lat, values)\n\nConstructs a LatticeValue object.\n\nArguments\n\nlat: the lattice the value is defined on.\nvalues: an AbstractVector of values on the lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, LatticeModels.SiteProperty}","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue(lat, prop)\n\nGenerates a LatticeValue representing the site property prop on lattice lat.\n\nArguments\n\nlat: the lattice the value is defined on.\nprop: the SiteProperty to be represented. Can be a SiteProperty or a Symbol defining it.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.brastate-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.brastate","text":"brastate(lv)\n\nConverts a LatticeValue to a Bra wavefunction vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coordvalue-Tuple{LatticeModels.AbstractLattice, Int64}","page":"Library","title":"LatticeModels.coordvalue","text":"coordvalue(lat, coord)\n\nGenerates a LatticeValue representing the spatial coordinate coord on lattice lat.\n\nArguments\n\nlat: the lattice the value is defined on.\ncoord: the coordinate to be represented. Can be an integer or a symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coordvalues-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.coordvalues","text":"coordvalues(lat)\n\nGenerates a tuple of LatticeValues representing spatial coordinates on lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ketstate-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.ketstate","text":"ketstate(lv)\n\nConverts a LatticeValue to a Ket wavefunction vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.project-Tuple{LatticeValue, LatticeModels.SiteProperty}","page":"Library","title":"LatticeModels.project","text":"project(lv, axis)\n\nProjects the lv::LatticeValue along the given axis.\n\nArguments\n\nlv: the LatticeValue to be projected.\naxis: the SiteProperty describing the axis to be projected along.\n\n\n\n\n\n","category":"method"},{"location":"library/#Operators-and-observables","page":"Library","title":"Operators and observables","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"operators/bases.jl\", \"operators/miscoperators.jl\", \"operators/manybody.jl\", \n    \"operators/latticeutils.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeBasis","page":"Library","title":"LatticeModels.LatticeBasis","text":"LatticeBasis <: QuantumOpticsBase.Basis\n\nBasis for a lattice system.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coordoperators-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"Library","title":"LatticeModels.coordoperators","text":"coordoperators(sys)\ncoordoperators(basis)\ncoordoperators(lat[, internal])\n\nGenerate a Tuple of coordinate operators for the given lattice.\n\nArguments\n\nsys: a System for which the coordinate operators are to be generated.\nbasis: a one-particle Basis for which the coordinate operators are to be generated.\nlat: a lattice for which the coordinate operators are to be generated.\ninternal: The basis for the internal degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"library/#QuantumOpticsBase.transition","page":"Library","title":"QuantumOpticsBase.transition","text":"QuantumOpticsBase.transition(sys::System, site1::LatticeSite, site2::LatticeSite[, op; field])\nQuantumOpticsBase.transition(sys::System, i1::Int, i2::Int[, op; field])\n\nGenerate a transition operator between two local states in lattice space. States can be defined by LatticeSites or integers.\n\nStandard rules for functions accepting Systems apply.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.interaction-Tuple{Function, Type{<:Number}, NParticles}","page":"Library","title":"LatticeModels.interaction","text":"interaction(f, [T, ]sys)\n\nCreate an two-site interaction operator for a given NParticles system. The function f takes two arguments, which are the two sites, and returns the interaction energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.interaction-Union{Tuple{K}, Tuple{Function, Type{<:Number}, NParticles, Val{K}}} where K","page":"Library","title":"LatticeModels.interaction","text":"interaction(f, [T, ]sys, K[; affect_internal=true])\n\nCreate an 2K-site interaction operator for a given NParticles system. The function f takes two K-tuples of integer numbers, which are site indices for creation and annihilation operators, and returns the interaction energy.\n\nIf affect_internal is true (default), the interaction operator will act on the internal degrees of freedom as well, and f will take four K-tuples - lattice and internal indices for creation and annihilation operators. If the system has no internal degrees of freedom, affect_internal will automatically be set to false and f will take two K-tuples.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.adjacencymatrix-Tuple{DataOperator{BT, BT} where BT<:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"Library","title":"LatticeModels.adjacencymatrix","text":"adjacencymatrix(op::Operator)\n\nGenerates an AdjacencyMatrix for the provided operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.localdensity-Tuple{Union{DataOperator{var\"#s176\", var\"#s176\"}, Bra{var\"#s176\"}, Ket{var\"#s176\"}} where var\"#s176\"<:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"Library","title":"LatticeModels.localdensity","text":"localdensity(state)\n\nCompute the local density of given state. The result is a LatticeValue with the same lattice as the input state.\n\nArguments\n\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/#Hamiltonians","page":"Library","title":"Hamiltonians","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"operators/system.jl\", \"operators/builder.jl\", \"operators/constructoperator.jl\",\n    \"operators/magneticfield.jl\", \"zoo/magneticfields.jl\"]","category":"page"},{"location":"library/#LatticeModels.NParticles-Union{Tuple{SampleT}, Tuple{SampleT, Any}} where SampleT<:LatticeModels.Sample","page":"Library","title":"LatticeModels.NParticles","text":"NParticles(lat[, internal], N[; T=0, statistics=FermiDirac])\nNParticles(sys, N[; T=0, statistics=FermiDirac])\n\nCreate a manybody system with a given lattice and a given number of particles.\n\nArguments\n\nlat: the lattice of the system.\ninternal: The basis for the internal degrees of freedom.\nsys: a one-particle system.\nN: the number of particles in the system.\n\nKeyword Arguments\n\nT: the temperature of the system. Default is 0.\nstatistics: the statistics of the particles. Default is FermiDirac.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(3, 3);\n\njulia> NParticles(lat, 4, statistics=BoseEinstein)\nNParticles(4 bosons) on 9-site 2-dim Bravais lattice in 2D space\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.System-Tuple{LatticeModels.Sample}","page":"Library","title":"LatticeModels.System","text":"System(lat[, internal; T, μ, N, statistics])\n\nCreate a system with a given lattice and optionally internal degrees of freedom.\n\nArguments\n\nlat: the lattice of the system.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword Arguments\n\nT: the temperature of the system. Default is 0.\nμ: the chemical potential of the system. Use mu synonym if Unicode input is not available.\nN: the number of particles in the system.\nstatistics: the statistics of the particles. Default is FermiDirac.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(3, 3);\n\njulia> System(lat)\nOne particle on 9-site 2-dim Bravais lattice in 2D space\n\njulia> System(lat, N=4, statistics=BoseEinstein)\n4 non-interacting bosons on 9-site 2-dim Bravais lattice in 2D space\n\njulia> System(lat, mu=0, statistics=BoseEinstein)\nNon-interactng bosons with fixed μ=0.0 on 9-site 2-dim Bravais lattice in 2D space\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sample-Tuple{LatticeBasis}","page":"Library","title":"LatticeModels.sample","text":"Returns the Sample of the object.\n\nDefine this function for your type to implement Sample API.\n\ninfo: Info\nThis function can be considered stable internal API. Feel free to use it in your packages.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.OperatorBuilder","page":"Library","title":"LatticeModels.OperatorBuilder","text":"OperatorBuilder\n\nA helper struct for building custom operators. This struct is used to build operators for a given system or lattice.\n\nExample\n\nl = SquareLattice(5, 5)\nbuilder = OperatorBuilder(l, field=LandauGauge(0.1), auto_hermitian=true)\nxhop = Bravais[1, 0]\nyhop = Bravais[0, 1]\nfor site in l\n    x, y = site\n    builder[site, site] = x + 2y\n    builder[site, site + xhop] = 1\n    builder[site, site + yhop] = 1im\n    site2 = l[rand(1:25)]\n    builder[site, site2] += 1\nend\nH = Hamiltonian(builder)\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.OperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{<:Number}, SystemT}} where {SystemT<:System, FieldT<:LatticeModels.AbstractField}","page":"Library","title":"LatticeModels.OperatorBuilder","text":"OperatorBuilder([T, ]sys, [; field=NoField(), auto_hermitian=false])\nOperatorBuilder([T, ]lat, [internal; field=NoField(), auto_hermitian=false])\n\nConstruct an OperatorBuilder for a given system or lattice.\n\nArguments\n\nT: The type of the matrix elements. Defaults to ComplexF64.\nsys: A System object representing the system.\nlat: The lattice on which the operator is defined.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword arguments\n\nfield: The gauge field to use for the bond operators.\nauto_hermitian: Whether to automatically add the hermitian conjugate of the operator. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.FastOperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{<:Number}, SystemT}} where {SystemT<:System, FieldT<:LatticeModels.AbstractField}","page":"Library","title":"LatticeModels.FastOperatorBuilder","text":"FastOperatorBuilder([T, ]sys, [; field=NoField(), auto_hermitian=false])\nFastOperatorBuilder([T, ]lat, [internal; field=NoField(), auto_hermitian=false])\n\nConstruct an OperatorBuilder for a given system or lattice. This version of the constructor uses a slightly faster internal representation of the operator matrix, but only allows increment/decrement assignments. builder[site1, site2] += 1 is allowed, but builder[site1, site2] = 1 is not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.construct_hamiltonian-Tuple{Type, System, Vararg{Any}}","page":"Library","title":"LatticeModels.construct_hamiltonian","text":"construct_hamiltonian([T, ]sys, terms...[; field])\nconstruct_hamiltonian([T, ]lat[, internal, terms...; field])\n\nConstruct a Hamiltonian for the given system. Does the same as construct_operator, but wraps the result in a Hamiltonian type.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.construct_operator-Tuple{Type, System, Vararg{Any}}","page":"Library","title":"LatticeModels.construct_operator","text":"construct_operator([T, ]sys, terms...[; field])\nconstruct_operator([T, ]lat[, internal, terms...; field])\n\nConstruct an operator for the given system.\n\nEach of the terms describes a term of the Hamiltonian. The term can be given in several ways:\n\nA DataOperator on the lattice, internal or composite basis (will be matched automatically).\nA Pair of an \"internal\" and an \"on-lattice\" part (e.g. int_p => lat_p):\nThe \"internal\" part can be a DataOperator, a matrix or a number.\nThe \"on-lattice\" part can be a LatticeValue (represents a diagonal term), a site\n(represents a local on-site potential), a bond (represents a hopping term) or a site1 => site2   pair (represents a single hopping).\nIdentity \"internal\" or \"on-lattice\" parts can be omitted.\n\nSee documentation for more details.\n\nArguments\n\nT: The element type of the Hamiltonian. Default is ComplexF64.\nsys: The System for which the Hamiltonian is constructed.\nlat: The lattice for which the Hamiltonian is constructed.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword Arguments\n\nfield: The gauge field to use for the bond operators. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.tightbinding_hamiltonian-Tuple{Type, System, Vararg{Any}}","page":"Library","title":"LatticeModels.tightbinding_hamiltonian","text":"tightbinding_hamiltonian([T, ]sys[, args...; t1=1, t2=0, t3=0, field])\ntightbinding_hamiltonian([T, ]lat[, internal, args...; t1=1, t2=0, t3=0, field])\n\nConstruct a tight-binding Hamiltonian for the given system.\n\nArguments\n\nT: The element type of the Hamiltonian. Default is ComplexF64.\nsys: The System for which the Hamiltonian is constructed.\nlat: The lattice for which the Hamiltonian is constructed.\ninternal: The basis for the internal degrees of freedom.\n\nAll other arguments are interpreted as terms of the Hamiltonian and passed to construct_hamiltonian.\n\nKeyword Arguments\n\nt1, t2, t3: The hopping amplitudes for the nearest, next-nearest, and next-next-nearest   neighbors, respectively.\nfield: The gauge field to use for the bond operators. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GaugeField","page":"Library","title":"LatticeModels.GaugeField","text":"GaugeField <: AbstractField\n\nA gauge field defined by a vector potential function.\n\n\n\nGaugeField(func; n)\n\nCreate a gauge field with a given vector potential function func.\n\nArguments\n\nfunc: a function that takes a point in space and returns the vector potential at this point as a SVector or Tuple.\nn: the number of steps to use in the trapezoidal rule integration.\n\nExample\n\nfield = GaugeField(n = 10) do p\n    (-0.5 * p[2], 0.5 * p[1], 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LineIntegralGaugeField","page":"Library","title":"LatticeModels.LineIntegralGaugeField","text":"LineIntegralGaugeField <: AbstractField\n\nA gauge field defined by a line integral function.\n\n\n\nLineIntegralGaugeField(func)\n\nCreate a gauge field with a given line integral function func. The function should take two points in space and return the line integral of the vector potential between these points.\n\nExample\n\nfield = LineIntegralGaugeField() do p1, p2\n    0.5 * (p2[1] - p1[1]) * (p2[2] + p1[2]) # A = [-y/2, x/2, 0]\nend\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NoField","page":"Library","title":"LatticeModels.NoField","text":"NoField <: AbstractField\n\nA stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}","page":"Library","title":"LatticeModels.line_integral","text":"line_integral(field, p1, p2[, n_steps=1])\n\nCalculates the int_p1^p2 overrightarrowA cdot overrightarrowdl integral using the trapezoidal rule. Increase n_steps to improve accuracy (note that for linear field gauges like Landau or symmetrical the formula is already pefrectly accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}","page":"Library","title":"LatticeModels.vector_potential","text":"vector_potential(field, point)\n\nReturns vector potential overrightarrowA for field in location point.\n\nThis function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.LandauGauge","page":"Library","title":"LatticeModels.LandauGauge","text":"LandauGauge <: AbstractField\n\nAn object representing Landau gauge uniform magnetic field along z-axis.\n\nFields\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PointFlux","page":"Library","title":"LatticeModels.PointFlux","text":"PointFlux{GaugeT} <: AbstractField\n\nAn object representing a small magnetic flux through given point. The field is directed along z-axis.\n\nFields\n\nflux: The magnetic flux value.\npoint: A Tuple of x and y coordinates of the point.\n\n\n\nPointFlux(flux, [point; gauge])\n\nConstruct a PointFlux object with given flux and point.\n\nThe optional gauge argument can be used to specify the gauge of the field. Possible values are :axial (A(r) = B times fracrr) and :singular (the the phase changes if the particle passes below the point). The default is :axial.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SymmetricGauge","page":"Library","title":"LatticeModels.SymmetricGauge","text":"SymmetricGauge <: AbstractField\n\nAn object representing symmetrically gauged uniform magnetic field along z-axis.\n\nFields\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#Built-in-models","page":"Library","title":"Built-in models","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"zoo/models.jl\"]","category":"page"},{"location":"library/#LatticeModels.bosehubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}","page":"Library","title":"LatticeModels.bosehubbard","text":"bosehubbard([type, ]lat, N[; U, T, t1, t2, t3, field])\n\nhatH = sum_ij^textsites t_ij c^dagger_i c_j + sum_i^textsites fracU2 hatn_i (hatn_i - 1)\n\nGenerates a Bose-Hubbard model hamiltonian on given lattice lat.\n\nArguments\n\ntype: The element type of the resulting operator. Default is ComplexF64.\nN: The number of particles.\n\nKeyword arguments\n\nt1, t2, t3 denote the coefficient on first, second and third hoppings respectively.   By default t1 is equal to one, the rest are zero.\nU: The interaction strength. Default is zero.\nT: The temperature of the system. Default is zero.\nfield: The magnetic field. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.fermihubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}","page":"Library","title":"LatticeModels.fermihubbard","text":"fermihubbard([type, ]lat, N[; U, T, t1, t2, t3, field])\n\nhatH = sum_ij^textsites t_ij c^dagger_i c_j + sum_i^textsites fracU hatn_i^ hatn_i^\n\nGenerates a Fermi-Hubbard model hamiltonian on given lattice lat.\n\nArguments\n\ntype: The element type of the resulting operator. Default is ComplexF64.\nN: The number of particles.\n\nKeyword arguments\n\nt1, t2, t3 denote the coefficient on first, second and third hoppings respectively.   By default t1 is equal to one, the rest are zero.\nU: The interaction strength. Default is zero.\nT: The temperature of the system. Default is zero.\nfield: The magnetic field. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.haldane","page":"Library","title":"LatticeModels.haldane","text":"haldane(lat, t1, t2[, m=0; T, μ, field, statistics])\n\nhatH = sum_i^textsublattice A m c^dagger_i c_i + sum_j^textsublattice B m c^dagger_j c_j + sum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) + sum_i j^text2-connectedcounter-clockwise left( i cdot t_2 c^dagger_i c_j + h c right)\n\nGenerates a Haldane topological insulator hamiltonian operator on given lattice lat.\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.kanemele-Tuple{System, Real, Real}","page":"Library","title":"LatticeModels.kanemele","text":"kanemele(lat, t1, t2[; T, μ, field, statistics])\n\nhatH = sum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) + sum_i j^text2-connectedcounter-clockwise left( i cdot t_2 c^dagger_i σ_z c_j + h c right)\n\nGenerates a Kane-Mele hamiltonian operator on given lattice lat.\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use keyword mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.qwz-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.qwz","text":"qwz(m[; T, μ, field, statistics])\nqwz(lat[, m; T, μ, field, statistics])\n\nhatH = sum_i^textsites m_i c^dagger_i sigma_z c_i + sum_i^textsites left( c^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + c^dagger_i + haty fracsigma_z - i sigma_y2 c_i + h c right)\n\nGenerates a QWZ model hamiltonian operator on given square lattice lat.\n\nArguments\n\nm (either a LatticeValue or a number) defines the m_i factors\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"method"},{"location":"library/#Diagonalization","page":"Library","title":"Diagonalization","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"spectrum.jl\"]","category":"page"},{"location":"library/#LatticeModels.Eigensystem","page":"Library","title":"LatticeModels.Eigensystem","text":"Eigensystem{LT, MT} where {LT<:AbstractLattice, MT<:AbstractMatrix}\n\nEigenvalues and eigenvectors for some operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{<:LatticeModels.FixedMu}}","page":"Library","title":"LatticeModels.densitymatrix","text":"densitymatrix(eig::Eigensystem[; T=0, μ, N, statistics, info=true])\n\nCreates an Operator representing a equilibrium density matrix, given the eigensystem eig of the Hamiltonian.\n\nThe resulting distribution will be Fermi-Dirac or Bose-Einstein if the statistics is specified, otherwise the Gibbs distribution will be used.\n\nKeyword arguments\n\nT is the temperature of the system. Default is zero.\nμ is the chemical potential. Use mu as a synonym if Unicode input is not available.\nN is the number of particles. If specified, the chemical potential is found automatically.\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\ninfo is a boolean flag to enable/disable logging. Default is true.\n\nNote that if eig is a diagonalized Hamiltonian, the μ, N and statistics parameters are inserted automatically.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diagonalize-Tuple{Hamiltonian, Val}","page":"Library","title":"LatticeModels.diagonalize","text":"diagonalize(op::DataOperator[, routine; params...])\n\nFinds eigenvalues and eigenvectors for a Operator and stores them in an Eigensystem.\n\nTwo routines are available:\n\n:lapack uses the eigen function from the standard LinearAlgebra package.\n:krylovkit uses the Lanczos algorithm from the KrylovKit package.   Accepts following parameters:\nv0 is the starting vector. Default is rand(ComplexF64, size(op.data, 1)).\nn is the target number of eigenvectors. Default is 10.\nAll other keyword arguments are passed to the KrylovKit.eigsolve function. See its documentation for details.\n:auto automatically selects the routine based on the size of the operator.\n\nThe default routine is :lapack for dense operators. If the operator matrix is less than 5000×5000, it is automatically converted to a dense operator. In other cases :krylovkit is used.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.findgroundstate-Tuple{LatticeModels.HamiltonianEigensystem}","page":"Library","title":"LatticeModels.findgroundstate","text":"findgroundstate(eig::HamiltonianEigensystem)\nfindgroundstate(ham::Hamiltonian)\n\nFinds the ground state of a Hamiltonian. Returns the energy and the state.\n\nExample\n\neig = diagonalize(ham)\nE, ψ = findgroundstate(eig)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.groundstate-Tuple{Any}","page":"Library","title":"LatticeModels.groundstate","text":"groundstate(eig::HamiltonianEigensystem)\ngroundstate(ham::Hamiltonian)\n\nFinds the ground state of a Hamiltonian. Returns the state.\n\nExample\n\neig = diagonalize(ham)\nψ = groundstate(eig)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{Any, LatticeModels.AbstractEigensystem}","page":"Library","title":"LatticeModels.projector","text":"projector(f, eig::Eigensystem)\n\nReturns an Operator representing a function applied to the diagonalized operator defined by the formula below:\n\nhatmathcalP = sum_i f(A_i) psi_ipsi_i\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{LatticeModels.AbstractEigensystem}","page":"Library","title":"LatticeModels.projector","text":"projector(eig::Eigensystem)\n\nreturns an Operator that projects onto the eigenvectors of the spectrum, defined by the formula below.\n\nhatmathcalP = sum_i psi_ipsi_i\n\n\n\n\n\n","category":"method"},{"location":"library/#Green's-function","page":"Library","title":"Green's function","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"greenfunction.jl\"]","category":"page"},{"location":"library/#LatticeModels.GreenFunction","page":"Library","title":"LatticeModels.GreenFunction","text":"GreenFunction\n\nA Green's function for a given lattice and Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.diagonalelements-Tuple{LatticeModels.GreenFunctionEval{<:System{<:LatticeModels.Sample{LT, Nothing} where LT}}}","page":"Library","title":"LatticeModels.diagonalelements","text":"diagonalelements(gf::GreenFunctionEval)\n\nReturn the diagonal elements of the Green's function as a LatticeValue.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.dos-Tuple{LatticeModels.AbstractEigensystem, Any}","page":"Library","title":"LatticeModels.dos","text":"dos(eig[, E; broaden])\ndos(gf[, E; broaden])\n\nCalculates the DOS (density of states) for a given eigensystem at energy E. If E is not specified, a function that calculates the DOS at a given energy is returned.\n\nArguments\n\neig is an Eigensystem or HamiltonianEigensystem.\ngf is a GreenFunction.\nE is the energy at which the DOS is calculated.\n\nKeyword arguments\n\nbroaden is the broadening factor for the energy levels, default is 0.1.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.greenfunction-Tuple{Any, Ket, Hamiltonian, Hamiltonian}","page":"Library","title":"LatticeModels.greenfunction","text":"greenfunction(psi0, hamp, hamm[; E₀, tol, kw...])\n\nCalculates the Green's function for a many-body system with a given initial state psi0.\n\nArguments\n\npsi0 is the initial state.\nhamp is the Hamiltonian for the subspace with one more particle than in psi0.\nhamm is the Hamiltonian for the subspace with one less particle than in psi0.\n\nKeyword arguments\n\nE₀ is the energy shift for the Green's function. Default is 0. Use E0 as a synonym   if Unicode input is not available.\ntol is the tolerance for the new eigenvectors. Default is 1e-5.\n\nAll other keyword arguments are passed to the diagonalize function. See its documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.greenfunction-Tuple{Any, LatticeModels.HamiltonianEigensystem{<:LatticeModels.OneParticleBasisSystem}}","page":"Library","title":"LatticeModels.greenfunction","text":"greenfunction(ham_eig::HamiltonianEigensystem)\n\nCreates a Green's function for a given one-body Hamiltonian eigensystem.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ldos-Tuple{GreenFunction, Real}","page":"Library","title":"LatticeModels.ldos","text":"ldos(gf::GreenFunction, E[; broaden])\n\nCalculates the LDOS (local density of states) for a given Green's function at energy E. broaden is the broadening factor for the energy levels, default is 0.1.\n\n\n\n\n\n","category":"method"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"currents.jl\", \"zoo/currents.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractCurrents, LatticeModels.AbstractTranslation)","category":"page"},{"location":"library/#LatticeModels.Currents","page":"Library","title":"LatticeModels.Currents","text":"Currents <: AbstractCurrents\n\nA AbstractCurrents instance that stores values for all currents explicitly.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Currents-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.Currents","text":"Currents(currents[, adjacency_matrix])\n\nCreates a Currents instance for currents.\n\nArguments\n\ncurrents: The AbstractCurrents object to be turned into Currents. That might be time-consuming,   because  this requires evaluation of the current between all pairs.\nadjacency_matrix: If provided, the current will be evaluated only between adjacent sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.DensityCurrents","page":"Library","title":"LatticeModels.DensityCurrents","text":"DensityCurrents <: AbstractCurrents\n\nDensity currents for given density matrix and given hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LocalOperatorCurrents","page":"Library","title":"LatticeModels.LocalOperatorCurrents","text":"LocalOperatorCurrents <: AbstractCurrents\n\nLocal operator (e. g. spin) currents for given density matrix and given hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SubCurrents","page":"Library","title":"LatticeModels.SubCurrents","text":"SubCurrents{CT<:AbstractCurrents} <: AbstractCurrents\n\nA lazy wrapper for a Currents object representing the same currents but on a smaller lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.currentsfrom-Tuple{LatticeModels.AbstractCurrents, Any}","page":"Library","title":"LatticeModels.currentsfrom","text":"currentsfrom(currents, src)\n\nCreate a LatticeValue object with the currents from src region to all other sites.\n\nArguments\n\ncurrents: The AbstractCurrents object to process.\nsrc: The source region. Can be a site/collection of sites or a LatticeValue{Bool} mask.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.currentsfromto","page":"Library","title":"LatticeModels.currentsfromto","text":"currentsfromto(currents, src[, dst])\n\nFinds the total current from src to dst regions. If dst is not provided, the current from src to all other sites is returned.\n\nArguments\n\ncurrents: The AbstractCurrents object to process.\nsrc: The source region.\ndst: The destination region.\n\nBoth src and dst can be a site/collection of sites or a LatticeValue{Bool} mask.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.lattice","text":"Gets the lattice where the given AbstractCurrents object is defined.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.mapgroup_currents-Tuple{Function, Function, LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.mapgroup_currents","text":"mapgroup_currents(f, group, currents[; sort=false, sortpairsby])\n\nFind the current between all possible pairs of sites, apply f to every site pair and group the result by value of f,\n\nArguments\n\nf: This function will be applied to all site pairs. Must accept two AbstractSites.\ngroup: This function will be used to group the current values for pairs with the same mapped value. Must accept a Vector of numbers.\ncurrents: The AbstractCurrents object to process.\n\nKeyword arguments\n\nsortresults: if true, the output arrays will be sorted by results of f.\nsortpairsby: if provided, the sites in each pair will be sorted by this function.   Must accept one AbstractSite; by default the order of the sites in the pair matches   their order in the lattice. The sign of the current will match the site order.\n\n\n\n\n\n","category":"method"},{"location":"library/#Evolution","page":"Library","title":"Evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"evolution.jl\", \"timesequence.jl\"]\nFilter = t -> t ∉ (LatticeModels.SchroedingerSolver,)","category":"page"},{"location":"library/#LatticeModels.CachedExp","page":"Library","title":"LatticeModels.CachedExp","text":"CachedExp(ham[; threshold=1e-10, nonzero_tol=1e-14])\n\nA SchroedingerSolver that finds the matrix exponential of the Hamiltonian and caches it. The matrix exponential is computed using a scaling and squaring method, so this solver works well with sparse or GPU arrays.\n\nArguments\n\nham: The Hamiltonian of the system. It can be an Operator or its matrix.\nthreshold: The threshold for the error in the matrix exponential.\nnonzero_tol: The tolerance for dropping small elements in the matrix exponential if it is   sparse.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Evolution","page":"Library","title":"LatticeModels.Evolution","text":"Evolution([solver, ]hamiltonian, states...; timedomain, namedstates...)\n\nCreate an Evolution object that can be used to evolve states in time according to the Schroedinger equation.\n\nArguments\n\nsolver: A SchroedingerSolver object that will be used to evolve the states. If omitted,   a CachedExp solver will be created.\nhamiltonian: The Hamiltonian of the system. It can be a matrix, a time-dependent operator   or a function that returns the Hamiltonian at a given time.\nstates and namedstates: The states to be evolved. They can be Ket wavefunctions or   DataOperator density matrices.\ntimedomain: The time domain to be used for the evolution. If omitted, the non-iterable Evolution   object will be returned, and you will be able to call it with   the time domain later.\n\nSee SchroedingerSolver for more information about solvers.\n\nwarning: Warning\nPlease note that the Evolution object is a stateful iterator. This means that it keeps track of the current time and the states as they evolve. You can perform evolution multiple times, but the timeline will be kept and the states will be updated in place.Also do not edit the states in place, as this will affect the evolution. If you need to modify the states or save them, make a copy of them first.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.KrylovKitExp","page":"Library","title":"LatticeModels.KrylovKitExp","text":"KrylovKitExp(ham[; kw...])\n\nA SchroedingerSolver that uses the exponentiate function from KrylovKit.jl to evolve the wavefunction vectors. This solver is useful for large, sparse, time-dependent Hamiltonians.\n\nArguments\n\nham: The Hamiltonian of the system. It can be an Operator or its matrix.\nkw...: Keyword arguments to be passed to exponentiate.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}\n\nA time-ordered sequence of values.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(times, values)\n\nConstructs a TimeSequence with the given times and values.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Real, Any}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(value[; t=0])\n\nConstructs a TimeSequence with one single snapshot. The timestamp is zero by default but can be over riden.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Union{Tuple{}, Tuple{ET}} where ET","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}()\n\nConstructs an empty TimeSequence with eltype ET.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.differentiate!","text":"differentiate!(tseq::TimeSequence)\n\nDifferentiate the values stored in tseq by time using the symmetric difference formula. The new values are written into tseq.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.differentiate","text":"differentiate(tseq::TimeSequence)\n\nDifferentiate the values stored in tseq and create a copy; see differentiate!.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.integrate!","text":"integrate!(tseq::TimeSequence)\n\nIntegrate the values stored in tseq over time using the trapezoidal rule. The new values are written into tseq.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.integrate","text":"integrate(tseq::TimeSequence)\n\nIntegrate the values stored in tseq and create a copy; see integrate!.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timerange-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.timerange","text":"timerange(tseq::TimeSequence)\n\nReturns the range of the timestamps of the TimeSequence.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timestamps-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.timestamps","text":"timestamps(tseq::TimeSequence)\n\nReturns the timestamps of the TimeSequence.\n\n\n\n\n\n","category":"method"},{"location":"library/#Internals-2","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"LatticeModels.AbstractLattice\nLatticeModels.AbstractSite\nLatticeModels.AbstractBonds\nLatticeModels.DirectedBonds\nLatticeModels.AbstractTranslation\nLatticeModels.AbstractCurrents\nLatticeModels.LookupTable\nLatticeModels.SchroedingerSolver\nLatticeModels.addlookuptable","category":"page"},{"location":"library/#LatticeModels.AbstractLattice","page":"Library","title":"LatticeModels.AbstractLattice","text":"AbstractLattice{SiteT}\n\nAn abstract type for a lattice of SiteT sites.\n\nMethods for subtypes to implement\n\nlength(l::AbstractLattice): Return the number of sites in the lattice.\nsite_index(l::AbstractLattice, site::SiteT): Return the index of the site in the lattice.\ngetindex(l::AbstractLattice, i::Int): Return the site with the given index.\ngetindex(l::AbstractLattice, is::AbstractVector{Int}): Return an AbstractLattice with the sites at the given indices.\n\nOptional methods for mutable lattices\n\nemptymutable(l::AbstractLattice, ::Type{SiteT}): Return an empty mutable instance of lattice.\ncopymutable(l::AbstractLattice): Return a mutable copy of the lattice.\npush!(l::AbstractLattice, site::SiteT): Add a site to the lattice.\ndeleteat!(l::AbstractLattice, is::AbstractVector{Int}): Remove the sites with the given indices from the lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractSite","page":"Library","title":"LatticeModels.AbstractSite","text":"AbstractSite{N}\n\nAn abstract type for a site of a N-dimensional lattice.\n\nFields\n\ncoords: A SVector of size N representing the spatial coordinates of the site.   All subtypes are expected to have this field.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractBonds","page":"Library","title":"LatticeModels.AbstractBonds","text":"AbstractBonds{LT}\n\nAn abstract type for bonds on some lattice.\n\nMethods for subtypes to implement\n\nlattice(bonds::AbstractBonds): Returns the lattice where the bonds are defined.\nisadjacent(bonds::AbstractBonds, site1::AbstractSite, site2::AbstractSite):   Returns if the sites are connected by the bonds.\n\nOptional methods for subtypes to implement\n\nadapt_bonds(bonds::AbstractBonds, l::AbstractLattice)\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.DirectedBonds","page":"Library","title":"LatticeModels.DirectedBonds","text":"DirectedBonds{LT} <: AbstractBonds{LT}\n\nAn abstract type for bonds on some lattice that have a direction.\n\nMethods for subtypes to implement\n\nlattice(bonds::DirectionalBonds): Returns the lattice where the bonds are defined.\ndestinations(bonds::DirectionalBonds, site::AbstractSite): Returns the sites where the\n\nsite is connected to, accounting for the direction of the bonds.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractTranslation","page":"Library","title":"LatticeModels.AbstractTranslation","text":"AbstractTranslation{LT}\n\nAn abstract type for translations on some lattice.\n\nMethods for subtypes to implement\n\nlattice(bonds::AbstractTranslation): Returns the lattice where the translations are defined.\ndestination(bonds::AbstractTranslation, site::AbstractSite): Returns the site where the site is translated to.\n\nOptional methods for subtypes to implement\n\nadapt_bonds(bonds::AbstractTranslation, l::AbstractLattice):   Adapt the translation to the lattice l. The output can be a different type of   translation, more fitting for the concrete type of lattice.\ninv(bonds::AbstractTranslation): Returns the inverse of the translation, if any.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractCurrents","page":"Library","title":"LatticeModels.AbstractCurrents","text":"AbstractCurrents\n\nSupertype for all type representing currents-like values on a lattice. Subtypes must implement Base.getindex(::Int, ::Int) and lattice functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LookupTable","page":"Library","title":"LatticeModels.LookupTable","text":"LookupTable\n\nA helper data structure to quickly find the index of a site in a lattice.\n\nRelies on sitekey(site) and secondarykey(function) functions to determine the index of a site in the lattice.\n\nWorks well under following assumptions:\n\nThe sitekey is some integer property of the sites.\nThe sites in the lattice are ordered by sitekey.\nThe numbering is mostly contiguous, i.e. there are no (or few) gaps in the numbering.\nThe secondarykey is also integer, mostly contiguous, ordered and unique for all sites with the same sitekey.\n\nSet them to nothing to disable usage.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SchroedingerSolver","page":"Library","title":"LatticeModels.SchroedingerSolver","text":"SchroedingerSolver\n\nAbstract type for solvers that can be used to evolve states in time according to the Schroedinger equation.\n\nSee also concrete implementations: CachedExp, KrylovKitExp.\n\nMethods to implement\n\nupdate_solver!(solver, hamiltonian, dt, force=false): Update the solver to evolve the   states according to the given Hamiltonian and time step. If force is true, the   solver should always update, even if the Hamiltonian and time step are seemingly the   same as the previous ones.\nstep!(solver, state, cache): Evolve the given state in time using the solver. The cache   argument is used to store intermediate results and can be nothing if the solver does   not need it.\nevolution_cache(solver, state): Return a cache object that can be used to store   intermediate results for the given state. Returns nothing if the solver does not need   a cache for the given state (this is the default implementation).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.addlookuptable","page":"Library","title":"LatticeModels.addlookuptable","text":"addlookuptable(lat)\n\nAdds a lookup table to the lattice lat and returns the lattice with the lookup table.\n\nwarning: Warning\nMake sure you add the lookup table to the lattice after you stop making changes to it. Otherwise the results may be unpredictable.This operation is not in-place.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"This section contains the documentation for the internal structure of LatticeModels.jl. ","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"warning: Warning\nThis section of documentation is under construction. Some parts may be incomplete.","category":"page"},{"location":"internals/#Advanced-features","page":"Internals","title":"Advanced features","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These features can be useful in non-trivial cases, but are not necessary for basic usage.","category":"page"},{"location":"internals/#AbstractLattice-interface","page":"Internals","title":"AbstractLattice interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The base of LatticeModels.jl is its interfaces, allowing to define lattices with arbitrary geometry, topology and boundary conditions. The LatticeModels.AbstractLattice interface is the main interface for defining lattices.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Generally speaking, a lattice is a set of sites. Each site, in turn, has its spatial coordinates in its coords field and maybe some additional properties. It also must be a subtype of LatticeModels.AbstractSite.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that the bonds between sites and the boundary conditions are initially not part of the lattice, but are added to its metadata later.","category":"page"},{"location":"internals/#Basic-functions","page":"Internals","title":"Basic functions","text":"","category":"section"},{"location":"internals/#Site-lookup","page":"Internals","title":"Site lookup","text":"","category":"section"},{"location":"internals/#Mutable-lattices","page":"Internals","title":"Mutable lattices","text":"","category":"section"},{"location":"internals/#Site-properties","page":"Internals","title":"Site properties","text":"","category":"section"},{"location":"internals/#Lattice-metadata","page":"Internals","title":"Lattice metadata","text":"","category":"section"},{"location":"internals/#Shapes","page":"Internals","title":"Shapes","text":"","category":"section"},{"location":"internals/#AbstractBonds-interface","page":"Internals","title":"AbstractBonds interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.AbstractBonds interface is used to define different types of bonds between sites. Most generally speaking, such object is a mapping that decides if the sites are connected for each pair.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that there are three basic types of bonds in LatticeModels.jl:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.AbstractBonds: a most general interface. Basically, it is just a mapping from site pairs to boolean values.\nLatticeModels.DirectedBonds: this type of bonds defines a set of bonds that has a defined direction. The whole topology can be defined by the \"destination\" sites for each site. Since the bonds are usually sparse, the general performance of this type of bonds is much higher.\nLatticeModels.AbstractTranslation: this is a subtype of DirectedBonds, where every site has one or zero \"destination\" sites. This allows to increase the performance even more, and also to transform the sites in a convenient manner:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"site1 = lat[!, x = 1, y = 1]    # Get the site at [1, 1]\nT = Translation(lat, [1, 0])    # Translate the site by [1, 0] vector\nsite2 = site1 + T               # `site2` is at [2, 1]","category":"page"},{"location":"internals/#Adapting-bonds-to-the-lattice","page":"Internals","title":"Adapting bonds to the lattice","text":"","category":"section"},{"location":"internals/#Boundary-conditions","page":"Internals","title":"Boundary conditions","text":"","category":"section"},{"location":"internals/#Diagonalizing-the-Hamiltonian","page":"Internals","title":"Diagonalizing the Hamiltonian","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"It is very easy to diagonalize a matrix in Julia. However, problems can arise when the matrix is of some custom type (e. g. sparse or a GPU array). By default LatticeModels.jl makes use of KrylovKit.jl to solve the eigenproblem using the Lanczos algorithm for non-trivial matrix types. However, sometimes it is necessary to use a different algorithm. The LatticeModels.diagonalize_routine is a simple way to add a new algorithm to the default toolchain.","category":"page"},{"location":"internals/#SchroedingerSolvers","page":"Internals","title":"SchroedingerSolvers","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.SchroedingerSolver interface is used to solve the time-dependent Schroedinger equation. It is used in the Evolution struct to perform unitary evolution. As with the diagonalization problem, one can add a new algorithm to the default toolchain by creating a new SchroedingerSolver type.","category":"page"},{"location":"internals/#Currents","page":"Internals","title":"Currents","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.AbstractCurrents interface allows to define different types of currents on the lattice. This allows it to be a lazy object, which computes the currents only when needed.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To implement basic currents semantics, you need to define the following methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.lattice(your_currents): returns the lattice, on which the currents are defined.\nBase.getindex(your_currents, i::Int, j::Int): returns the current between sites with numbers i and j. This is done in such a manner, because you do not usually need the site properties to calculate the currents.","category":"page"},{"location":"manual/greenfunction/#Green's-function","page":"Green's function","title":"Green's function","text":"","category":"section"},{"location":"manual/greenfunction/#Introduction","page":"Green's function","title":"Introduction","text":"","category":"section"},{"location":"manual/greenfunction/#Many-body-Green's-function","page":"Green's function","title":"Many-body Green's function","text":"","category":"section"},{"location":"manual/greenfunction/#Density-of-states","page":"Green's function","title":"Density of states","text":"","category":"section"},{"location":"manual/hamiltonian/#System","page":"Constructing the Hamiltonian","title":"System","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"This section describes how to define the quantum system that will be later worked on.","category":"page"},{"location":"manual/hamiltonian/#Systems","page":"Constructing the Hamiltonian","title":"Systems","text":"","category":"section"},{"location":"manual/hamiltonian/#The-Hamiltonian","page":"Constructing the Hamiltonian","title":"The Hamiltonian","text":"","category":"section"},{"location":"manual/hamiltonian/#The-constructor-function","page":"Constructing the Hamiltonian","title":"The constructor function","text":"","category":"section"},{"location":"manual/hamiltonian/#The-operator-builder","page":"Constructing the Hamiltonian","title":"The operator builder","text":"","category":"section"},{"location":"manual/hamiltonian/#Gauge-fields","page":"Constructing the Hamiltonian","title":"Gauge fields","text":"","category":"section"},{"location":"manual/latticevalue/#LatticeValue","page":"Working with data","title":"LatticeValue","text":"","category":"section"},{"location":"manual/latticevalue/#Basics","page":"Working with data","title":"Basics","text":"","category":"section"},{"location":"manual/latticevalue/#Common-Operations","page":"Working with data","title":"Common Operations","text":"","category":"section"},{"location":"manual/latticevalue/#Broadcasting","page":"Working with data","title":"Broadcasting","text":"","category":"section"},{"location":"manual/latticevalue/#Visualization","page":"Working with data","title":"Visualization","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Lowest-states-in-a-tight-binding-model","page":"Examples","title":"Lowest states in a tight-binding model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The tight-binding model Hamiltonian is defined by this formula (the sum is performed over adjacent sites):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hatH = sum_i j^textsites left( c^dagger_i c_j + h c right)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we take a square lattice and build a Hamiltonian for it. Then we find its eigenstates and plot their local density on heatmaps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\n# Generate a 40x40 square lattice\nl = SquareLattice(40, 40)\n# Define the tight-binding model Hamiltonian\nH = tightbinding_hamiltonian(l)\n\n# Calculate eigenvalues and eigenvectors\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], localdensity(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", st=:shape, \n        clims=clims, c=:inferno, cbar=:none, lw=0, framestyle=:none, xlab=\"\", ylab=\"\")\nend\n\n# The following lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, subplot=n^2+2, \n    background_subplot=:transparent, framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9))\nsavefig(\"local_density.png\")\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Currents-on-a-ring-shaped-sample","page":"Examples","title":"Currents on a ring-shaped sample","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we create a ring-shaped sample of a triangular lattice. Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\n\nl = TriangularLattice(Circle(10), !Circle(5))\nremovedangling!(l)\nh(B) = tightbinding_hamiltonian(l, field=PointFlux(B))\ndiag = diagonalize(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = densitymatrix(diag, mu = 0)\n# Perform unitary evolution\nτ = 10\na = Animation()\nev = Evolution(t -> h(0.1 * min(t, τ) / τ), P_0)\nfor state in ev(0:0.1:2τ)\n    P, H, t = state\n    # Find the density and plot it\n    p = plot(layout=2, size=(1000, 500))\n    plot!(p[1], localdensity(P), clims=(0, 1), st=:shape)\n\n    # Show currents on the plot\n    plot!(p[2], DensityCurrents(H, P), clims=(0, 0.005), lw=1, arrowheadsize=0.3)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"adiabatic_flux.gif\")","category":"page"},{"location":"examples/#Time-sequences","page":"Examples","title":"Time sequences","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will see how to use TimeSequence to store and manipulate time-dependent data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will calculate the evolution of a ground state of a tight-binding model after a magnetic field is turned on. We will store the local density at each time step and use it to plot the local density depending on time, as well as its time derivative and integral over time.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels, Plots\n\nl = SquareLattice(20, 20)\nH = tightbinding_hamiltonian(l)\npsi_0 = groundstate(H)\nH1 = tightbinding_hamiltonian(l, field=LandauGauge(0.1))\nev = Evolution(H1, psi_0)\n\ndensities = TimeSequence{LatticeValue}()\nfor (psi, _, t) in ev(0:0.1:10)\n    densities[t] = localdensity(psi)\nend\n\nsite_bulk = l[!, x = 10, y = 10]\nsite_edge = l[!, x = 10, y = 1]\nds_bulk = densities[site_bulk]\nds_edge = densities[site_edge]\nplot(ds_bulk, label=\"ρ(t) (bulk)\")\nplot!(differentiate(ds_bulk), label=\"dρ(t)/dt (bulk)\")\nplot!(ds_edge, label=\"ρ(t) (edge)\")\nplot!(integrate(ds_edge), label=\"∫ρ(t)dt (edge)\")","category":"page"},{"location":"examples/#Hofstadter-butterfly","page":"Examples","title":"Hofstadter butterfly","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Hofstadter butterfly is a fractal-like structure that appears when the tight-binding model is subjected to a magnetic field. It is a plot of the energy spectrum as a function of the magnetic flux through the unit cell.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To create the Hofstadter butterfly, we will use the Landau gauge for the magnetic field. Note that we have to set periodic boundary conditions, and to make them compatible with the gauge field, they should be tweaked a little:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"psi(x + L_x y) = psi(x y) e^2pi i B y L_x\npsi(x y + L_y) = psi(x y)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let us plot the Hofstadter butterfiles for square, triangular and honeycomb lattices. The magnetic field field will be changed from zero to one phi_0 flux quantum per plaquette.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels, Plots\n\nfunction get_butterfly(l, lx, ly, plaquette_area)\n    xs = Float64[]\n    ys = Float64[]\n    area = lx * ly\n    dflux = 1 / area\n    totflux = 1 / plaquette_area\n    for B in 0:dflux:totflux\n        # magnetic boundary conditions\n        f(site) = exp(2pi * im * B * site.y * lx)\n        lb = setboundaries(l, [lx, 0] => f, [0, ly] => true)\n        H = tightbinding_hamiltonian(lb, field=LandauGauge(B))\n        dg = diagonalize(H)\n        append!(xs, fill(B, length(dg.values)))\n        append!(ys, dg.values)\n    end\n    return xs, ys\nend\n\np = plot(layout = @layout[a b; _ c{0.5w} _], size=(800, 500), leg=false,\n    xlabel=\"B\", ylabel=\"E\")\nscatter!(p[1], title=\"Square lattice\",\n    get_butterfly(SquareLattice(10, 10), 10, 10, 1), ms=1)\nscatter!(p[2], title=\"Triangluar lattice\",\n    get_butterfly(TriangularLattice(10, 10), 10, 5 * sqrt(3), sqrt(3) / 4), ms=1)\nscatter!(p[3], title=\"Honeycomb lattice\",\n    get_butterfly(HoneycombLattice(10, 10), 10, 5 * sqrt(3), sqrt(3) / 2), ms=1)\nsavefig(\"hofstadter_butterfly.png\")\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#LDOS-animation","page":"Examples","title":"LDOS animation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Local density can be a bit ambiguous for degenerate eigenstates. That's where the LDOS (e. g. the Local Density of States) will be helpful.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The formula for the LDOS is the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"textLDOS_alpha(E) = textIm G_alphaalpha(E - idelta)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where G is the Green's function and delta is the broadening.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's create an animation presenting the DOS and LDOS for a square lattice with a hole indside. We will use the QWZ model hamiltonian, because it has a two-zone band structure, which will make the results more interesting. See qwz for more information about the QWZ model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\nl = SquareLattice(20, 20)\nl_center = l[j1 = 8..13, j2 = 8..13]\nsetdiff!(l, l_center)   # remove the center\nH = qwz(l)\n\ndg = diagonalize(H)\nδ = 0.1\nEs = -4:0.1:4\nEs_d = -4:0.01:4\nG = greenfunction(dg)\na = @animate for E in Es\n    print(\"\\rE = $E\") # hide\n    p = plot(layout=2, size=(800, 400))\n    plot!(p[1], Es_d, dos(G, broaden=δ), lab=\"\", title=\"DOS\")\n    vline!(p[1], [E], lab=\"\")\n    plot!(p[2], ldos(G, E, broaden=δ), st=:shape, \n        c=:inferno, clims=(0, NaN), title=\"LDOS\", lw=0)\n    plot!(p, plot_title=\"E = $E, δ = $δ\")\nend\n\ngif(a, \"ldos_animation.gif\", fps=10)","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paste the following line into the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/aryavorskiy/LatticeModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/aryavorskiy/LatticeModels.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Compat\nThis package has tested compatibility with Julia v1.6. Use with caution on lower versions.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry or boundary conditions.\nPowerful operator generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nManybody computations.\nSmart unitary evolution reducing excessive computations where possible.\nSupports visualization with Plots.jl.\nCompatible with QuantumOptics.jl.","category":"page"},{"location":"#Similar-packages","page":"Home","title":"Similar packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Packages such as Quantica.jl, pybinding and Kwant provide similar functionality. However, they are in general designed for other purposes and lack some features that are present in LatticeModels.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Schroedinger equation solvers with time-dependent Hamiltonians. Only Kwant provides similar    functionality with its Tkwant module, but it lacks the performance and flexibility in some cases.\nConvenient tools for setting periodic boundary conditions and gauge fields. The only way to do this in    Kwant or Pybinding is to manually set the hopping values.\nA flexible interface for defining new types of lattices and bonds. Random lattices can be implemented   on top of GenericLattice with ease.\nManybody computations. LatticeModels.jl can handle manybody systems with particle interaction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Overall, while Kwant and pybinding are mostly focused on quantum transport problems and Quantica.jl is designed to find various properties of lattices, LatticeModels.jl focuses on dynamic simulations.","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This simple code plots local density for lowest energy states of a square tight-binding lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels, Plots\n\nl = SquareLattice(40, 40)\nH = tightbinding_hamiltonian(l)\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    # Plot local density on each subplot\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], localdensity(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", st=:shape, \n        clims=clims, c=:inferno, cbar=:none, lw=0, framestyle=:none, xlab=\"\", ylab=\"\")\nend\n\n# The following lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, subplot=n^2+2, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), background_subplot=:transparent)\nsavefig(\"example.png\")\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"See more examples in the Examples section.","category":"page"},{"location":"manual/operators/#States-and-Operators","page":"Operators","title":"States and Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"In this chapter we will learn how to create Hamiltonians and other operators.","category":"page"},{"location":"manual/operators/#Basic-operators","page":"Operators","title":"Basic operators","text":"","category":"section"},{"location":"manual/operators/#Measurements","page":"Operators","title":"Measurements","text":"","category":"section"},{"location":"manual/operators/#Diagonalizing","page":"Operators","title":"Diagonalizing","text":"","category":"section"}]
}

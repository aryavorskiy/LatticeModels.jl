var documenterSearchIndex = {"docs":
[{"location":"currents/","page":"Currents","title":"Currents","text":"TODO","category":"page"},{"location":"library/#LatticeModels.jl","page":"Library","title":"LatticeModels.jl","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-creation","page":"Library","title":"Lattice creation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice.jl\"]","category":"page"},{"location":"library/#LatticeModels.Bravais","page":"Library","title":"LatticeModels.Bravais","text":"Bravais{N, NB}\n\nN-dimensional infinite Bravais lattice with NB sites in basis.\n\n\n\nBravais(translation_vectors[, basis])\n\nConstructs a Bravais lattice with given translation vectors and locations of basis sites relative to some unit cell. The basis argument can be omitted, in which case the lattice basis will consist of one site located in the bottom-left corner of the unit cell.\n\ntranslation_vectors argument must be an AbstractMatrix{<:Real} of size N×N, while basis must also be an  abstract matrix of size N×NB.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nType alias for Lattice{:honeycomb,2,2}.\n\n\n\nHoneycombLattice(sz::Vararg{Int, 2})\n\nConstructs a honeycomb lattice with a sz-size macro cell.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Lattice","page":"Library","title":"LatticeModels.Lattice","text":"Lattice{LatticeSym, N, NB}\n\nA finite subset of a Brvais{N, NB}. LatticeSym is a Symbol which represents the type of the lattice (e. g. :square, :honeycomb). This makes Lattice object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.\n\n\n\nLattice(sym, sz, bvs[, mask])\n\nConstructs a finite Lattice{sym, N, NB} as a subset of the bvs Bravais lattice. sz is a NTuple{N, Int} which represents how many times the unit cell of bvs was translated by each axis - these sites form a macro cell. mask, if defined, is a Vector{Bool} storing information about which of the sites from the macro cell are actually included in the lattice, and which are not.\n\nFor example, a 3×3 square lattice with its center site excluded is represented as Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])\n\nTo define a new type of lattice, create an alias for Lattice{YourSym, YourN, YourNB}. Refer to the docs for detailed explanation.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeSite","page":"Library","title":"LatticeModels.LatticeSite","text":"LatticeSite{N}\n\nA site of a Lattice{LatticeSym, N, NB} lattice. Fields:\n\nunit_cell: a set of translations along all axes representing the unit cell the site is located in.\nbasis_index: the number of site in the lattice basis.\n\nThis type is used to iterate over all sites of a Lattice{LatticeSym, N, NB}. The exact location of a LatticeSite can be found using the coords(lattice, site) function.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nType alias for Lattice{:square,N,1}.\n\n\n\nSquareLattice(sz::Int...)\n\nConstructs a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coords-Tuple{Lattice, LatticeSite}","page":"Library","title":"LatticeModels.coords","text":"coords(lattice::Lattice, site::LatticeSite) -> vector\n\nFinds the location in space of lattice site site on lattice lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.radius_vector-Tuple{Lattice, LatticeSite, LatticeSite}","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(lattice::Lattice, site1::LatticeSite, site2::LatticeSite) -> vector\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macro cell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym","page":"Library","title":"LatticeModels.sublattice","text":"sublattice(lf::Function, l::Lattice) -> Lattice\n\nGenerates a a subset of lattice l by applying the lf function to its sites. The lf function must accept two positional arguments (a LatticeSite and a vector with its coordinates) and return a boolean value.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-values","page":"Library","title":"Lattice values","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_value.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LatticeSym}\n\nRepresents a value of type T on a Lattice{LatticeSym} lattice.\n\nFields:\n\nlattice: the Lattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coord_values-Tuple{Lattice}","page":"Library","title":"LatticeModels.coord_values","text":"coord_values(lattice::Lattice)\n\nGenerates a tuple of LatticeValues representing coordinate functions.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.plot_fallback-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.plot_fallback","text":"plot_fallback(lv::LatticeValue)\n\nCreates a copy of lv lattice value with its LatticeSym overwritten to :uncertain. Use it to invoke the default plot recipe for LatticeValues when defining a custom one.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-operators","page":"Library","title":"Lattice operators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"lattice_operator.jl\"]","category":"page"},{"location":"library/#Hoppings","page":"Library","title":"Hoppings","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hoppings.jl\"]","category":"page"},{"location":"library/#Magnetic-fields","page":"Library","title":"Magnetic fields","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"field.jl\"]","category":"page"},{"location":"library/#Hamiltonian-tools","page":"Library","title":"Hamiltonian tools","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"hamiltonian.jl\"]","category":"page"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"currents.jl\"]","category":"page"},{"location":"library/#Unitary-evolution","page":"Library","title":"Unitary evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"evolution.jl\"]","category":"page"},{"location":"library/#LatticeModels.evolution_operator-Tuple{Any, Real}","page":"Library","title":"LatticeModels.evolution_operator","text":"evolution_operator(H, t[, k])\n\nCalculates the unitary evolution operator using the formula\n\n$ \\mathcal{U}(t) = e^{-\\frac{1}{i\\hbar} \\hat{H} t} $\n\nArguments\n\nH: the hamiltonian matrix\nt: the evolution time\nk: if provided, the exponent will be calculated using a Taylor series expansion with order k\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@evolution-Tuple","page":"Library","title":"LatticeModels.@evolution","text":"@evolution [kwargs...] {rules...} for_loop\n\nGenerates an environment with defined hamiltonian and density matrices that evolve by certain laws. See Unitary evolution for more details.\n\n\n\n\n\n","category":"macro"},{"location":"hamiltonian/","page":"Hamiltonian generation","title":"Hamiltonian generation","text":"TODO","category":"page"},{"location":"plot/","page":"Visualization","title":"Visualization","text":"TODO","category":"page"},{"location":"advanced/","page":"Advanced options","title":"Advanced options","text":"TODO","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"TODO","category":"page"},{"location":"lattice/#Define-a-lattice","page":"Defining a lattice","title":"Define a lattice","text":"","category":"section"},{"location":"lattice/#Simple-Bravais-lattice","page":"Defining a lattice","title":"Simple Bravais lattice","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The simplest variant of a finite Bravais lattice is a macro cell,  which is the lattice basis translated finite number of times along every translation vector.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"using LatticeModels, Plots, LinearAlgebra","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Constructing a macro cell is simple: the lattice constructor accepts positional arguments which will be translation ranges along all dimensions.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Note that lattices of some types can be of any dimensionality, while others can not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"SquareLattice(10, 10)\nSquareLattice(3, 3, 3)\nHoneycombLattice(5, 5)\nHoneycombLattice(3, 3, 2)","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A lattice can be scatter-plotted to see how its sites are located.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"p = plot(size=(800, 350), layout=2)\nplot!(p[1], SquareLattice(10, 5))\nplot!(p[2], HoneycombLattice(8, 4))","category":"page"},{"location":"lattice/#Sublattices","page":"Defining a lattice","title":"Sublattices","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Suppose we want to create a lattice with non-trivial geometry (for example, with holes).  This can be done by deleting some of the sites from the macro cell. There are three ways ways to do this:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Convenient way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = SquareLattice(10, 10)\n\nx, y = coord_values(l)\nl1 = l[@. abs(x) > 3 || abs(y) > 3]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Here we first create the macro cell, then find the coordinate values for its sites. After that we use LatticeValue broadcasting - see Lattice values for more detail.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"tip: Tip\nThis way to define sublattices is preferred, because code like this is the most readable. The x, y coordinate values will be also helpful to create other sublattices or slices.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Low-level way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l2 = sublattice(l) do site, (x, y); abs(x) > 3 || abs(y) > 3; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The lambda must accept a LatticeSite and a coordinate vector as positional arguments  and return whether the site should be included or not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The In-place way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l3 = SquareLattice(10, 10) do site, (x, y); abs(x) > 3 || abs(y) > 3; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"This notation is exactly the same as the low-level way, but done in one line.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warn: Warn\nThis notation should be used only if you need to access site indices or if the x, y coordinate values will not be needed further in the program.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The plot recipe for sublattices shows excluded sites with translucent markers by default. Passing keyword argument show_excluded_sites=false disables this.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = HoneycombLattice(6, 6)\nx, y = coord_values(l)\nplot(l[@. -5 < x * √3 + y < 5.5])","category":"page"},{"location":"lattice/#Custom-lattice-types","page":"Defining a lattice","title":"Custom lattice types","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"It is quite likely that you will need more types of lattices than this package provides by default. In such cases you need to define a new type. Follow these steps:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Create an exact alias","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Select a Symbol that will be the LatticeSym for this type and define an alias for the Lattice{LatticeSym, N, NB} type. The alias must not have any type parameters except for the dimension count if needed:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const HoneycombLattice = Lattice{:honeycomb, 2, 2}\nconst SquareLattice{N} = Lattice{:square, N, 1}","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Define the constructor","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The only arguments allowed are the macro cell size. The Bravais object must be generated in the constructor and passed to the default constructor Lattice(sym, sz, bvs).","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Let us define our own lattice type to make things clearer:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const GrapheneLattice = Lattice{:graphene, 3, 2}\nfunction GrapheneLattice(sz::Vararg{Int, 3})\n    bvs = Bravais([1 1/2 0; 0 √3/2 0; 0 0 2], [0 1/2; 0 √3/6; 0 0])\n    Lattice(:graphene, sz, bvs)\nend","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A sublattice constructor will be generated by default:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"gl = GrapheneLattice(6, 6, 3) do site, (x, y, z)\n    -5 < x * √3 + y < 5.5\nend\nplot(gl, show_excluded_sites=false)","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warn: Warn\nPlease note that if the type alias is dimension-parametric, you must define the constructor for a concrete type:SquareLattice(sz::Vararg{Int, N}) where N = ...     # Wrong!\nSquareLattice{N}(sz::Vararg{Int, N}) where N = ...  # Correct","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry and any possible count of internal states on one sites.\nVersatile hamiltonian generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nSmart unitary evolution macro reducing excessive computations where possible.\nPlots.jl integration.","category":"page"},{"location":"#Usage-examples","page":"Home","title":"Usage examples","text":"","category":"section"},{"location":"#Currents-in-Hofstadter-model-on-a-ring-shaped-sample","page":"Home","title":"Currents in Hofstadter model on a ring-shaped sample","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this example we delete part of the sites in the middle of a square lattice.  Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Hofstadter model hamiltonian is evaluated according to this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = sum_textx-links c^dagger_i c_j + sum_texty-links c^dagger_i c_j + h c","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing LinearAlgebra, Plots\n\nl = SquareLattice(10, 10) do site, (x, y)\n    abs(x) > 1 || abs(y) > 1\nend\n\n# Define a Hofstadter model hamiltonian\nh(B) = @hamiltonian begin   \n    lattice := l\n    # Add hoppings along axis x and y\n    @hop axis = 1\n    @hop axis = 2\n    # Add magnetic field through (0, 0) point\n    field := FluxField(B, (0, 0))\nend\n\n# Calculate eigenvalues and eigenvectors\nsp = spectrum(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = filled_projector(sp)\n# Perform unitary evolution\nτ = 10\na = Animation()\n@evolution {\n    H := h(0.1 * min(t, τ) / τ)\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    # Find the partial trace and plot it\n    density = diag_aggregate(m -> real(tr(m)), P)\n    heatmap(density, clims=(0,1))\n\n    # Show currents on the plot\n    plot!(DensityCurrents(H, P), arrows_scale=7, arrows_rtol=0.1)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"#Local-Chern-marker-with-hamiltonian-quench","page":"Home","title":"Local Chern marker with hamiltonian quench","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Chern insulator hamiltonian is described by this formula:","category":"page"},{"location":"","page":"Home","title":"Home","text":"hatH = \nsum_i m_i c^dagger_i sigma_z c_i + left(\nsum_textx-links c^dagger_i fracsigma_z - i sigma_x2 c_j + \nsum_texty-links c^dagger_i fracsigma_z - i sigma_y2 c_j + \nh c right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this experiment we create a filled state density matrix for a system with m_i = 1.  After that we change the m_i in the center of the lattice to -1 and start the evolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels\nusing LinearAlgebra, Plots\n\nl = SquareLattice(11, 11)\nx, y = coord_values(l)\n\n# The Pauli matrices\nσ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\n\n# Initial hamiltonian: m=1 everywhere\nH1 = @hamiltonian begin   \n    lattice := l\n    @diag σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\n\n# Quenched hamiltonian: m=-1 in the central 3x3 square\nM = @. (abs(x) < 1.5 && abs(y) < 1.5) * -2 + 1\nH2 = @hamiltonian begin\n    lattice := l\n    @diag M ⊗ σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\nX, Y = coord_operators(l, 2)\n\nsp = spectrum(H1)\nP_0 = filled_projector(sp)\n\nτ = 10\na = Animation()\n@evolution {\n    H := H2\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    p = plot(layout=2, size=(900, 500))\n\n    # Local Chern marker heatmap\n    lcm_operator = 4pi * im * P * X * P * Y * P\n    chern_marker = diag_aggregate(tr, lcm_operator) .|> real\n    heatmap!(p[1], chern_marker, clims=(-2, 2))\n\n    # Select sites on y=0 line (use ≈ to avoid rounding errors)\n    chern_marker_on_sw = chern_marker[@. y ≈ 0]\n    # Mark selected sites on the heatmap\n    plot!(p[1], chern_marker_on_sw.lattice, high_contrast=true)\n    # Add a line plot\n    plot!(p[2], chern_marker_on_sw, project_axis=:x, ylims=(-3, 3), lab=:none)\n\n    plot!(plot_title=\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"TODO","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"danger: Outdated docs\nThis part of the documentation is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"tutorial/#Local-density-for-lowest-states-in-a-tight-binding-model","page":"Tutorial","title":"Local density for lowest states in a tight-binding model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tight-binding model hamiltonian is defined by this formula:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hatH = sum_i^textsites left( c^dagger_i + hatx c_i + c^dagger_i + haty c_i + h c right)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we will find its eigenstates and plot their local density on heatmaps.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\n# Generate a 40x40 square lattice\nl = SquareLattice(40, 40)\n# Define the tight-binding model hamiltonian\nH = tightbinding_hamiltonian(l)\n\n# Calculate eigenvalues and eigenvectors\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], site_density(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", clims=clims, cbar=:none)\nend\n\n# The following 2 lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, background_subplot=:transparent, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), subplot=n^2+2)","category":"page"},{"location":"tutorial/#Currents-in-a-tight-binding-model-on-a-ring-shaped-sample","page":"Tutorial","title":"Currents in a tight-binding model on a ring-shaped sample","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example we delete part of the sites in the middle of a square lattice.  Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tight-binding hamiltonian is the same as in the example above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\n\nl = SquareLattice(10, 10) do (x, y)\n    !(4 < x < 7 && 4 < y < 7)\nend\nh(B) = tightbinding_hamiltonian(l, field=FluxField(B))\ndiag = diagonalize(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = densitymatrix(diag)\n# Perform unitary evolution\nτ = 10\na = Animation()\n@evolution {\n    H := h(0.1 * min(t, τ) / τ)\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    # Find the partial trace and plot it\n    plot(site_density(P), clims=(0,1))\n\n    # Show currents on the plot\n    plot!(DensityCurrents(H, P), arrows_scale=7, arrows_rtol=0.1)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"tutorial/#Local-Chern-marker-with-hamiltonian-quench","page":"Tutorial","title":"Local Chern marker with hamiltonian quench","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Chern insulator hamiltonian is described by this formula:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hatH = \nsum_i^textsites m_i c^dagger_i sigma_z c_i + \nsum_i^textsites left( \nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + \nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i + \nh c right)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this experiment we create a filled state density matrix for a system with m_i = 1.  After that we change the m_i in the center of the lattice to -1 and start the evolution.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\n\nl = SquareLattice(11, 11)\nx, y = coord_values(l)\n\n# Initial hamiltonian: m=1 everywhere\nH1 = qwz(l, 1)\n\n# Quenched hamiltonian: m=-1 in the central 3x3 square\nM = ones(l)\nM[@. 4 < x < 8 && 4 < y < 8] .= -1\nH2 = qwz(M)\nX, Y = coord_operators(l, 2)\n\nsp = diagonalize(H1)\nP_0 = densitymatrix(sp)\n\nτ = 10\na = Animation()\n@evolution {\n    H := H2\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    p = plot(layout=2, size=(900, 400))\n\n    # Local Chern marker heatmap\n    lcm_operator = 4pi * im * P * X * P * Y * P\n    chern_marker = site_density(lcm_operator)\n    plot!(p[1], chern_marker, clims=(-2, 2))\n\n    # Select sites on y=6 line\n    chern_marker_on_sw = chern_marker[y = 6]\n    # Mark selected sites on the heatmap\n    plot!(p[1], lattice(chern_marker_on_sw), high_contrast=true)\n    # Add a line plot\n    plot!(p[2], project(chern_marker_on_sw, :x), ylims=(-3, 3), lab=:none)\n\n    plot!(plot_title=\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"tutorial/#LDOS-animation","page":"Tutorial","title":"LDOS animation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Local density can be a bit ambiguous for degenerate eigenstates. That's where the LDOS (Refer to ldos documentation) will be helpful.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's take the same hamiltonian from the previous example and create a LDOS animation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\nl = SquareLattice(40, 40)\nH = qwz(l, 1)\n\ndg = diagonalize(H)\nδ = 0.1\nEs = -4:0.1:4\nEs_d = -4:0.01:4\nldosf = ldos(dg, δ)\na = @animate for E in Es\n    print(\"\\rE = $E\") # hide\n    p = plot(layout=2, size=(800, 400))\n    plot!(p[1], Es_d, dos(dg, δ), lab=\"\", title=\"DOS\")\n    vline!(p[1], [E], lab=\"\")\n    plot!(p[2], ldosf(E), clims=(0, NaN), title=\"LDOS\")\n    plot!(p, plot_title=\"E = $E, δ = $δ\")\nend\n\ngif(a, \"animation.gif\", fps=10)","category":"page"},{"location":"currents/#Usage","page":"Currents","title":"Usage","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents object is a lazy object that can calculate any current-like value between any pair of sites.  Usage is pretty simple:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"using LatticeModels, Plots","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"l = SquareLattice(10, 10)\nH = tightbinding_hamiltonian(l, field = FluxField(1, (5.5, 5.5)))\nP = densitymatrix(diagonalize(H), μ = -0.5)\n\ncurr = DensityCurrents(H, P)                    # Create Currents object\nheatmap(site_density(P))\nplot!(curr, arrows_scale=25, arrows_rtol=0.1, color=:blue)    # Quiver-plot the currents","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"What happened here? The formula for the density current from site i to site j is J_ij = texttr(-i hath_ij hatc^dagger_i hatc_j hatrho + h c) = 2 textIm tr(hath_ij hatc^dagger_i hatc_j hatrho).  The curr object contains this formula inside and when this object is passed to the plot function, all needed currents are evaluated.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"A current between each pair of sites is shown as an arrow directed from one to another with its length proportional to the strength of the current. The arrows_scale keyword argument scales all arrows by given factor, while arrows_rtol hides all arrows that are shorter than some fraction of the distance between the sites.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"You can display currents between certain sites by using a boolean-typed LatticeValue and bracket-notation:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"x, y = coord_values(l)\nsub_curr = curr[x .< y]\nplot!(sub_curr, arrows_scale=25, arrows_rtol=0.1, color=:green)","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Here all currents between sites in the upper-left coordinate triangle are marked green.","category":"page"},{"location":"currents/#Interface","page":"Currents","title":"Interface","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"It is quite likely that you might want to define your own type of currents. All you need to do is inherit the AbstractCurrents type and define two functions:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"lattice(::MyCurrents) must return the lattice which the currents are defined on\nBase.getindex(::MyCurrents, i::Int, j::Int) must return the current between sites with indices i and j. Note that the function must be skew-symmetric, e. g. curr[i, j] == -curr[j, i].","category":"page"},{"location":"currents/#Materialized-currents","page":"Currents","title":"Materialized currents","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents is a lazy object. This allows to avoid excessive computation of site-to-site currents, but the computations that are needed will be repeated every time when we access that object; also abstract currents cannot be normally stored into a TimeSequence (more precisely, you won't be able to differentiate or integrate such currents over time). That's where the MaterializedCurrents come in, having all their values stored explicitly in an array.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"To convert any type of currents to MaterializedCurrents, simply use the materialize function. You can avoid evaluating some currents (for example, if you know beforehand that they must be zero) by passing a lambda as a first argument (or with do-syntax): it must take the Lattice and two LatticeSites and return whether the current between these sites must be evaluated.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"You can find it similar to the selector function we used back in Hopping operators, which indeed is. You may find the following selector functions useful:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Passing a PairSet produced by the bonds function will keep only the currents between adjacent sites.\npairs_by_distance will allow you to select pairs of sites depending on the distance between them. ","category":"page"},{"location":"currents/#Mapping-currents","page":"Currents","title":"Mapping currents","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"In some cases we want to find out how currents depend on some lattice properties: for example, the distance between sites. In such case, the map_currents function can be quite helpful.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Let's find the mean and the standard deviation for currents between sites given the distance between them:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"using LinearAlgebra, Statistics\n\ndist, adcurr = map_currents(\n    curr, \n    reduce_fn=(x -> [mean(abs.(x)), std(abs.(x))]),\n    sort=true\n) do l, site1, site2\n    norm(site1.coords - site2.coords)\nend\n\nacurr, dcurr = eachcol(adcurr)\nscatter(dist, acurr, err=dcurr, xlims=(0, 14))","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"What happened here? The map_currents function found the distance and the current between each pair of sites. Then for each distance between sites it found the mean and standard deviation for the absolute value of the currents in such pairs, and stored it column-wise in a matrix automatically. In the next line we extracted the mean and standard deviation into separate lists, and plotted the obtained data.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"From this picture we can see that there are no density currents between non-adjacent sites, as one must have expected.","category":"page"},{"location":"library/#LatticeModels.jl","page":"Library","title":"LatticeModels.jl","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-system","page":"Library","title":"Lattice system","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"core/lattice.jl\", \"core/sample.jl\"]","category":"page"},{"location":"library/#LatticeModels.Lattice","page":"Library","title":"LatticeModels.Lattice","text":"Lattice{LatticeSym, N, NB}\n\nA finite subset of a Brvais{N, NB}. LatticeSym is a Symbol which represents the type of the lattice (e. g. :square, :honeycomb). This makes Lattice object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.\n\n\n\nLattice(sym, sz, bvs[, mask])\n\nConstructs a finite Lattice{sym, N, NB} as a subset of the bvs Bravais lattice. sz is a NTuple{N, Int} which represents how many times the unit cell of bvs was translated by each axis - these sites form a macrocell. mask, if defined, is a Vector{Bool} storing information about which of the sites from the macrocell are actually included in the lattice, and which are not.\n\nFor example, a 3×3 square lattice with its center site excluded is represented as Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])\n\nTo define a new type of lattice, create an alias for Lattice{YourSym, YourN, YourNB}. Refer to the docs for detailed explanation.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.check_issublattice-Tuple{Lattice, Lattice}","page":"Library","title":"LatticeModels.check_issublattice","text":"Checks if l1 is sublattice of l2. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samelattice-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samelattice","text":"Checks if l1 and l2 objects are defined on one lattice. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samemacrocell-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samemacrocell","text":"Checks if l1 and l2 are defined on one macrocell. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.radius_vector-Union{Tuple{N}, Tuple{Lattice, LatticeModels.LatticeSite{N}, LatticeModels.LatticeSite{N}}} where N","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(l::Lattice, site1::LatticeSite, site2::LatticeSite) -> vector\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macrocell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_distance-Tuple{Lattice, LatticeModels.LatticeSite, LatticeModels.LatticeSite}","page":"Library","title":"LatticeModels.site_distance","text":"site_distance(l::Lattice, site1::LatticeSite, site2::LatticeSite[; pbc=false])\n\nReturns the distance between two sites on the l lattice.\n\nKeyword arguments:\n\npbc: if true, the boundary conditions will be considered periodic and\n\nthe distance will be measured on the shortest path.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_distance-Tuple{}","page":"Library","title":"LatticeModels.site_distance","text":"site_distance(; pbc)\n\nGenerates a function that finds the distance between sites (see site_distance(::Lattice, ::LatticeSite, ::LatticeSite)). This notation can be handy when passing this function as an argument.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_index-Tuple{Lattice, Union{LatticeModels.LatticePointer, LatticeModels.LatticeSite}}","page":"Library","title":"LatticeModels.site_index","text":"site_index(l::Lattice, site::LatticeSite; macrocell=false)\n\nReturns the integer index for given site in lattice. Returns nothing if the site is not present in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym","page":"Library","title":"LatticeModels.sublattice","text":"sublattice(lf::Function, l::Lattice) -> Lattice\n\nGenerates a a subset of lattice l by applying the lf function to its sites. The lf function must return a boolean value.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-values","page":"Library","title":"Lattice values","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"core/lattice_value.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LT}\n\nRepresents a value of type T on a Lattice{LatticeSym} lattice.\n\nFields:\n\nlattice: the Lattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeValue-Tuple{Lattice, AbstractVector}","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue(l::Lattice, v::AbstractVector)\n\nConstructs a LatticeValue object.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coord_values-Tuple{Lattice}","page":"Library","title":"LatticeModels.coord_values","text":"coord_values(l::Lattice)\n\nGenerates a tuple of LatticeValues representing spatial coordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.project-Tuple{LatticeValue, Any}","page":"Library","title":"LatticeModels.project","text":"project(lv::LatticeValue, axis)\n\nCreates a mapping from site coordinates to values of lv. The coordinate axis to project the sites onto can be set with the axis argument - it can be either an integer from 1 to 3 or an axis descriptor Symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#Bonds","page":"Library","title":"Bonds","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"core/bonds.jl\"]","category":"page"},{"location":"library/#LatticeModels.SiteOffset","page":"Library","title":"LatticeModels.SiteOffset","text":"SiteOffset{T, N}\n\nA struct representing bonds in some direction in a lattice.\n\n\n\nSiteOffset([site_indices, ]translate_uc)\n\nConstructs a SiteOffset object.\n\nArguments:\n\nsite_indices: a ::Int => ::Int pair with indices of sites connected by the bond.\n\nWhen not defined, the resulting bonds object will connect site with any basis index to a site with the same basis index, but in another unit cell.\n\ntranslate_uc: the unit cell offset.\n\nIf site_indices are equal or undefined and translate_uc is zero, the bond connects each site with itself. In this case an error will be thrown. Note that though the dimension count for the bond is static, it is automatically compatible to higher-dimensional lattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteOffset-2","page":"Library","title":"LatticeModels.SiteOffset","text":"SiteOffset(site_indices)\nSiteOffset([site_indices; ]axis[, dist=1])\n\nA convenient constructor for a SiteOffset object. site_indices is 1 => 1 by default.\n\nsite_indices is a ::Int => ::Int pair with indices of sites connected by the bond; 1 => 1 is the default value.\n\nKeyword arguments:\n\naxis: The hopping direction axis in terms of unit cell vectors.\ndist: The hopping distance in terms of\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.radius_vector-Tuple{Lattice, Bonds{<:Pair}}","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(l::Lattice, hop::SiteOffset)\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macrocell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#Magnetic-fields","page":"Library","title":"Magnetic fields","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"field.jl\"]","category":"page"},{"location":"library/#LatticeModels.NoField","page":"Library","title":"LatticeModels.NoField","text":"NoField <: AbstractField\n\nA stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}","page":"Library","title":"LatticeModels.line_integral","text":"line_integral(field, p1, p2[, n_steps=1])\n\nCalculates the int_p1^p2 overrightarrowA cdot overrightarrowdl integral using the trapezoidal rule. Increase n_steps to improve accuracy (note that for linear fields like Landau or symmetrical calibrations the formula is already pefrectly accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}","page":"Library","title":"LatticeModels.vector_potential","text":"vector_potential(field, point)\n\nReturns vector potential overrightarrowA for field in location point.\n\nThis function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.\n\n\n\n\n\n","category":"method"},{"location":"library/#Operators","page":"Library","title":"Operators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"operators_core.jl\", \"operators_build.jl\", \"operators_manybody.jl\"]","category":"page"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"currents.jl\"]","category":"page"},{"location":"library/#LatticeModels.AbstractCurrents","page":"Library","title":"LatticeModels.AbstractCurrents","text":"AbstractCurrents\n\nSupertype for all type representing currents-like values on a lattice. Subtypes must implement Base.getindex(::Int, ::Int) and lattice functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.MaterializedCurrents","page":"Library","title":"LatticeModels.MaterializedCurrents","text":"MaterializedCurrents <: AbstractCurrents\n\nA AbstractCurrents instance that stores values for all currents explicitly.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SubCurrents","page":"Library","title":"LatticeModels.SubCurrents","text":"SubCurrents{CT<:AbstractCurrents} <: AbstractCurrents\n\nA lazy wrapper for a Currents object representing the same currents but on a smaller lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.lattice","text":"lattice(::AbstractCurrents)\n\nGets the lattice where the given AbstractCurrents object is defined.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.map_currents-Tuple{Function, LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.map_currents","text":"map_currents(map_fn, currs::AnstractCurrents[; reduce_fn, sort=false])\n\nAccepts a function that takes a Lattice and two LatticeSites and returns any value. Applies map_fn to every site pair and returns two Vectors: one with currents, one with results of map_fn.\n\nKeyword arguments:\n\nreduce_fn: if a function is provided, all currents with the same mapped value will be reduced into one value.\n\nFor example, if aggr_fn=(x -> mean(abs.(x))), and map_fn finds the distance between the sites, the returned lists will store the distance between sites and the average absolute current between sites with such distance.\n\nsort: if true, the output arrays will be sorted by mapped value.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.materialize-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.materialize","text":"materialize([function, ]currents)\n\nCreates a MaterializedCurrents instance for currents.\n\nIf function is provided, it must accept a Lattice and two LatticeSites and return if the current between this site must be calculated or not. This can be useful to avoid exsessive calculations.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.pairs_by_distance-Tuple{Any}","page":"Library","title":"LatticeModels.pairs_by_distance","text":"pairs_by_distance(f)\n\nA selector function used for hopping operator definition or currents materialization.\n\nTakes a function and generates a lambda which accepts a lattice and two LatticeSites, returning whether f applied to distance between the two sites returned true.\n\n\n\n\n\n","category":"method"},{"location":"library/#Unitary-evolution","page":"Library","title":"Unitary evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"evolution.jl\"]","category":"page"},{"location":"library/#LatticeModels.evolution_operator!-Tuple{AbstractMatrix, AbstractMatrix, Real}","page":"Library","title":"LatticeModels.evolution_operator!","text":"evolution_operator(H, t)\n\nCalculates the unitary evolution operator using the formula\n\n$ \\mathcal{U}(t) = e^{-\\frac{1}{i\\hbar} \\hat{H} t} $\n\nArguments\n\nH: the hamiltonian matrix\nt: the evolution time\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@evolution-Tuple","page":"Library","title":"LatticeModels.@evolution","text":"@evolution [kwargs...] {rules...} for_loop\n\nGenerates an environment with defined hamiltonian and density matrices that evolve by certain laws. See Unitary evolution for more details.\n\nKeyword arguments:\n\nk: order of the Taylor expansion for matrix exponent. If omitted, the default exp function will be used.\npade: set this to true to use Padé approximant formula instead of Taylor expansion.\nrtol: the relative tolerance to decide whether the Δt changed between iterations or not. 1e-12 by default.\nshow_progress: defines whether the progress informer must be displayed or not. true by default.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Time-sequences","page":"Library","title":"Time sequences","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"time_sequence.jl\"]","category":"page"},{"location":"library/#LatticeModels.TimeSequence","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}\n\nSeries of some data depending on time.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(times, values)\n\nConstructs a TimeSequence with given timestamps and values.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Real, Any}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(value; t=0)\n\nConstructs a TimeSequence with one single snapshot. The timestamp is zero by default but can be over riden.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.differentiate!","text":"differentiate!(ts::TimeSequence)\n\nDifferentiate the values stored in the TimeSequence object by time using the symmetric difference formula.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.integrate!","text":"integrate(ts::TimeSequence)\n\nIntegrates the values stored in the TimeSequence object over time using the trapezoidal rule.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timestamps-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.timestamps","text":"timestamps(ts::TimeSequence)\n\nReturns the timestamps of the snapshots.\n\n\n\n\n\n","category":"method"},{"location":"library/#Model-zoo","page":"Library","title":"Model zoo","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"zoo.jl\"]","category":"page"},{"location":"library/#LatticeModels.DensityCurrents","page":"Library","title":"LatticeModels.DensityCurrents","text":"DensityCurrents <: AbstractCurrents\n\nDensity currents for given density matrix and given hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.FluxField","page":"Library","title":"LatticeModels.FluxField","text":"FluxField <: AbstractField\n\nAn object representing a small magnetic flux through given point. The field is directed along z-axis. Fields:\n\nB: The magnetic field value\npoint: A NTuple{2, Number} representing the point where the magnetic flux is located.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nType alias for Lattice{:honeycomb,2,2}.\n\n\n\nHoneycombLattice(sz::Vararg{Int, 2})\n\nConstructs a honeycomb lattice with a sz-size macrocell.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LandauField","page":"Library","title":"LatticeModels.LandauField","text":"LandauField <: AbstractField\n\nAn object representing Landau calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nType alias for Lattice{:square,N,1}.\n\n\n\nSquareLattice(sz::Int...)\n\nConstructs a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SymmetricField","page":"Library","title":"LatticeModels.SymmetricField","text":"SymmetricField <: AbstractField\n\nAn object representing symmetrically calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.haldane","page":"Library","title":"LatticeModels.haldane","text":"haldane(l::HoneycombLattice, t1::Real, t2::Real[, m::Real=0; field::AbstractField])\n\nhatH =\nsum_i^textsublattice A m c^dagger_i c_i +\nsum_j^textsublattice B m c^dagger_j c_j +\nsum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) +\nsum_i j^text2-connectedcounter-clockwise left( i cdot t_2 c^dagger_i c_j + h c right)\n\nGenerates a Haldane topological insulator hamiltonian operator.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.qwz-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.qwz","text":"qwz([f, ]mv::LatticeValue[; field::AbstractField, pbc=false])\nqwz([f, ]l::SquareLattice[, m::Number=1; field::AbstractField, pbc=false])\n\nhatH =\nsum_i^textsites m_i c^dagger_i sigma_z c_i +\nsum_i^textsites left(\nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i +\nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i +\nh c right)\n\nGenerates a QWZ model hamiltonian operator with set magnetic field. If the m_i values are set by the mv::LatticeValue, which must be defined on a SquareLattice. Otherwise they will all be set to m.\n\nf here must be a function or a PairSelector describing which hoppings will be excluded.\n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"danger: Outdated docs\nThis part of the documentation is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"operators/#Hamiltonian-macro","page":"Operators","title":"Hamiltonian macro","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"A hamiltonian operator usually consists of a diagonal part and a hopping part.  Sometimes a magnetic field is applied, in which case additional phase factors emerge according to Peierls substitution. ","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Taking all this into account, the operator will now look something like this:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"hatH = \nsum_i^textsites hats_i hatc^dagger_i hatc_i + left( sum_i j^textadjacent hatt_ij hatc^dagger_j hatc_i\ncdot e^frac2pi iphi_0 int_r_i^r_j overrightarrowA cdot overrightarrowdl + h c right)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Such an operator can be easily constructed using the @hamiltonian macro.  All you have to do is assign lattice and also field if needed, and then define the diagonal and hopping members using @diag and @hop.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Let's take a look at the example on the Usage examples page:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"A simple tight-binding model hamiltonian for a square lattice is defined by the formula  hatH = sum_i^textsites left( c^dagger_i + hatx c_i + c^dagger_i + haty c_i + h c right)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"We can create a matrix for this operator on a xsize×ysize square lattice with the following code:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"using LatticeModels","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"TightBinding(xsize, ysize, field=NoField()) = @hamiltonian begin\n    lattice := SquareLattice(xsize, ysize)\n    field := field\n    @hop axis = 1   # x-bonds\n    @hop axis = 2   # y-bonds\nend\nnothing # hide","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Note that the keyword arguments for hopping operators are written as if they were passed to the hopping function.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"For a QWZ model Chern insulator the hamiltonian looks like this:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"hatH = \nsum_i^textsites m_i c^dagger_i sigma_z c_i + \nsum_i^textsites left( \nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + \nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i + \nh c right)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Here we want the m_i values to be represented by any number-typed LatticeValue, so the most convenient way to do it is to use tensor product notation:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"# The Pauli matrices\nconst σ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\n\n# Initial hamiltonian: m=1 everywhere\nChernInsulator(m::LatticeValue{<:Number, :square}, field=NoField()) = @hamiltonian begin   \n    lattice := lattice(m)\n    field := field\n    dims_internal := 2\n    @diag m ⊗ σ[3]\n    @hop (σ[3] - im * σ[1]) / 2 axis = 1\n    @hop (σ[3] - im * σ[2]) / 2 axis = 2\nend\nnothing # hide","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Here we must explicitly set the internal phase space dimension count via dims_internal := 2.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Some default hamiltonian formulas are already implemented - see qwz, haldane docstrings for more info.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"tip: Tip\nIt is possible to set the matrix type of the hamiltonian operator at the generation time - use arrtype := <Preferred type> notation, this can be used e. g to reduce memory usage by switching to sparse arrays. Note however that some array types may not support this feature, in which case use the @on_lattice macro.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Note that the field parameter is defaulted to NoField() (this is a magnetic field object representing zero field). Other available magnetic field objects are:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"LandauField(B::Real) - Landau-calibrated uniform magnetic field\nSymmetricField(B::Real) - symmetrically calibrated uniform magnetic field\nFluxField(Φ::Real, point::NTuple{2, Number}) - point magnetic field flux through point.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Most of these fields are designed for 2D lattices, but may also be applied to lattices with other dimensionality. You can define your own field types, see Custom magnetic fields.","category":"page"},{"location":"operators/#Operator-spectrum-utilities","page":"Operators","title":"Operator spectrum utilities","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"A Eigensystem object contains eigenvalues and eigenvectors of some hermitian operator. ","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"It is a very convenient way to work with eigenvectors. Check this out:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"dg = diagonalize(tightbinding_hamiltonian(SquareLattice(5, 5)))\ndg[1]       # Get the first eigenstate (e. g. the state with lowest energy)\ndg[3]       # Get the third eigenstate\ndg[value = 0]   # Get eigenstate with energy nearest to 0\ndg[1:3]     # Create a new Eigensystem with states from #1 to #3\nE = dg.values   # Get eigenvalues\ndiag_filled = dg[E .< 0]    # Create a new Eigensystem with filled bands only","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"You can use densitymatrix or projector (only in zero-temperature cases) functions to find a density matrix of a system.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"P = projector(E -> E < 0, dg)\nP = projector(diag_filled)              # The same thing\nP = densitymatrix(dg, μ = 0, T = 0)     # The same thing\nP = densitymatrix(dg)                   # The same thing","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"warning: Warning\nThe diagonalize function finds the eigenvalues and eigenvectors using LinearAlgebra.eigen. You will probably have to define it for array types that do not support default LinearAlgebra routines.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"One more thing you can do with Eigensystems is finding the density of states (DOS) and the local density of states (LDOS).  The DOS is the imaginary part of texttrleft(frac1hatH - E - ideltaright) operator, whereas the LDOS is its partial trace.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"It's highly recommended to use the built-in dos and ldos functions, because the Eigensystem object stores the hatH operator already diagonalized, which makes calculations much faster.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"using Plots\n\np = plot(layout=@layout[_ a{0.5w} _; grid(1, 2)], size=(800, 800))\nplot!(p[1], -4:0.1:4, dos(sp, 0.2), title=\"DOS with δ = 0.2\")\nplot!(p[2], ldos(sp, 1, 0.2), title=\"LDOS at E = 1 with δ = 0.2\")\n\n# These two lines produce exactly the same result as the previous\nldos_fun = ldos(sp, 0.2)\nplot!(p[3], ldos_fun(1), title=\"LDOS at E = 1 with δ = 0.2 (via function)\")","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"tip: Tip\nIf you want to find the LDOS for the same spectrum and delta, but for many different energy values, consider using ldos(spectrum, delta): it improves performance dramatically.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"danger: Outdated docs\nThis part of the documentation is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"We often  want to study the behavior of some quantum system in time-dependent conditions. We can use the unitary evolution operator to describe how the density matrix depends on time:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"mathcalU(t) = Tleft e^frac1ihbar int_t_0^t hatH(tau) dtau righthspace05cm\nmathcalP(t) = mathcalU(t) mathcalP_0 mathcalU^dagger (t)","category":"page"},{"location":"evolution/#The-evolution-macro","page":"Unitary evolution","title":"The evolution macro","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro can be quite useful if your hamiltonian depends on time or if there are multiple Hamiltonians in your experiment. It avoids excessive computation in several cases automatically:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian does not change, the mathcalU(t dt) operator will not be re-evaluated.\nIf several wavefunctions or density matrices evolve using the same hamiltonian, neither the hamiltonian nor the evolution operator matrix will be re-evaluated.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us define a function that generates a Chern insulator hamiltonian:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"using LatticeModels, Plots\nσ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\nChern(l, B) = @hamiltonian begin\n    lattice := l\n    field := LandauField(B)\n    dims_internal := 2\n    @diag σ[3]\n    @hop axis=1 (σ[3] - im * σ[1]) / 2\n    @hop axis=2 (σ[3] - im * σ[2]) / 2\nend\nnothing # hide","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The @evolution macro creates a scope where the hamiltonian and wavefunctions (or density matrices) are evaluated for the given time interval.  It takes two arguments: a braced list with evolution specifiers and a for-loop that iterates over the time interval:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"l = SquareLattice(10, 10)\nτ = 30\na = Animation()\nB = 0.01\nP0 = densitymatrix(diagonalize(qwz(l, 0)))\n\n@evolution {\n    H := Chern(l, B * min(t, τ) / τ),\n    P0 --> H --> P\n} for t in 0:0.1:2τ\n    cur = DensityCurrents(H, P)\n    heatmap(site_density(P), title=\"Local density, t = $t\", clims=(0.9, 1.1))\n    plot!(cur, arrows_scale=20, color=:blue)\n    frame(a)\nend\ngif(a, \"animation.gif\")","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us make it clear what an evolution specifier is. In fact, there are two possible variants:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"It is an evolution rule describing the initial state, the hamiltonian it will evolve accroding to, and the name of the variable to write the result. These three arguments must be written in a chain delimited by --> like this: \nP0 --> Chern(l, B * min(t, τ) / τ) --> P\nNote that you can use a hamiltonian alias instead of an expression if it was previously defined.\nIt is an alias declaration, which means that a certain expression will be evaluated on every iteration and assigned to a variable with a given name. For example, H := Chern(l, B * min(t, τ) / τ) evaluates the Chern insulator hamiltonian and writes the result to the H variable.","category":"page"},{"location":"evolution/#Compatibility","page":"Unitary evolution","title":"Compatibility","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro is designed to be compatible with arbitrary array types. This means that hamiltonian expressions or initial states needn't to be LatticeArrays, but they can be of any array type instead, as long as it supports linear algebra operations such as matrix multiplication.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here are the functions that must be defined for the desired array type:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Equality operator: ==\nBasic arithmetic functions: +, -, *, adjoint\nThe identity matrix one(A)\nThe matrix exponent exp(A)\nIf it is not possible to implement this function you can set the k keyword argument (see below) to calculate the matrix exponent as a partial sum of Taylor series.\nIf the inverse matrix inv(A) function is defined, you can use the Padé approximant for the matrix exponent, which is generally more accurate.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"warning: Warning\nIf you use LatticeArrays, you still have to make sure these functions and operators are defined for the underlying array type.","category":"page"},{"location":"evolution/#Performance","page":"Unitary evolution","title":"Performance","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The evolution macro avoids calculations where possible to improve performance. It is important to know how it achieves this result:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian matrix has not changed between two iterations and the time step remained approximately the same, mathcalU(t dt) will not be re-evaluated, because the matrix exponent is the most time-consuming operation compared to others like matrix multiplication or addition.\nThe relative tolerance used to check if the time step has changed can be set via rtol keyword.\nIf the hamiltonian expression does not explicitly depend on the loop variable (t in the example), it will be considered constant and evaluated only once at the beginning. Otherwise it will be evaluated on every iteration in the loop scope.\nIf several states evolve according to the same hamiltonian, both the hamiltonian and the mathcalU(t dt) evolution operator will be evaluated only once per iteration.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"To improve performance with small time intervals you can calculate the matrix exponent as a Taylor polynomial. Its order can be set via k keyword.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"For more precise calculation add pade=true - this will enable matrix exponent calculation via Padé approximant. Note that this formula requires finding an inverse matrix, so this option is not compatible with sparse matrices.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"By default the macro shows a progress informer that shows the task progress, the estimated time remaining and the fraction of time that was spent to perform evolution. To disable it add show_progress=false to the keyword arguments.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Keyword assignments should be placed before the rules list:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"@evolution k=2 rtol=1e-6 show_progress=false {...} for t in ...","category":"page"},{"location":"evolution/#Time-sequences","page":"Unitary evolution","title":"Time sequences","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"A TimeSequence is a struct that stores information about how some value changed during time. It simplifies working with time-dependent values by allowing you to run the computation pass only once and re-evaluate all processing and visualization code as much as you want.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here is an example:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"P0 = densitymatrix(diagonalize(qwz(l)))\ndensity_rec = TimeSequence()\nderiv_rec = TimeSequence()\n\n@evolution {\n    H := Chern(l, B * min(t, τ) / τ),\n    P0 --> H --> P\n} for t in 0:0.1:2τ\n    insert!(density_rec, t, site_density(P))\n    insert!(deriv_rec, t, site_density(-im * (H * P - P * H)))\nend\n\nsite = l[50]\np = plot(layout=(2,1))\nplot!(p[1], density_rec[site], lab=\"p\")\n\n# Compare computed time derivative with Heisenberg equation\nplot!(p[2], differentiate(density_rec[site]), lw=5, alpha=0.3, lab=\"dp/dt\")\nplot!(p[2], deriv_rec[site], lab=\"Heisenberg\")","category":"page"},{"location":"evolution/#Indexing-and-iteration","page":"Unitary evolution","title":"Indexing and iteration","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"TimeSequences support two kinds of indexing:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Calling the record with a numeric value selects the time and returns the object in nearest snapshot.  Calling it with two numeric values yields a new TimeSequence with all timestamps between given values.\nIndexing it with square brackets will apply this index to all snapshots. The output will also be a TimeSequence.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let's see how it works:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"p = plot(layout=(1,3), size=(800, 250))\nplot!(p[1], density_rec(10))                        # The snapshot with time nearest to 10\ntypeof(density_rec(10))                             # LatticeValue{Float64}\nplot!(p[2], density_rec[l[25]])                     # The value on the 25-th site depending on time \ntypeof(density_rec[l[25]])                          # Dict{Float64, Float64}\nplot!(p[3], (density_rec(15, 25) |> diff)[l[25]])   # Derivative of the value by time where 15 ≤ t ≤ 25","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Note that TimeSequence impements the AbstractDict and therefore is iterable. The iterator yields timestamp => value pairs:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"for (t, P) in density_rec\n    # Do what you need with t, P\nend","category":"page"},{"location":"evolution/#Differentiation-and-integration","page":"Unitary evolution","title":"Differentiation and integration","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"You can also automatically differentiate and integrate the TimeSequence with differentiate and integrate functions (or their in-place alternatives differentiate! and integrate!). However, the type of the stored values must implement the following methods:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Base.copy: the non in-place methods simply call their in-place versions on a copy of the original TimeSequence.\nBase.zero: this function will be called before integrating.\nLinearAlgebra.axpby! to implement basic in-place math.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Still, types in this library (LatticeValue, LatticeArray, MaterializedCurrents), numbers and arrays are compatible with differentiation and integration out of the box.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"warning: Warning\nIntegrating or differentiating may produce unexpected results or crash if applied to a TimeSequence with elements of different type or defined on a different Lattice/Basis. Lattice or basis match is not checked when constructing a TimeSequence!","category":"page"},{"location":"lattice/#Simple-Bravais-lattice","page":"Defining a lattice","title":"Simple Bravais lattice","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The simplest variant of a finite Bravais lattice is a macrocell,  which is the lattice basis translated finite number of times along every translation vector.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"using LatticeModels, Plots, LinearAlgebra","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Constructing a macrocell is simple: the lattice constructor accepts positional arguments which will be translation ranges along all dimensions.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Note that lattices of some types can be of any dimensionality, while others can not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"julia> SquareLattice(10, 10)\n100-site square lattice (10×10 macrocell)\n\njulia> SquareLattice(3, 3, 3)\n27-site square lattice (3×3×3 macrocell)\n\njulia> HoneycombLattice(5, 5)\n50-site honeycomb lattice (5×5 macrocell, 2-site basis)\n\njulia> HoneycombLattice(3, 3, 2)\nERROR: MethodError: no method matching HoneycombLattice(::Int64, ::Int64, ::Int64)\n[...]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A lattice can be scatter-plotted to see how its sites are located and which index is assigned to each site:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"p = plot(size=(800, 350), layout=2)\nplot!(p[1], SquareLattice(10, 5))\nplot!(p[2], HoneycombLattice(8, 4))","category":"page"},{"location":"lattice/#axis_descriptors","page":"Defining a lattice","title":"Lattice sites and axis descriptors","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A LatticeSite is a struct describing where a site of some Bravais lattice is located:  it stores the location of the unit cell and the site's number in the lattice basis. Its spatial coordinates are also stored inside, which you can access via the coords field as a vector or using accesors like x, y, z for individual coordinates. You can also unpack a LatticeSite to access the coordinates.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Iterating over any Lattice will yield LatticeSites.  You can also get them by indexing the Lattice object with integers or coordinate keywords:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = SquareLattice(5, 5)\nsite1 = l[7]\nsite2 = l[x = 2, y = 2]\nsite1 == site2\nx, y = site1","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"These keywords are called axis descriptors. There are two types of them:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Coordinate axes are described by integers or symbols of form :x$i (where $i is the integer index of the axis). For indices 1-3 descriptors :x, :y and :z respectively are also allowed. Use these to select lattice sites by coordinate.\nLattice axes parallel to lattice translation vectors are described by symbols of form :j$i (where $i is the integer index of the axis). Use these to select lattice sites by unit cell index.\nA special basis index descriptor :index can be used to select sites by basis index.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Axis descriptors can also be used for selecting sites (or sublattices) by lattice indices. Take a look at the example:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = HoneycombLattice(5, 5)\nplot(l, leg=:bottomright)\nplot!(l[j1=2], pretty=false, lab=\"Select a unitcell row\")\nplot!(l[index=1], pretty=false, ms=10, alpha=0.3, lab=\"Select a Bravais sublattice\")","category":"page"},{"location":"lattice/#Sublattices","page":"Defining a lattice","title":"Sublattices","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Suppose we want to create a lattice with non-trivial geometry (for example, with holes).  This can be done by deleting some of the sites from the macrocell. There are three ways ways to do this:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Convenient way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = SquareLattice(10, 10)\n\nx, y = coord_values(l)\nl1 = l[@. x > 5 || y > 5]","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Here we first create the macrocell, then find the coordinate values for its sites. After that we use LatticeValue broadcasting, see Lattice values for more detail.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"tip: Tip\nThis way to define sublattices is preferred, because code like this is the most readable. The x, y coordinate values will be also helpful to create other sublattices or slices.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The Low-level way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l2 = sublattice(l) do (x, y); x > 5 || y > 5; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The lambda must accept a LatticeSite and return whether the site should be included or not.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The In-place way","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l3 = SquareLattice(10, 10) do (x, y); x > 5 || y > 5; end","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"This notation is exactly the same as the low-level way, but done in one line.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The plot recipe for sublattices shows excluded sites with translucent markers by default and also prints out integer indices for all included sites. Pass keyword argument pretty=false to suppress this behavior.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"l = HoneycombLattice(6, 6)\nx, y = coord_values(l)\nplot(l[@. 7 < x * √3 + y < 18])","category":"page"},{"location":"lattice/#Custom-lattice-types","page":"Defining a lattice","title":"Custom lattice types","text":"","category":"section"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"It is quite likely that you will need more types of lattices than this package provides by default. In such cases you need to define a new type. Follow these steps:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Create an exact alias","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Select a Symbol that will be the LatticeSym for this type and define an alias for the Lattice{LatticeSym, N, NB} type. The alias must not have any type parameters except for the dimension count if needed:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const HoneycombLattice = Lattice{:honeycomb, 2, 2}\nconst SquareLattice{N} = Lattice{:square, N, 1}","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Define the constructor","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"The only positional arguments allowed are the macrocell size.[1] The Bravais object must be generated in the constructor and passed to the default constructor Lattice(sym, sz, bvs).","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"[1]: This is done with purpose to achieve code consistency. Also in-place sublattice generation will almost certainly be broken. Use keyword arguments if you need additional parameters for some lattice type.","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"Let us define our own lattice type:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"const GrapheneLattice = Lattice{:graphene, 3, 2}\nfunction GrapheneLattice(sz::Vararg{Int, 3})\n    bvs = Bravais([1 1/2 0; 0 √3/2 0; 0 0 2], [0 1/2; 0 √3/6; 0 0])\n    Lattice(:graphene, sz, bvs)\nend\nnothing # hide","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"A sublattice constructor will be generated by default:","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"gl = GrapheneLattice(6, 6, 3) do (x, y, z)\n    7 < x * √3 + y < 18\nend\nplot(gl, pretty=false)","category":"page"},{"location":"lattice/","page":"Defining a lattice","title":"Defining a lattice","text":"warning: Warning\nPlease note that if the type alias is dimension-parametric, you must define the constructor for a concrete type, otherwise you will almost definitely break the lattice constructor dispatch:SquareLattice(sz::Vararg{Int, N}) where N = ...     # Wrong!\nSquareLattice{N}(sz::Vararg{Int, N}) where N = ...  # CorrectIn the second example SquareLattice(sz::Vararg{Int, N}) where N constructor will be generated automatically.","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paste the following line into the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/aryavorskiy/LatticeModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/aryavorskiy/LatticeModels.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Compat\nThis package has tested compatibility with Julia v1.6. Use with caution on lower versions.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry or boundary conditions.\nPowerful operator generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nSmart unitary evolution macro reducing excessive computations where possible.\nSupports visualization via Plots.jl.\nCompatible with QuantumOptics.jl.","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This simple code plots density heatmaps for lowest energy states of a square tight-binding lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels, Plots\n\nl = SquareLattice(40, 40)\nH = tightbinding_hamiltonian(l)\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    # Plot a density heatmap on each subplot\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], site_density(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", clims=clims, cbar=:none)\nend\n\n# The following 2 lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, background_subplot=:transparent, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), subplot=n^2+2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See more examples in the Tutorial section.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"danger: Outdated docs\nThis part of the documentation is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"internals/#AbstractGraph-API","page":"Internals","title":"AbstractGraph API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"A AbstractGraph, as described in the Pair selectors paragraph, is a lambda-like object.  Actually, everything that differs is a built-in sanity check algorithm ensuring that the lattice it is used on is a subset of the lattice it was defined on.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To implement this interface, you must inherit the LatticeModels.AbstractGraph class and define two methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.lattice(::YourSelector) must return the lattice your selector was defined on.\nLatticeModels.match(::YourSelector, site1::LatticeSite, site2::LatticeSite) must return whether the (site1, site2) pair is selected.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Let's take a look at the built-in DomainsSelector:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct DomainsSelector <: LatticeModels.AbstractAbstractGraph\n    domains::LatticeValue\nend\nLatticeModels.lattice(ps::DomainsSelector) = lattice(ps.domains)\nLatticeModels.match(ps::DomainsSelector, site1::LatticeSite, site2::LatticeSite) =\n    ps.domains[site1] == ps.domains[site2]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"It's quite likely though that the built-in AbstractGraphs will cover all your needs:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"DomainsSelector can split your lattice into different domains: pass a LatticeValue and the pair will be selected only if the values on both sites match.\nPairLhsGraph takes a boolean-typed LatticeValue and selects a site pair only if the value on the first site of the pair is true. Can be useful for creating a slit in the lattice sample.\nPairRhsGraph is the same as previous, but selects pairs by the second site of the pair.\nPairSet is an arbitrary set of site pairs - you can generate one by yourself or use the bonds function.\nYou may also find the pairs_by_distance function useful: it is not a AbstractGraph because it is lattice-independent, but you may find it convenient if you want to select site pairs depending on the distance between the sites in the pair.","category":"page"},{"location":"internals/#Custom-magnetic-fields","page":"Internals","title":"Custom magnetic fields","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"You can induce magnetic field by setting the vector potential overrightarrowA in every point of the space. This can be done by creating an AbstractField object: this is a lazy object that stores information about the magnetic field and implements the LatticeModels.vector_potential function that calculates the above-mentioned vector potential.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The int_r_1^r_2 overrightarrowA cdot overrightarrowdl integral is found automatically with the LatticeModels.line_integral function. The number of steps can be adjusted, but it is recommended to redefine this method for each new magnetic field type using an exact formula: this will improve performance and accuracy in most cases.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"You can use a convenience macro to simplify definition of new field types:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"@field_def struct LandauField(B::Number=1)\n    # Define the vector potential function\n    vector_potential(x) = (0, x*B)\n\n    # Redefine the integrating function\n    line_integral(p1, p2) = ((p1[1] + p2[1]) / 2) * (p2[2] - p1[2]) * B\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Let's see what happened here.  This macro created a new struct LandauField <: AbstractField with only one field B::Number and a constructor LandauField(B::Number=1).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"It also defined a suitable LatticeModels.vector_potential function. The only parameter in this function definition is x, which will be the X coordinate of the point (all other coordinate values will not be passed).  The return type must be Tuple or SVector to ensure that it can be converted to SVector by the default LatticeModels.line_integral implementation.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This field object is compatible with lattices of any dimension count. Undefined elements of the overrightarrowA vector will be set to zero, and \"excessive\" ones will be discarded.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"tip: Tip\nTo handle dimension-dependent behavior, you can use vector_potential(p...) = (0, p[1]*B) notation. Here p is a SVector which will allow you to yield different values depending on the dimension count.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"You may notice that here the LatticeModels.line_integral function was also redefined. It simply takes two SVectors describing the coordinates of p_1 and p_2 and returns the value of the int_p_1^p_2 overrightarrowA cdot overrightarrowdl path integral between them.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"tip: Tip\nTo control the accuracy and performance of the integration without redefining LatticeModels.line_integral,  set the default number of integration steps by adding n_steps := <desired number> to the struct definition.","category":"page"},{"location":"internals/#Custom-array-backends","page":"Internals","title":"Custom array backends","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"You can freely change the type of underlying arrays in LatticeArrays by using the @on_lattice macro. It will convert the internal array to the desired type and wrap it with the same Basis:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"using LatticeModels # hide\nX, Y = coord_operators(SquareLattice(50, 50), 2)\nXY = X * Y\nusing SparseArrays\nsp_XY = @on_lattice sparse(XY)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"In this example the @on_lattice macro transformed the call to sparse so that the internal array was passed to it,  and its output was wrapped into a LatticeArray. Thus, sp_XY here is an operator on a sparse matrix, but equal to XY. ","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Same way, you can send LatticeArrays to your GPU by calling @on_lattice cu(XY) from CUDA.jl.","category":"page"},{"location":"lattice_values/#LatticeValue-basics","page":"Lattice values","title":"LatticeValue basics","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"A LatticeValue is a struct that maps sites of a certain Lattice to values of some type.  One can be generated using a do-syntax similar to one in Sublattices:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"using LatticeModels, Plots","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"l = SquareLattice(10, 10)\nlv = LatticeValue(l) do (x, y); x + y + 1; end    # arbitrary site-dependent\nlv2 = rand(l)                               # uniformly distributed random numbers\nlv3 = randn(l)                              # normally distributed random numbers\nlv4 = ones(l)                               # 1 on all sites. Also zeros(l) is possible","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"To generate a tuple of LatticeValues for site coordinates, you can use the coord_values function. Note that LatticeValues support broadcasting, which means you can create coordinate-dependent lattice values in-place:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"x, y = coord_values(l)\nlv == x .+ y .+ 1","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"note: Note\nA wavefunction cannot and must not be stored as a LatticeValue, use LatticeVector instead.  The reason is that a LatticeValue does not take one-site phase spaces into account, which renders them unusable for these purposes.Linear algebra operations and @on_lattice wrapping are deliberately unsupported for LatticeValues.","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Lattice values implement a scatter plot recipe, which colors the plot markers according to the value:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"scatter(lv, markersize=10)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Depending on the lattice type, additional plot recipes can be available. For example, a lattice value on a square lattice can be plotted as a heatmap (which will be enabled by default if you do not specify the series type):","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"plot(lv, markersize=10)","category":"page"},{"location":"lattice_values/#Indexing","page":"Lattice values","title":"Indexing","text":"","category":"section"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"It is often required to select some sites by certain condition.  This can be done using a LatticeValue{Bool} and broadcasting (like with Sublattices).","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"In the example below we will delete all sites from the circle of radius 3 in the center of the lattice  (which will make the according heatmap regions blank).","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"heatmap(lv[@. √(x^2 + y^2) ≥ 10])","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"The approach from above provides a flexible way to edit LatticeValues:","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"lv2 = ones(l)\nlv2[@. x < y] = x .* y          # Assign another LatticeValue\nlv2[@. x ≥ y && x ≥ -y] .= 20   # or a number\nheatmap(lv2)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that a LatticeValue can be projected to some coordinate axis to create line plots. The projection axis is set by an axis descriptor (see Axis descriptors)","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"lv_on_line = lv[x = 5]\np = plot(layout=(2, 1))\n\nheatmap!(p[1], lv)\nplot!(p[1], lattice(lv_on_line), high_contrast=true)\nplot!(p[2], project(lv_on_line, :y))","category":"page"},{"location":"lattice_values/","page":"Lattice values","title":"Lattice values","text":"Note that we can show the sites we selected by plotting the lattice of the selected values with high_contrast=true. This options hides the indices and translucent marks, and also makes the plot markers black-and-white, which prevents them from blending in with the heatmap in the background.","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"manual/bonds/#Adjacency-and-boundary-conditions","page":"Adding bonds","title":"Adjacency and boundary conditions","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This chapter describes how to define bonds between sites in a lattice and how to use them to define boundary conditions.","category":"page"},{"location":"manual/bonds/#General-bonds","page":"Adding bonds","title":"General bonds","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"There are several ways to define bonds between sites in a lattice. The most general way is to define a function that takes two sites and returns if they are connected. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Generally, all objects that define bonds are subtypes of the AbstractBonds type. Here is a short overview of types of bonds that are supported by this package:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"AdjacencyMatrix — a simple matrix that defines if two sites are connected.\nSiteDistance — connectivity based on the distance between sites.\nNearestNeighbor — connects nearest neighbors on a given lattice. You can specify the order of the neighbors (e. g. first, second, etc.) by passing an integer to the constructor: NearestNeighbor(2).\nTranslation — connects two sites that are shifted by a certain vector.\nBravaisTranslation — connects two sites in a Bravais lattice unit cell. Unlike the Translation, it is defined in terms of the lattice axes and the site indices.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Let's begin with the AdjacencyMatrix. It is a simple wrapper around a boolean-valued matrix that defines if two sites are connected. Here is an example of how to use it:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\n\n# Define a nearest neighbor adjacency matrix\nadj = AdjacencyMatrix(l, NearestNeighbor())\n\n# Let's disconnect the center sites from the rest vertically\nfor x in 2:3\n    site1 = l[x=x, y=2]\n    site2 = l[x=x, y=1]\n    adj[site1, site2] = false\n\n    site3 = l[x=x, y=3]\n    site4 = l[x=x, y=4]\n    adj[site3, site4] = false\nend\n\nplot(adj)                   # Plot what we've got\nplot!(l, showbonds=false)   # And the lattice itself","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"As you can see, the adjacency matrix is a writable object, so you can change the bonds as you like. In this example we deleted vertical bonds between the four center sites and the boundary of the lattice.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"There are many ways to create an adjacency matrix — for example, you can use a function that takes two sites and returns if they are connected. This is useful when you need to define bonds in a more complex way:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"adj2 = AdjacencyMatrix(l) do site1, site2\n    dx = site1.x - site2.x\n    dy = site1.y - site2.y\n    return abs(dx * dy) == 1    # Diagonal bonds\nend\nplot(adj2)\nplot!(l, showbonds=false)","category":"page"},{"location":"manual/bonds/#Translations","page":"Adding bonds","title":"Translations","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"A \"translation\" is a special type of bonds that has a distinct direction (e. g. each pair of sites consists of a \"source\" and a \"target\" site). Also it must define exactly one destination for each source site (if any).","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"An example is the Translation — it allows defining bonds between sites that are shifted by a certain vector. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = GrapheneRibbon(6, 4)        # A convenient constructor for a honeycomb lattice\ntr = Translation(l, [1, 2√3/3])\nplot(tr)\nplot!(l, ls=:dash, linecolor=:grey)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Another type of translation is the BravaisTranslation. It translates sites on a Bravais lattice in terms of the lattice vectors:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"tr2 = BravaisTranslation(1 => 2, [0, 1])\ntr1 == tr2  # true","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"What does this notation mean? We take the first site in the unit cell; then we go to the unit cell shifted by [0, 1] and take the second site from there. Note that the first example described the same translation, but in terms of positions, not unit cell indices.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"note: Note\nYou can omit the pair of indices if you want to translate the unit cell regardless of the site index.  Bravais[j1, j2, ...] is shorthand for BravaisTranslation([j1, j2, ...]).    ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"You can use translations to shift a site, for example: site2 = site1 + tr, just like with regular vectors. Another  use-case for translations is in defining boundary conditions, as we will see in the next section.","category":"page"},{"location":"manual/bonds/#BoundaryConditions_chapter","page":"Adding bonds","title":"Boundary conditions","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"The most general form of boundary conditions supported by this package is this:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"psi(r + R) = psi(r) f(r)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"where R is a translation vector and f is some function. This is a generalization of periodic boundary conditions, which are a special case of this form.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"These conditions are in fact applied not to the lattice itself, but to the Hamiltonian. Think of it as a way to replace the c(r)^dagger c(r) hopping with c(r)^dagger c(r - R) f(r), if the r site is not present in the lattice, but r - R is.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"In general, there are three types of boundary conditions:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"PeriodicBoundary — the most common type of boundary conditions. Just periodicity with no factor.\nTwistedBoundary — periodicity with a phase factor that does not depend on r.\nFunctionBoundary —  general form of boundary conditions.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"The constructor for the boundary accepts two arguments — the phase (or the function) and the translation. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"As an example, let us consider the example with the Hofsadter butterfly from the Examples page. The magnetic field B changes from zero to one flux quantum per plaquette, for each value of B we calculate the energy spectrum of an infinite lattice and plot it. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Let's consider a periodic lattice instead. We want to apply magnetic field in the Landau gauge to it, and since  the translation operators include the vector potential mathcalA, we have to tweak the boundary conditions a little:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"psi(x + L_x y) = psi(x y) e^2pi i B y L_x\npsi(x y + L_y) = psi(x y)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This can be done with the FunctionBoundary:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = HoneycombLattice(10, 10)\nLx = 10\nLy = 5√3\nn_plaquettes = 100\nB_step = 1 / (Lx * Ly)          # Field step: one flux quantum through all plaquettes\nB_max = n_plaquettes * B_step   # Until one flux quantum per plaquette\n\npoints_E = Float64[]\npoints_B = Float64[]\nfor B in 0:B_step:B_max\n    f(site) = exp(2π * im * B * site.y * Lx)\n    xboundary = FunctionBoundary(f, [Lx, 0])\n    yboundary = PeriodicBoundary([0, Ly])\n    lb = setboundaries(l, xboundary, yboundary)\n    H = tightbinding_hamiltonian(lb, field=LandauGauge(B))\n    dg = diagonalize(H)\n    append!(points_E, dg.values)\n    append!(points_B, fill(B, length(dg.values)))\nend\nscatter(points_B, points_E, xlabel=\"B\", ylabel=\"E\", leg=false, ms=1)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Note that we could have set the boundary conditions to the lattice in one line. In fact, we already did this in the Examples section:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"lb = setboundaries(l, [Lx, 0] => f, [0, Ly] => true)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Let's explain this notation:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Each pair consists of a translation on the left and a \"boundary specifier\" on the right. A simple vector, like here, is interpreted as a Translation — you can use any translation type here, Bravais[-5, 10] instead of [0, Ly] would work as well.\nThe second argument can be one of the following:\ntrue/false — a periodic or open boundary condition.\nA number θ — a twisted boundary condition with a phase factor exp(im * θ).\nA function f — a general boundary condition.\nSometimes the lattice includes default translation axes, and you can use their aliases as translations.  For example, for a 10x10 square lattice setboundaries(l, :axis1 => f, :axis2 => true) is equivalent to setboundaries(l, [10, 0] => f, [0, 10] => true).","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Note that you can pass boundary conditions to the lattice constructor as well. We could not do this in the previous example, because the boundary conditions depended on the magnetic field B. However, if you have a fixed boundary condition, you can pass it to the lattice constructor like this:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"lb = HoneycombLattice(10, 10, boundaries=([Lx, 0] => f, [0, Ly] => true))","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This is equivalent to the setboundaries call from the previous example. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"note: Note\nIn our example we imposed periodic boundary conditions in shape of a rectangle 0  x  L_x, 0  y  L_y. However, the lattice itself is more like a parallelogram, because of its unit cell shape. This is not a problem, because this shape is still periodic in terms of these translations along x and y.If the periodicity is violated, for example, if the both r and r + R sites are present in the lattice, an error will be thrown.","category":"page"},{"location":"manual/bonds/#Generic-lattice","page":"Adding bonds","title":"Generic lattice","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"The GenericLattice is a tool you might want to use if you need to define a lattice with a more complex geometry. It is basically just a collection of arbitrary sites. As an example, let's define a lattice with a naive random geometry:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = GenericLattice{2}()         # 2D lattice\nfor i in 1:100\n    pt = rand(2) * 5\n    md = minimum(site -> norm(pt - site.coords), l, init=1.0)\n    md > 0.5 && push!(l, pt)    # Add a site if it is far enough from the others\nend\nl2 = setboundaries(l, [0, 5] => true, [5, 0] => true)  # Periodic boundary conditions\nbonds = SiteDistance(<(1), l2)  # Connect sites that are closer than 1\nplot(bonds)\nplot!(l2)       # Unlike Bravais lattices, GenericLattice does not have default bonds","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This tool is not very mature yet, but it can be useful for tasks not related to Bravais lattices. Note that boundary conditions or default nearest-neighbor hoppings can be set to the GenericLattice as well.","category":"page"},{"location":"manual/currents/#Currents_chapter","page":"Currents","title":"Currents","text":"","category":"section"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"This chapter covers the calculation of currents in the system.","category":"page"},{"location":"manual/currents/#Basics","page":"Currents","title":"Basics","text":"","category":"section"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents object is a collection of currents of some nature (e.g. charge, spin, etc.) from one site to another.  In most cases it is a lazy object that doesn't store the currents themselves, but rather the parameters to evaluate them on the go.","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"A good example of this is DensityCurrents, which calculates the charge currents between sites.","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"using LatticeModels, Plots\nl = SquareLattice(10, 10)\nH = tightbinding_hamiltonian(l)\nP = densitymatrix(H, statistics=FermiDirac, mu=0)\nH1 = tightbinding_hamiltonian(l, field=PointFlux(0.1, (5.5, 5.5)))\nC = DensityCurrents(H1, P)\nplot(C)","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Here we find the density matrix P of the system, add a magnetic field to the Hamiltonian to induce currents (H1), and calculate the charge currents between sites (C). The resulting plot shows the currents between sites.","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Currents can be indexed with sites to get the currents between them:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"site1 = l[!, x=1, y=1]; site2 = l[!, x=1, y=2]; site3 = l[!, x=1, y=3];\nC[site1, site2]\nC[site1, site3]         # Current between site1 and site3 is zero","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"You can evaluate all currents at once by converting the currents object to Currents. This can be useful when you want to perform non-trivial operations on the currents:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"C1 = Currents(C)\nC1[site1, site2] == C[site1, site2]","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Also note that the Currents object is writable:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"site4 = l[!, x=2, y=2]\nC1[site1, site4] = 0.05\nC1[l[!, x=10, y=10], l[!, x=9, y=9]] = 0.05\nplot(C1)","category":"page"},{"location":"manual/currents/#Common-Operations","page":"Currents","title":"Common Operations","text":"","category":"section"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"One function you may find useful is currentsfromto, which calculates currents between two sites or other domains. As an example, let's find how the currents through a circular sample depends on time:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"using LatticeModels, Plots\nl = SquareLattice{2}(Circle(10), !Circle(5))\nh(t) = tightbinding_hamiltonian(l, field=PointFlux(0.1 * t, (0, 0)))\nP = densitymatrix(h(0), statistics=FermiDirac, mu=0)\nτ = 10\nev = Evolution(t -> h(min(t, τ)), P)\ndom1 = l[x = 0 .. Inf, y = 0]\ndom2 = l[x = 0 .. Inf, y = 1]\ncurrs = TimeSequence(ev, 0:0.1:2τ) do (Pt, Ht, t)\n    Currents(DensityCurrents(Ht, Pt))    # Convert to Currents, since P is reused\nend\ncurrs_from_to = map(curr -> currentsfromto(curr, dom1, dom2), currs)\nplot(currs_from_to, title=\"Currents through the circle\")","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Here we perform a time evolution of the system with a magnetic field that is slowly increasing from 0 to 0.1 * τ, after which it remains constant. See the Evolution chapter for more details about time evolution.","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"The value we evaluated is the currents between two domains dom1 and dom2 at each time step. Here are  the domains:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"C = currs[τ]\nplot(C)\nplot!(dom1, label=\"Domain 1\")\nplot!(dom2, label=\"Domain 2\")","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Another useful function is currentsfrom, which calculates currents from a given domain (site or part of the lattice) to the rest of the lattice and returns a LatticeValue object.","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Let us continue with the previous example. This will calculate the currents from site1 in the bottom-left corner to the rest of the lattice:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"site = l[!, x = -7, y = 2]\nheatmap(currentsfrom(C, site), c=:balance, clims=(-0.06, 0.06))\nplot!(site, label=\"\", title=\"Currents from site $(site.coords)\")","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Also note that currents are iterable objects, yielding a tuple of source => target pair and the current value.  The order of the sites is such that the current is directed from the source to the target and is always positive. This can be useful to analyze, for example, the direction of the currents:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"cs = zeros(4)\nns = zeros(Int, 4)\nfor ((src, tgt), curr) in C\n    @assert curr >= 0\n    curr < 1e-6 && continue\n    x, y = normalize(tgt.coords - src.coords)\n    angle = atan(y, x)\n    idx = mod(round(Int, angle / (π / 2)), 4) + 1\n    cs[idx] += curr\n    ns[idx] += 1\nend\nbar([\"0\", \"π/2\", \"π\", \"3π/2\"], cs ./ ns, label=\"Average current by direction\")","category":"page"},{"location":"manual/currents/#Visualization","page":"Currents","title":"Visualization","text":"","category":"section"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"The currents can be visualized using the plot function. The values of the currents will be shown as arrows between the sites. The color of the arrows represents the magnitude of the currents. Also note that the opacity of the arrows is also proportional to the magnitude of the currents, which can be disabled by setting arrowtransparency=false. You can customize the appearance of the arrows using the arrowheadsize and arrowheadwidth keywords.","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"Here we will continue with the C currents obtained in the previous example:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"p = plot(layout = @layout[a b; _ c{0.5w} _], size=(1000, 1000))\nplot!(p[1], C, title=\"Default\")\nplot!(p[2], C, arrowtransparency=false, title=\"Opaque arrows\")  \nplot!(p[3], C, arrowheadsize=0.3, arrowheadwidth=1, arrowtransparency=false,\n    title=\"Custom arrowhead\")","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"You can plot an AbstractCurrents and a LatticeValue object in one axes. However, due to Plots.jl limitations, both series must share the same colorbar. You can bypass this by plotting them on separate axes, or by plotting the currents with a single color. In this case you need to set line_z=nothing to disable the colorbar for the arrows. Here is an example of plotting the currents and the lattice together:","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"plot(localdensity(P), st=:shape)\nplot!(C, c=:pink2, arrowheadsize=0.3, arrowheadwidth=0.6, line_z=nothing)","category":"page"},{"location":"manual/currents/","page":"Currents","title":"Currents","text":"tip: Tip\nTo make the plot more readable and even almost artistic, keep in mind that the arrows should be of similar hue, but different brightness compared to the background. This can be achieved by setting the arrows color to one that fits the background color palette.","category":"page"},{"location":"manual/lattice/#Lattices","page":"Defining the lattice","title":"Lattices","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This chapter describes the basic functionality of this package — creating and manipulating lattices.","category":"page"},{"location":"manual/lattice/#Basics","page":"Defining the lattice","title":"Basics","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Creating a lattice is simple. If you want to work with Bravais lattices, there are plenty of predefined types in the package. For example, to create a square lattice, you can use the SquareLattice type:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = SquareLattice(10, 10)\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This will create a 10x10 square lattice. Note that you can create a plot by simply using the plot function from the Plots package.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"SquareLattice(10, 10) notation means that we take a square lattice unit cell and translate it 10 times in the x and y directions. This syntax can be extended a little bit:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = HoneycombLattice(-2:2, -2:2)\nplot(l)\nplot!(l[j1 = 0, j2 = 0], c=:red, ms=6)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"What happened here? We created a honeycomb lattice by translating the unit cell from -2 to 2 in both directions. Then we plotted the lattice and highlighted the unit cell at the origin to make it more visible. l[j1 = 0, j2 = 0] allowed us selecting part of the lattice by specifying the indices of the unit cell (j1 and j2 are the indices of the unit cell in the first and second directions, respectively).","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"If we need to create a lattice with a less trivial shape, we can use any function we need:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = TriangularLattice(-10:10, -10:10) do site\n    return 4 < sqrt(site.x^2 + site.y^2) < 8     # Create a ring-shaped lattice\nend\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here the lattice constructor first translated the unit cell from -10 to 10 in both directions, and then applied the function to each site to create a ring-shaped lattice. This is similar to the filter function in Julia — in fact, you can use filter or filter! on an existing lattice to create a new one as well.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"There are other things you can control when creating a lattice, such as the lattice offset & rotation.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l1 = SquareLattice(-2:2, -2:2)\nl2 = SquareLattice(-2:2, -2:2, offset=:centeralign)\nl3 = SquareLattice(-2:2, -2:2, rotate=pi/3, offset=[6, -1.5])\nplot(l1, lab=\"No offset\", shape=:circle)\nplot!(l2, lab=\"Center the unit cell\", shape=:star)\nplot!(l3, lab=\"Shifted and rotated by π/3\", shape=:square)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"To find out more about offset and rotation, see UnitCell — the keywords are described there.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"note: Note\nIf you use both offset/rotation and a function to create a lattice, the function will be applied to the sites after the offset/rotation is applied. Use the postoffset and postrotate keywords to control the position and orientation of the lattice after the function is applied.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"The lattices implement the AbstractSet interface, so you can use all the set operations on them — union, intersect, setdiff etc.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l1 = SquareLattice(-2:0, -2:0)\nl2 = SquareLattice(0:2, 0:2)\nl3 = SquareLattice(-3:3, -3:3)\nl = setdiff(l3, union(l1, l2))\nplot(l)\nplot!(union(l1, l2), showbonds=false, alpha=0.3)","category":"page"},{"location":"manual/lattice/#Sites","page":"Defining the lattice","title":"Sites","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Let's find out what sites actually are. A site is generally a point in the lattice. It is defined by its position in space and maybe some additional properties. In case of a Bravais lattice these additional properties are unit cell indices and the index in the unit cell.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"A lattice is generally a set-like structure that allows indexing. Let's take a closer look in the REPL:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = HoneycombLattice(-2:2, -2:2)\nsite = l[1]     # Get the first site\nsite.x          # Get the x-coordinate of the site\nsite.j2         # Get the second index of the unit cell\nsite.index      # Get the index of the site in the unit cell\nx, y = site     # Destructure the site","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"As we see, we can access the properties of the site simply as fields of the site object. We can also destructure the site to get its coordinates.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"compat: Julia 1.8\nAccessing the properties of the site as fields like site.x requires Julia 1.8 and later. This limitation is imposed with purpose, since this seriously affects runtime performance in earlier versions. You will still be able to destructure the site to get its coordinates, or use the following fields:site.coords — the position of the site\nsite.latcoords — the unit cell indices\nsite.index — the index of the site in the unit cell","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Properties like x, j1, index etc. are part of a general SiteProperty interface. You can use them to create 'slices' of lattices:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"slice = l[j1 = 0 .. 2, j2 = -2 .. 0, index=1]  # Get a slice of the lattice\nplot(l)\nplot!(slice, c=:red, ms=6)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here 0 .. 2 and -2 .. 0 are intervals defining the ranges of the unit cell indices. You can use any collection instead of then if you need.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Finding sites by their properties can be done with the same notation:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l[x = 1.5, y = √3/2]    # Find the site with x = 1.5 and y = √3/2\nl[x = 1.2, y = 3]       # No such site, throws an error","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This is notation is convenient yet type-unstable, since it returns a Site object if there is one site satisfying the condition — otherwise a lattice is returned. To make sure that the result is indeed a site, add ! to the beginning of the condition:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l[!, x = 1.5, y = √3/2]    # Find the site with x = 1.5 and y = √3/2\nl[!, x = 1.5]              # More than one site, throws an error","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Note that pair notation is also supported. You can use it to access the properties of the site using the Coord and LatticeCoord types. For example, the following two lines are equivalent to ones above:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l[!, Coord(1) => 1.5, Coord(2) => √3/2] # Same as l[!, x = 1.5, y = √3/2]\nl[!, Coord(1) => 1.5]                   # Same as l[!, x = 1.5]","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This notation improves performance on Julia 1.7 and earlier, since it does not need any type-inference tricks to work fast. You may also find it useful when you work with multi-dimensional lattices.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here is a short list of site properties you can use:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"x, y, z — the position of the site. Alternatively, you can use x1, x2, x3, x4 and so on to access the coordinates of the site in the unit cell. Use Coord(i) to access the i-th coordinate using pair notation.\nj1, j2, j3 and so on — the indices of the unit cell. Use LatticeCoord(i) to access the i-th index using pair notation.\nindex — the index of the site in the unit cell. Use BasisIndex() to access it using pair notation.","category":"page"},{"location":"manual/lattice/#Custom-UnitCell","page":"Defining the lattice","title":"Custom UnitCell","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"You can also create a lattice from a custom unit cell:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\n# This will be our custom honeycomb lattice unit cell\n# First argument - vectors of the unit cell\n# Second argument - radius-vectors for the sites in the unit cell\nuc = UnitCell([[1/2, sqrt(3)/2] [-1/2, sqrt(3)/2]], [[0, sqrt(3)/6] [0, -sqrt(3)/6]])\nplot(uc)    # Plot the unit cell","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Note that both arguments are actually matrices — the first one is a matrix of the unit cell vectors, and the second one is a matrix of the site positions in the unit cell. However, here we used concatenation to create the matrices for the sake of readability: remember that [[a, b] [c, d]] is equivalent to [a c; b d].","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"To create a lattice, we can use the span_unitcells function:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = span_unitcells(uc, -5:5, -5:5) do site\n    x, y = site\n    return abs(y) < 5 && \n        abs(y * 1 / 2 + x * sqrt(3) / 2) < 5 && \n        abs(y * 1 / 2 - x * sqrt(3) / 2) < 5\nend   # Create a hex shape\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"In fact, the constructors we discussed earlier are just a shorthand for span_unitcells with a predefined unit cell. You can use span_unitcells to create a lattice from any unit cell you want.","category":"page"},{"location":"manual/lattice/#Shapes","page":"Defining the lattice","title":"Shapes","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"The shapes framework is a powerful tool for creating lattices of arbitrary geometry:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = SquareLattice{2}(Hexagon(10, [-10, 0]), Circle(10, [10, 0]))\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here we created a square lattice in shape of a hexagon and a circle. The first argument of the shape is its radius (for the hexagon it is the distance from its center to the vortices), and the second argument is the center of the shape. Other possible shapes include Box, Polygon, SiteAt and Path.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"complex_l = SquareLattice{2}(   # Here you have to specify the dimension of the lattice\n    Circle(10), Circle(10, [20, 0]), Circle(10, [10, 10√3]),\n    !Circle(5), !Circle(5, [20, 0]), !Circle(5, [10, 10√3]),\n    Box(-5 .. 5, -14 .. -12), Box(15 .. 25, -14 .. -12),\n    Path([-12, 32], [32, 32])\n)\nplot(complex_l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Note that adding ! before the shape inverts it. This is useful when you need to create a lattice with a hole in it.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"In some cases, the shapes may contain dangling sites. They tend to mess up the calculations, so you can remove them using the removedangling keyword or removedangling! function. By default, the software performs two passes to remove sites that are connected to only one other site, but you can specify the number of passes or set it to Inf to remove all dangling sites recursively:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = HoneycombLattice(Circle(3, [0, 0]), Circle(3, [-2, 10]), Path([0, 0], [-2, 10]), removedangling=false)\np = plot(size=(800, 350), layout=(1, 2))\nplot!(p[1], l, title=\"With dangling sites\")\nremovedangling!(l)\nplot!(p[2], l, title=\"Without dangling sites\")","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Let's discuss what is happening under the hood. The HoneycombLattice constructor calls the fillshapes function, which estimates the unitcells one has to span for each shape, and adds the sites that are in the shape to the lattice. ","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"You can also use addshapes! to add shapes to an existing lattice and deleteshapes! to remove them. These functions, however, do not support the ! notation for inverting shapes.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"One last, but not least, thing to mention is that this framework allows approximate scaling. If you need a lattice with distinct shape and, say, roughly 1000 sites, you can use the sites keyword to specify the number of sites you need:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = TriangularLattice(sites=1000, Circle(1, [-1, 0]), Circle(1, [1, 0]), Circle(1, [0, √3]))\nplot(l, title = \"$(length(l)) ≈ 1000 sites\")","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"You can also use the shaperadius function to estimate the radius of the shape that will give you the desired number of sites:[1]","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"circ = SquareLattice{2}(Circle(), sites=150)\nr = shaperadius(circ, Circle())\nplot(circ, lab = \"$(length(circ)) ≈ 150 sites\")\nplot!(Circle(r), c=:grey, ls=:dash, lab = \"r ≈ $r\")","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"[1]: Actually, the shaperadius function returns the scaling factor for the shape set. However, Circle() by default creates a circle with radius 1, so the scaling factor is equal to the radius of the circle.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"note: Note\nRadius estimation is not always precise and works under following assumptions:The shapes are large enough to contain the unit cell and do not intersect with each other.\nThe inverted shapes are all contained in the non-inverted ones, and also do not intersect with each other.","category":"page"},{"location":"manual/lattice/#Multi-dimensional-lattices","page":"Defining the lattice","title":"Multi-dimensional lattices","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This package supports multi-dimensional lattices. You can create a lattice of any dimension by creating a suitable unit cell first. Or by passing the required amount of axes to the lattice constructor, if the type supports it:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = SquareLattice(5, 4, 3)\nplot(l)     # A 3D cubic lattice","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Also remember that the dimensions of the lattice are not necessarily spatial dimensions. For example, you can create a bilayer Graphene lattice by defining a unit cell with two layers:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"# Bilayer Graphene with shifted layers\nuc = UnitCell([[1, 0, 0] [1/2, √3/2, 0]], \n    [[0, 0, 0] [1/2, √3/6, 0] [0, 0, √3/3] [-1/2, -√3/6, √3/3]]) \nl = span_unitcells(uc, -2:2, -2:2)\nplot(l, lc=:grey, zwiden=1.3)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Effectively, it is a 2D lattice in 3D space. Note that you can always project a multi-dimensional lattice or its slice to a 2D plane when plotting it:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"plot(l[index=(1, 2)], axes=(:x, :y))    # Plot the first layer","category":"page"},{"location":"manual/lattice/#Bonds-and-hoppings","page":"Defining the lattice","title":"Bonds and hoppings","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"In the scope of this package, bonds are not considered part of the lattice, but rather a separate structure that connects sites. You can assign nearest-neighbour hoppings to the lattice (of course, since you can see them on the plot), but in general the lattice and the bonds are separate entities. The reasoning behind this is that in some cases you may need to use different sets of bonds for different models.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"To find out more about bonds, adjacency and boundary conditions, see the next chapter: Adjacency and boundary conditions.","category":"page"},{"location":"manual/evolution/#Evolution_chapter","page":"Evolution","title":"Evolution","text":"","category":"section"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"This chapter describes several ways to work with time evolution of quantum systems on lattices. It features Evolution — a powerful struct that represents the time evolution of a quantum system according to the Schrödinger equation, and TimeSequence, which is used to store and process time-dependent data.","category":"page"},{"location":"manual/evolution/#Basics","page":"Evolution","title":"Basics","text":"","category":"section"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The Evolution struct is used to represent the time evolution of a quantum system. It contains the Hamiltonian and the initial state (or states) of the system. To evaluate the time evolution, you can write this:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"using LatticeModels, Plots\nlat = Chain(200)\n\n# Define the initial state: a Gaussian wavepacket\nx = coordvalue(lat, :x)\npsi0 = ketstate(@. exp(-0.02 * (x - 50) ^ 2 - im * 0.3x))\n\n# Define the Hamiltonian\nH = tightbinding_hamiltonian(lat)\n\n# Create the plot\nplot(title=\"Gaussian wavepacket evolution\", xlabel=\"x\", yticks=:none)\n# Empty plots for the legend\nplot!([NaN], c = :blue, label=\"Re\") \nplot!([NaN], c = :red, label=\"Im\")  \n\nev = Evolution(H, psi0)\nfor moment in ev(0:5:50)\n    psi, Ht, t = moment # Unpack to get the state, Hamiltonian and time\n    plot!(real.(psi.data) .+ t / 3, c=:blue, lab=\"\")\n    plot!(imag.(psi.data) .+ t / 3, c=:red, lab=\"\")\nend\nplot!()","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"We got a pretty plot of a Gaussian wavepacket moving to the right. Let us discuss what happened here in-depth.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"We set the Hamiltonian to be a constant operator. Since we perform the evolution in even time steps, and the Hamiltonian is not time-dependent, we can precompute the exponential of the Hamiltonian hatU = e^-i H t and use it in the evolution. This is done automatically here.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The Evolution struct is not an iterator. Instead, it is a callable object that returns an iterator. This is done to allow for more flexibility, as you can see below.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The Evolution struct always yields stateful iterators. This means that the psi in the loop is actually the same object, and it is updated on each iteration. This is done to reduce memory allocations and improve performance. Do not edit the states in the loop, as it will affect the results.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"This allows continuing the evolution from the last state. Let's stick to the previous example and add some more iterations:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"for moment in ev(50:5:100)\n    t = moment.t        # Get the time\n    psi = moment.state  # Get the state\n    # moment.H is the Hamiltonian, but it is not used here\n    plot!(real.(psi.data) .+ t / 3, c=:blue, lab=\"\")\n    plot!(imag.(psi.data) .+ t / 3, c=:red, lab=\"\")\nend\nplot!()","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"tip: Tip\nIf you do not need to iterate over a single Evolution object multiple times, you can use a shorthand. This notation:for moment in Evolution(H, psi0, timedomain=0:5:50)\n    # ...\nendis equivalent to this:ev = Evolution(H, psi0)\nfor moment in ev(0:5:50)\n    # ...\nend","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Note that we used a different notation to access the state and the time. You can use any of these two, whichever you find more convenient in your situation:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Fields: psi = moment.state; Ht = moment.H; t = moment.t\nUnpacking: psi, Ht, t = moment","category":"page"},{"location":"manual/evolution/#Multiple-initial-states","page":"Evolution","title":"Multiple initial states","text":"","category":"section"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The Evolution struct can also accept multiple initial states. Let's create two Gaussian wavepackets and evolve them:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"# Define the initial states: two Gaussian wavepackets\npsi0_1 = ketstate(@. exp(-0.02 * (x - 50) ^ 2 - im * 0.3x))\npsi0_2 = ketstate(@. exp(-0.02 * (x - 150) ^ 2 + im * 0.3x))\n\np = plot(title=\"Two Gaussian wavepackets evolution\", xlabel=\"x\", yticks=:none)\n\nev = Evolution(H, psi0_1, psi0_2)     # Pass the initial states as keyword arguments\nfor moment in ev(0:5:50)\n    psi1 = moment[1]\n    psi2 = moment[2]\n    t = moment.t\n    plot!(abs2.(psi1.data) .+ t / 3, c=:black, lab=\"\")\n    plot!(abs2.(psi2.data) .+ t / 3, c=:green, lab=\"\")\nend\nplot!()","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Note that accessing moment.state will throw an error here, because there is more than one state. Instead, you can access all them as a tuple with moment.states or each one separately with moment[1], moment[2], etc. Also you can still unpack the moment as psi1, psi2, Ht, t = moment, which will do the very same thing.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The Evolution struct also allows assigning aliases to the states. You can do this by passing the initial states as keyword arguments. This code will produce the same result as in the previous example:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"p = plot(title=\"Two Gaussian wavepackets evolution\", xlabel=\"x\", yticks=:none)\n\nev = Evolution(H, psi1=psi0_1, psi2=psi0_2)\nfor moment in ev(0:5:50)\n    t = moment.t\n    plot!(abs2.(moment.psi1.data) .+ t / 3, c=:black, lab=\"\")\n    plot!(abs2.(moment.psi2.data) .+ t / 3, c=:green, lab=\"\")\nend\nplot!()","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"moment.states will be a named tuple with the states in this case. This way you can access the states as moment.psi1, moment.psi2, etc. You can still use indices moment[1], moment[2] or unpack the moment as psi1, psi2, Ht, t = moment. The choice is yours.","category":"page"},{"location":"manual/evolution/#Time-dependent-Hamiltonian","page":"Evolution","title":"Time-dependent Hamiltonian","text":"","category":"section"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"If the Hamiltonian is time-dependent, you can pass a function that returns the Hamiltonian at the given time. This function should accept a single argument — the time. An example of a time-dependent Hamiltonian is the one with a magnetic field that changes in time from the Examples section:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"using LatticeModels, Plots\nl = TriangularLattice(Circle(10), !Circle(5))\nremovedangling!(l)\nh(B) = tightbinding_hamiltonian(l, field=PointFlux(B))\ndiag = diagonalize(h(0))\n\nP_0 = densitymatrix(diag, mu = 0)\nτ = 10\nht(t) = h(0.1 * min(t, τ) / τ)\nev = Evolution(ht, P_0)\n\nanim = @animate for moment in ev(0:0.1:2τ)\n    ρ, Ht, t = moment\n    curr = DensityCurrents(Ht, ρ)\n    plot(curr, title=\"t = $t\", clims=(0, 0.005), size=(1000, 700))\nend\ngif(anim, \"currents.gif\")","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Here we applied magnetic field that changes in time. The flux is increased linearly from 0 to 0.1 in 10 time units, and then stays constant. The animation shows the density currents in the lattice at each time step.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"To make the Hamiltonian time-dependent in the previous example, we defined a function ht(t) = h(0.1 * min(t, τ) / τ). This function returns the Hamiltonian with the flux 0.1 * min(t, τ) / τ at the given time t. The Evolution struct then uses this function to calculate the Hamiltonian at each time step.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The exponent for the time-dependent Hamiltonian is cached for each time step. This means that on the second half of the evolution interval, the exponent is calculated only once, and then reused for each time step. This improves performance. To improve it even more, you can pre-calculate the static Hamiltonian:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"const H1 = h(0.1)   # Make it constant to enforce type stability\nht(t) = t > τ ? H1 : h(0.1 * t / τ)","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"note: Note\nThe Evolution checks the Hamiltonian equality by storing a reference to the last Hamiltonian. Thes means that if you return the same object each time in the Hamiltonian function, the exponent will not be recalculated, even if you changed the Hamiltonian. To force the recalculation, wrap the return value into a Ref.Note that you can also use QuantumOptics.TimeDependentOperator interface — this might be more convenient, as it eliminates extra allocations more efficiently, and exponent caching for them is disabled by default.","category":"page"},{"location":"manual/evolution/#Solvers","page":"Evolution","title":"Solvers","text":"","category":"section"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The Evolution struct can use several solvers to calculate the time evolution. You can set the solver to use explicitly this way:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"ev = Evolution(CachedExp(threshold=1e-12, nztol=1e-15), H, psi0)","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The CachedExp solver is the default option, and it works in a very simple way: at each time step it calculates the exponent of the Hamiltonian hatU = e^-i H Delta t and applies it to the state. It also caches the exponent to avoid recalculating it if the Hamiltonian and the timestep are the same.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The exponent is calculated using a custom-implemented scaling and squaring algorithm. Contrary to the exp function from the LinearAlgebra package, it works with sparse matrices and GPU arrays also, while performance on dense matrices is comparable. However, some precision loss is possible, especially for large time steps, so you can adjust the tolerance for your case with these parameters:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"threshold — the threshold for the error in the exponent calculation. Limits the number of iterations in the Taylor series expansion. The default value is 1e-10.\nnztol — the tolerance for the zero elements in the Hamiltonian. Works only for sparse matrices — the elements with the absolute value less than nztol are considered zero. The default value is 1e-14.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The CachedExp solver is universal and works well in most cases. However, it is not the most efficient one. In some specific cases you might want to use a more specialized solver. For example, the KrylovKitExp solver can be faster if the Hamiltonian is large, sparse and dependent on time. It uses the exponentiate function from the KrylovKit package to calculate the exponent.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Let's run some performance tests:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"using LatticeModels\nl = SquareLattice(40, 40)\nh(B) = tightbinding_hamiltonian(l, field=LandauGauge(B))\n\n# The initial state is the ground state of the Hamiltonian with B = 0\npsi = groundstate(h(0))\nτ = 10\nht(t) = h(0.1 * min(t, τ) / τ)\nts = 0:0.1:2τ\nsite = l[!, x = 20, y = 20]\n\nprintln(\"CachedExp:\")\n# We can evaluate the density at x = 20, y = 20 in a one-liner\n@time dens1 = [localdensity(moment.state)[site] for moment in \n    Evolution(CachedExp(), ht, psi, timedomain=ts, showprogress=false)]\n@time dens1 = [localdensity(moment.state)[site] for moment in \n    Evolution(CachedExp(), ht, psi, timedomain=ts, showprogress=false)]\n@time dens1 = [localdensity(moment.state)[site] for moment in \n    Evolution(CachedExp(), ht, psi, timedomain=ts, showprogress=false)]\n\nprintln(\"\\nKrylovKitExp:\")\n@time dens2 = [localdensity(moment.state)[site] for moment in \n    Evolution(KrylovKitExp(), ht, psi, timedomain=ts, showprogress=false)]\n@time dens2 = [localdensity(moment.state)[site] for moment in \n    Evolution(KrylovKitExp(), ht, psi, timedomain=ts, showprogress=false)]\n@time dens2 = [localdensity(moment.state)[site] for moment in \n    Evolution(KrylovKitExp(), ht, psi, timedomain=ts, showprogress=false)]\nnothing # hide","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The first attempt took some time because of the precompilation required, but overall the KrylovKitExp solver turned out to be faster in this case. Let's plot the results to make sure they are the same:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"using Plots\nplot(ts, dens1, label=\"CachedExp\", xlabel=\"t\", ylabel=\"ρ(x=20, y=20)\", \n    ylims=(0, NaN), size=(800, 400))\nplot!(ts, dens2, label=\"KrylovKitExp\")","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"A significant drawback of KrylovKitExp solver is that it works only with wavefunctions — it does not support density matrices.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"note: Note\nGenerally, the Evolution struct supports only Schrödinger/von Neumann equations. If you need to solve the master equation, you can use the functions from the QuantumOptics package.However, a solver for the master equation can be implemented on top of the Evolution struct using this EvolutionSolver interface. Please file an issue if you are interested in this feature.","category":"page"},{"location":"manual/evolution/#TimeSequence_chapter","page":"Evolution","title":"TimeSequence","text":"","category":"section"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"The TimeSequence struct is used to store and manipulate time-dependent data. It is a dictionary-like object that maps time points to values. The values can be any type, including arrays, matrices, and even lattice-specific types like LatticeValue.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Let's calculate the evolution of a ground state of a tight-binding model after a magnetic field is adiaiabatically turned on. We will store the local density at each time step and use it to plot the local density depending on time, as well as its time derivative and integral over time:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"using LatticeModels, Plots\nl = SquareLattice(20, 20)\nh(B) = tightbinding_hamiltonian(l, field=LandauGauge(B))\n\n# The initial state is the ground state of the Hamiltonian with B = 0\npsi = groundstate(h(0))\nτ = 10\nht(t) = h(0.1 * min(t, τ) / τ)\ndensities = TimeSequence{LatticeValue}()\n\nfor moment in Evolution(ht, psi, timedomain=0:0.1:2τ)\n    densities[moment.t] = localdensity(moment.state)\nend\n\nplot(densities[!, x = 10, y = 10], label=\"ρ(t) (bulk)\")\nplot!(densities[!, x = 1, y = 10], label=\"ρ(t) (edge)\")","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"tip: Tip\nThe very same result could be achieved without writing the loop, using the TimeSequence constructor with a function. This way it will automatically iterate over the Evolution object and store the results:densities = TimeSequence(Evolution(ht, psi), 0:0.1:2τ) do moment\n    localdensity(moment.state)\nend","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Note that we can index a TimeSequence of LatticeValues the same way as a LatticeValue itself, which will produce another TimeSequence with the same time domain. This is because TimeSequence forwards almost all the indexing operations to the values it stores.","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"This type also supports time indexing and slicing. You can combine these types of indexing by using the t keyword for the time axis — all other arguments will be treated as spatial coordinates. Let's plot the local density at the center of the lattice and the local density at the edge of the lattice at the same time point:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"p = plot(layout=2, size=(1000, 500))\nplot!(p[1], densities[0.5])\nplot!(p[2], densities[!, x=10, y=10, t=0.5 .. 3.5], label=\"ρ(t) (bulk)\")\nplot!(p[2], densities[!, x=1, y=10, t=5 .. 10], label=\"ρ(t) (edge)\")","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"Another very useful feature of the TimeSequence is that it can be integrated and differentiated over time using the integrate and differentiate functions. Let's plot the time derivative and integral of the local density in the bulk of the lattice:","category":"page"},{"location":"manual/evolution/","page":"Evolution","title":"Evolution","text":"densities_bulk = densities[!, x = 10, y = 10]\nplot(densities_bulk, label=\"ρ(t) (bulk)\")\nplot!(differentiate(densities_bulk), label=\"dρ(t)/dt (bulk)\")\nplot!(integrate(densities_bulk), label=\"∫ρ(t)dt (bulk)\")","category":"page"},{"location":"library/#Internals","page":"API","title":"Internals","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-basics","page":"API","title":"Lattice basics","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"core/lattice.jl\", \"lattices/genericlattice.jl\", \"lattices/bravais/unitcell.jl\", \n    \"lattices/bravais/lattice.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractLattice, LatticeModels.AbstractSite)","category":"page"},{"location":"library/#LatticeModels.IncompatibleLattices","page":"API","title":"LatticeModels.IncompatibleLattices","text":"IncompatibleLattices([header, ]lat1, lat2)\n\nAn exception thrown when two lattices are incompatible.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteProperty","page":"API","title":"LatticeModels.SiteProperty","text":"SiteProperty\n\nAn abstract type for a property of a site.\n\nThis interface is used to define various properties of a site. They can be accessed using getsiteproperty. This interface is used in following places:\n\nlattice[...] syntax to access sites with specific properties.\nlattice_value[...] syntax to access values defined on sites with specific properties.\nFunctions to generate LatticeValues and operators for specific properties.\n\nExamples\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(3, 3);\n\njulia> l[x = 1, y = 2]          # Get site with x = 1 and y = 2\n2-dim Bravais lattice site in 2D space at [1.0, 2.0]\n\njulia> l[x = 1]                 # Get sublattice with x = 1\n3-site 2-dim Bravais lattice in 2D space\nUnit cell:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\nLattice type: SquareLattice{2}\nDefault translations:\n  :axis1 → Bravais[3, 0]\n  :axis2 → Bravais[0, 3]\nNearest neighbor hoppings:\n  1.00000 =>\n    Bravais[1, 0]\n    Bravais[0, 1]\n  1.41421 =>\n    Bravais[1, -1]\n    Bravais[1, 1]\n  2.00000 =>\n    Bravais[2, 0]\n    Bravais[0, 2]\nBoundary conditions: none\n\njulia> l[x = 1, y = 2, z = 3]   # No site with defined z property on a 2D lattice\nERROR: ArgumentError: Invalid axis index 3 of a 2-dim site\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.check_issublattice-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractLattice}","page":"API","title":"LatticeModels.check_issublattice","text":"Checks if l1 is sublattice of l2. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samelattice-Tuple{Any, Any}","page":"API","title":"LatticeModels.check_samelattice","text":"Checks if l1 and l2 objects are defined on the same lattice. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samesites-Tuple{Any, Any}","page":"API","title":"LatticeModels.check_samesites","text":"Checks if l1 and l2 objects are defined on the same sites. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractLattice}","page":"API","title":"LatticeModels.lattice","text":"lattice(any)\n\nReturn the lattice of the given object (an operator, LatticeValue, ...)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_index","page":"API","title":"LatticeModels.site_index","text":"site_index(lat, site[, range])\n\nReturn the index of the site in the lattice lat. If range is given, only search in the given range. Return nothing if the site is not found.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.GenericLattice","page":"API","title":"LatticeModels.GenericLattice","text":"GenericLattice{SiteT}\n\nA generic lattice of SiteT sites.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = GenericLattice{2}()\n0-site GenericLattice{GenericSite{2}} in 2D space\n\njulia> push!(l, GenericSite(0, 0))  # Add a site at (0, 0)\n1-site GenericLattice{GenericSite{2}} in 2D space:\n  Site at [0.0, 0.0]\n\njulia> push!(l, (0, 1))             # Add a site at (0, 1)\n2-site GenericLattice{GenericSite{2}} in 2D space:\n  Site at [0.0, 0.0]\n  Site at [0.0, 1.0]\n\njulia> push!(l, [1, 0])             # Add a site at (1, 0)\n3-site GenericLattice{GenericSite{2}} in 2D space:\n  Site at [0.0, 0.0]\n  Site at [0.0, 1.0]\n  Site at [1.0, 0.0]\n\njulia> l[2]\n2-dim GenericSite{2} at [0.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.GenericLattice-Tuple{LatticeModels.AbstractLattice}","page":"API","title":"LatticeModels.GenericLattice","text":"GenericLattice(lat)\n\nConstructs a GenericLattice from some other lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{N}} where N","page":"API","title":"LatticeModels.GenericLattice","text":"GenericLattice{N}()\n\nConstructs an empty N-dimensional GenericLattice of GenericSites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{SiteT}} where SiteT<:LatticeModels.AbstractSite","page":"API","title":"LatticeModels.GenericLattice","text":"GenericLattice{SiteType}()\n\nConstructs an empty GenericLattice of SiteType sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericSite","page":"API","title":"LatticeModels.GenericSite","text":"GenericSite{N}\n\nA generic site in an N-dimensional lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisSite","page":"API","title":"LatticeModels.BravaisSite","text":"BravaisSite{N,NU,B}\n\nA site of a BravaisLattice{N,NU,B} lattice.\n\nFields\n\nunitcell: a UnitCell object representing the lattice unit cell.\nlatcoords: a SVector of size N representing the lattice coordinates of the site.\nbasindex: an Int representing the index of the site in the lattice basis.\ncoords: a SVector of size N representing the spatial coordinates of the site.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.UnitCell","page":"API","title":"LatticeModels.UnitCell","text":"UnitCell(translations[, basis; offset, rotate])\n\nConstructs a Bravais lattice unit cell with given translation vectors and locations of basis sites.\n\nArguments\n\ntranslations: an AbstractMatrix of size N×N representing the translation vectors of the lattice.\nbasis: an AbstractMatrix of size N×NB representing the locations of basis sites.   If not provided, the lattice basis will consist of one site located in the bottom-left corner of the unit cell.\n\nKeyword arguments\n\noffset: a keyword argument that specifies how to shift the lattice basis.   Possible values:\n:origin: no shift (default).\n:center: shift the lattice so that the center of the basis is at the origin of the unit cell.\n:centeralign: shift the lattice so that the center of the basis is at the center of the unit cell.\nAlso accepts an AbstractVector of size N to shift the lattice by a custom vector.\nrotate: a keyword argument that specifies how to rotate the lattice basis.   Possible values:\nnothing: no rotation (default).\nAn AbstractMatrix of size N×N to rotate the lattice.\nA Real number to rotate the lattice by this angle in radians.\nAlso accepts an AbstractMatrix of size N×N to rotate the lattice basis.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{<:Integer, <:Integer}}, NU}}} where {N, NU, NB}","page":"API","title":"LatticeModels.span_unitcells","text":"span_unitcells([f, ]unitcell, dims...[; boundaries, offset])\n\nConstruct a Bravais lattice by spanning unitcell in dims dimensions, filtered by f.\n\nArguments\n\nf: a function that defines if the site is included in the lattice. Takes a BravaisSite, returns a Bool.\nunitcell: a UnitCell object.\ndims: a list of Integers or Ranges specifying the size of the lattice in each dimension.\n\nKeyword arguments\n\ndefault_translations: a list of BravaisTranslations to add to the lattice as default boundary condition axes.\nboundaries: a BoundaryConditions object specifying the boundary conditions of the lattice.\nrmdup: a Bool specifying whether to remove sites that are equivalent after applying the boundary conditions.\noffset: the offset of the lattice from the origin. See UnitCell for details.\nrotate: a rotation matrix to apply to the lattice. See UnitCell for details.\n\nKeep in mind that the offset and rotation are applied to the unit cell before the lattice is spanned (and f is applied). To apply them after the lattice is spanned, use the postoffset and postrotate keywords.\n\nExamples\n\njulia> using LatticeModels\n\njulia> using LatticeModels\n\njulia> uc = UnitCell([[1, 0] [0, 1]])\n1-site Unit cell of a 2-dim Bravais lattice in 2D space:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\n\njulia> span_unitcells(uc, 3, 3) == SquareLattice(3, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-constructors","page":"API","title":"Lattice constructors","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"zoo/lattices.jl\", \"zoo/shapes.jl\"]","category":"page"},{"location":"library/#LatticeModels.HoneycombLattice","page":"API","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nRepresents a honeycomb lattice.\n\nLattice vectors: [1, 0] and [0.5, √3/2], two sites at [0, 0] and [0.5, √3/6] in each unit cell.\n\n\n\nHoneycombLattice(a, b)\n\nConstruct a honeycomb lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.KagomeLattice","page":"API","title":"LatticeModels.KagomeLattice","text":"KagomeLattice\n\nRepresents a kagome lattice.\n\nLattice vectors: [1, 0] and [0.5, √3/2], three sites at [0, 0], [0.5, 0] and [0.25, √3/4] in each unit cell.\n\n\n\nKagomeLattice(a, b)\n\nConstruct a kagome lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"API","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nRepresents a square lattice in N dimensions.\n\n\n\nSquareLattice(sz...)\n\nConstruct a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TriangularLattice","page":"API","title":"LatticeModels.TriangularLattice","text":"TriangularLattice\n\nRepresents a triangular lattice. Lattice vectors: [1, 0] and [0.5, √3/2].\n\n\n\nTriangularLattice(a, b)\n\nConstruct a triangular lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Chain-Tuple{Function, Any}","page":"API","title":"LatticeModels.Chain","text":"Chain(sz)\n\nConstruct a 1D chain lattice of size sz.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GrapheneRibbon","page":"API","title":"LatticeModels.GrapheneRibbon","text":"GrapheneRibbon(len, wid[, center; kw...])\n\nConstruct a graphene ribbon sample with zigzag edges. To get armchair edges, simply rotate the lattice by 90 degrees.\n\nArguments\n\nlen: the length of the ribbon.\nwid: the width of the ribbon.\ncenter: the unit cell coordinates of the bottom-left corner of the ribbon. Default is (0, 0).\n\nAll other keyword arguments are passed to span_unitcells (see its documentation for details).\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.@bravaisdef-Tuple{Any, Any}","page":"API","title":"LatticeModels.@bravaisdef","text":"@bravaisdef MyBravaisLattice UnitCell(...)\n@bravaisdef MyBravaisLattice N -> UnitCell(...)\n\nDefine a new Bravais lattice type MyBravaisLattice with a unit cell constructor UnitCell(expr). If the notation is N -> UnitCell(expr), the unit cell constructor will be dependent on the dimensionality N. otherwise, the dimensionality will be inferred from the unit cell. N is the dimensionality of the lattice.\n\nExamples\n\njulia> using LatticeModels\n\njulia> @bravaisdef MyBravaisLattice UnitCell([1 0; 0 1]);   # 2D square lattice\n\njulia> MyBravaisLattice(3, 3)\n9-site 2-dim Bravais lattice in 2D space\nUnit cell:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\nLattice type: MyBravaisLattice\nDefault translations:\n  :axis1 → Bravais[3, 0]\n  :axis2 → Bravais[0, 3]\nNearest neighbor hoppings:\n  1.00000 =>\n    Bravais[1, 0]\n    Bravais[0, 1]\n  1.41421 =>\n    Bravais[1, -1]\n    Bravais[1, 1]\n  2.00000 =>\n    Bravais[2, 0]\n    Bravais[0, 2]\nBoundary conditions: none\n\n\n\n\n\n","category":"macro"},{"location":"library/#LatticeModels.BallND","page":"API","title":"LatticeModels.BallND","text":"BallND{N}([radius, center])\n\nConstruct a N-dimensional ball with a given radius and center. Note the aliases: Circle and Ball are BallND{2} and BallND{3} respectively.\n\nArguments\n\nradius: The radius of the ball.\ncenter: The center of the ball.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Box","page":"API","title":"LatticeModels.Box","text":"Box(intervals...)\n\nConstruct a box with given horizontal and vertical intervals. Usage: Box(1 .. 3, 2 .. 4).\n\nArguments\n\nintervals: The intervals for each dimension.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Path","page":"API","title":"LatticeModels.Path","text":"Path(start, stop)\n\nConstruct a path from start to stop.\n\nArguments\n\nstart: The start of the path.\nstop: The end of the path.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Polygon","page":"API","title":"LatticeModels.Polygon","text":"Polygon{N}([radius, center])\nPolygon{N}([center; h])\n\nConstruct a regular N-sided polygon with a given (circumscribed) radius and center. Note the aliases: Triangle, Square, and Hexagon are Polygon{3}, Polygon{4}, and Polygon{6} respectively.\n\nArguments\n\nradius: The (circumscribed) radius of the polygon.\ncenter: The center of the polygon.\n\nKeyword Arguments\n\nh: The distance from the center to the vertices. If given, the radius is calculated as h / cos(pi / N).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteAt","page":"API","title":"LatticeModels.SiteAt","text":"SiteAt(coords)\n\nRepresents a single site at the given coordinates.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.fillshapes-Union{Tuple{N}, Tuple{UnitCell{Sym, N} where Sym, Vararg{LatticeModels.AbstractShape}}} where N","page":"API","title":"LatticeModels.fillshapes","text":"fillshapes(uc, shapes...[; sites, scale, kw...])\n\nCreate a lattice sample with geometry defined by the given shapes. The lattice is filled with sites that are inside the shapes.\n\nArguments\n\nuc: The UnitCell of the lattice. Might also be a lattice type.\nshapes: The shapes to fill the lattice with.\n\nKeyword Arguments\n\nsites: If given, an attepmt will be made to fill the lattice with the given number of sites.   The scaling will be approximate and relying on assumptions that the shapes do not overlap.\nscale: The scaling factor for the shapes. If sites is given, the scaling factor will be   calculated automatically.\n\nAll other keyword arguments are passed to the lattice constructor. See span_unitcells for more information.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.removedangling!","page":"API","title":"LatticeModels.removedangling!","text":"removedangling!(lat[, maxdepth])\n\nRemove dangling sites from the lattice. A site is considered dangling if it has less than 2 neighbors. The function will remove all dangling sites and their neighbors recursively up to maxdepth levels — the default is Inf.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.shaperadius-Tuple{UnitCell, LatticeModels.AbstractShape, Int64}","page":"API","title":"LatticeModels.shaperadius","text":"shaperadius(unitcell, shape, sites)\nshaperadius(lat, shape[, sites])\n\nCalculate the radius of a shape such that it contains appriximately sites sites.\n\nArguments\n\nunitcell: The UnitCell of the lattice. Might also be a lattice type.\nlat: The lattice. It is considered that the lattice was constructed in the same shape.\nshape: The shape to calculate the radius for.\nsites: The number of sites the shape should contain.\n\n\n\n\n\n","category":"method"},{"location":"library/#Bonds","page":"API","title":"Bonds","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"core/bonds.jl\", \"lattices/bravais/bonds.jl\", \"lattices/bravais/nearestneighbor.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractBonds, LatticeModels.AbstractTranslation, \n    LatticeModels.DirectedBonds)","category":"page"},{"location":"library/#LatticeModels.AdjacencyMatrix","page":"API","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix{LT} where {LT<:Lattice}\n\nRepresents the bonds on some lattice.\n\n\n\nAdjacencyMatrix(lat[, mat])\n\nConstruct an adjacency matrix from the mat matrix on the lat lattice.\n\nIf mat is not provided, it is assumed to be a zero matrix.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(2, 2);\n\njulia> a = AdjacencyMatrix(l)\nAdjacency matrix on 4-site SquareLattice in 2D space\nValues in a 4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 0 stored entries:\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n\njulia> site1, site2, site3, site4 = l;\n\njulia> a[site1, site2] = a[site2, site4] = a[site3, site4] = true;\n\njulia> a\nAdjacency matrix on 4-site SquareLattice in 2D space\nValues in a 4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 6 stored entries:\n ⋅  1  ⋅  ⋅\n 1  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1\n ⋅  1  1  ⋅\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AdjacencyMatrix-Tuple{Function, LatticeModels.AbstractLattice}","page":"API","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix(f, lat)\n\nConstructs an adjacency matrix from the function f that returns if the sites are connected on the lat lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.AdjacencyMatrix-Tuple{LatticeModels.AbstractBonds, Vararg{LatticeModels.AbstractBonds}}","page":"API","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix([lat, ]bonds...)\n\nConstructs an adjacency matrix from the bonds. If lat is not provided, it is inferred from the bonds.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.SiteDistance","page":"API","title":"LatticeModels.SiteDistance","text":"SiteDistance(f, lat)\n\nA bonds type that connects sites based on the distance between them.\n\nArguments\n\nf: A function that takes a distance and returns if the distance is allowed.\nlat: The lattice where the bonds are defined.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Translation","page":"API","title":"LatticeModels.Translation","text":"Translation <: AbstractTranslation\n\nA spatial translation on some lattice.\n\nFields\n\nlat: The lattice where the translations are defined.\nR: The vector of the translation.\n\nExample\n\njulia> using LatticeModels\n\njulia> gl = GenericLattice([(1, 1), (1, 2), (2, 1), (2, 2)])\n4-site GenericLattice{GenericSite{2}} in 2D space:\n  Site at [1.0, 1.0]\n  Site at [1.0, 2.0]\n  Site at [2.0, 1.0]\n  Site at [2.0, 2.0]\n\njulia> tr = Translation(gl, [1, 0])     # Translation by [1, 0]\nTranslation by [1.0, 0.0]\n on 4-site GenericLattice{GenericSite{2}} in 2D space\n\njulia> site1 = gl[!, x = 1, y = 1]      # Site at [1, 1]\n2-dim GenericSite{2} at [1.0, 1.0]\n\njulia> site1 + tr                       # Translated site\n2-dim GenericSite{2} at [2.0, 1.0]\n\njulia> site1 - tr                       # Inverse translation\n2-dim GenericSite{2} at [0.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.UndefinedLattice","page":"API","title":"LatticeModels.UndefinedLattice","text":"UndefinedLattice\n\nA lattice that is not defined. The bonds can be 'defined' on it in context where the lattice is already defined before, e. g. in construct_operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.adapt_bonds-Tuple{Any, LatticeModels.AbstractLattice}","page":"API","title":"LatticeModels.adapt_bonds","text":"adapt_bonds(bonds, lat)\n\nAdapt the bonds to the lattice lat. The output can be a different type of bonds, more fitting for the concrete type of lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.adjacentsites-Tuple{AdjacencyMatrix, LatticeModels.AbstractSite}","page":"API","title":"LatticeModels.adjacentsites","text":"adjacentsites(bonds, site)\n\nReturns the sites that are connected to site by the bonds.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sitedistance-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}","page":"API","title":"LatticeModels.sitedistance","text":"sitedistance([lat, ]site1, site2)\n\nReturns the distance between two sites on the lat lattice, taking boundary conditions into account.\n\nArguments\n\nlat: The lattice where the sites are defined.\nsite1 and site2: The sites to measure the distance between.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.translate_to_nearest-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}","page":"API","title":"LatticeModels.translate_to_nearest","text":"translate_to_nearest(lat, site1, site2)\n\nTranslate site2 to its equivalent nearest to site1 in the lattice lat, taking the boundary conditions into account.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.Bravais","page":"API","title":"LatticeModels.Bravais","text":"Bravais[ lattice_coords ]\n\nA convenient constructor for a BravaisTranslation that does not permute sublattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisTranslation","page":"API","title":"LatticeModels.BravaisTranslation","text":"BravaisTranslation([site_indices, ]translate_uc)\nBravaisTranslation(site_indices)\nBravaisTranslation([site_indices; ]axis[, dist=1])\n\nA convenient constructor for a BravaisTranslation object.\n\nArguments\n\nsite_indices: a ::Int => ::Int pair with indices of sites connected by the bond;\n\nif omitted, the bond connects sites with the same sublattice index.\n\ntranslate_uc: The unit cell offset.\n\nKeyword arguments\n\naxis: The hopping direction axis in terms of unit cell vectors.\ndist: The hopping distance in terms of unit cell vectors.\n\nIf site_indices are equal or undefined and translate_uc is zero, the translation is considered to be a translation of all sites to themselves. An error will be thrown in this case.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisTranslation-2","page":"API","title":"LatticeModels.BravaisTranslation","text":"BravaisTranslation{T, N}\n\nA struct representing bonds in some direction in a lattice.\n\nNote that though the dimension count for the bond is static, it is automatically compatible with higher-dimensional lattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NearestNeighbor","page":"API","title":"LatticeModels.NearestNeighbor","text":"NearestNeighbor(lat[, N=1])\n\nReturns the nearest neighbor bonds of order N for the lattice lat.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = HoneycombLattice(5, 5);\n\njulia> NearestNeighbor(lat)\nBravaisSiteMapping with 3 translations:\n  1 => 2, [0, -1]\n  1 => 2, [-1, 0]\n  1 => 2, [0, 0]\n on 50-site HoneycombLattice in 2D space\n\njulia> lat = SquareLattice(3, 3, 3, 3);\n\njulia> NearestNeighbor(lat, 4)\nBravaisSiteMapping with 12 translations:\n  Bravais[1, -1, -1, -1]\n  Bravais[1, 1, -1, -1]\n  Bravais[1, -1, 1, -1]\n  Bravais[1, 1, 1, -1]\n  Bravais[2, 0, 0, 0]\n  Bravais[0, 2, 0, 0]\n  Bravais[0, 0, 2, 0]\n  Bravais[1, -1, -1, 1]\n  Bravais[1, 1, -1, 1]\n   ⋮\n on 81-site SquareLattice in 4D space\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NearestNeighbor-2","page":"API","title":"LatticeModels.NearestNeighbor","text":"NearestNeighbor{N}\n\nA bonds type that connects sites that are nearest neighbors of order N on some lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.getnnbonds-Tuple{LatticeModels.AbstractLattice}","page":"API","title":"LatticeModels.getnnbonds","text":"getnnbonds(lat)\n\nReturns the nearest neighbor bonds of the lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.setnnbonds-Tuple{LatticeModels.AbstractLattice, Vararg{LatticeModels.AbstractBonds}}","page":"API","title":"LatticeModels.setnnbonds","text":"setnnbonds(lat, args...; overwrite=false)\n\nAdds the nearest neighbor bonds args to the lattice lat. If overwrite is true, the default nearest neighbor bonds are replaced by args. Otherwise, the new bonds are merged with the default.\n\nEach args can be a bonds type or a distance-bonds pair.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(3, 3);\n\njulia> lat2 = setnnbonds(lat, SiteDistance(0 .. 1), SiteDistance(1 .. 2));\n\njulia> lat2.nnbonds\nNearest neighbor hoppings:\n  #1 =>\n    SiteDistance(0 .. 1)\n  #2 =>\n    SiteDistance(1 .. 2)\n\n\n\n\n\n","category":"method"},{"location":"library/#Boundary-conditions","page":"API","title":"Boundary conditions","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"core/boundaries.jl\"]","category":"page"},{"location":"library/#LatticeModels.BoundaryConditions","page":"API","title":"LatticeModels.BoundaryConditions","text":"BoundaryConditions\n\nA collection of boundary conditions for a lattice.\n\nFields\n\nbcs: A tuple of boundary conditions.\ndepth: The upper limit of the depth of the boundary conditions (used for routing).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.FunctionBoundary","page":"API","title":"LatticeModels.FunctionBoundary","text":"FunctionBoundary <: Boundary\n\nA boundary condition with a function that returns the phase factor for a given site. The boundary condition is encoded in form ψ(x + R) = f(x)ψ(x), where f(x) is the function and R is the translation vector.\n\n\n\nFunctionBoundary(f, translation)\n\nConstruct a FunctionBoundary with a given function and translation.\n\nArguments\n\nf: The function that returns the phase factor for a given site.\ntranslation: The translation vector of the boundary representad as AbstractTranslation.   If an array is passed, it is converted to Translation automatically.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TwistedBoundary","page":"API","title":"LatticeModels.TwistedBoundary","text":"TwistedBoundary <: Boundary\n\nA boundary condition with a phase twist. A PeriodicBoundary is a special case of TwistedBoundary with zero twist.\n\n\n\nTwistedBoundary(translation, Θ)\n\nConstruct a TwistedBoundary with a given translation and twist angle.\n\nArguments\n\ntranslation: The translation vector of the boundary representad as AbstractTranslation.   If an array is passed, it is converted to Translation automatically.\nΘ: The twist angle in radians.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PeriodicBoundary-Tuple{Any}","page":"API","title":"LatticeModels.PeriodicBoundary","text":"PeriodicBoundary(translation)\n\nConstruct a PeriodicBoundary with a given translation.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.setboundaries-Tuple{LatticeModels.AbstractLattice, BoundaryConditions}","page":"API","title":"LatticeModels.setboundaries","text":"setboundaries(lat, boundaries...[; checkboundaries=true, rmdup=false])\n\nSet the boundary conditions for the lattice lat.\n\nArguments\n\nlat: The lattice.\nboundaries: The boundary conditions. It can be a single Boundary or a Tuple of Boundary objects.\n\nKeyword arguments\n\ncheckboundaries: If true, check if the boundary conditions overlap within the lattice sites.\nrmdup: If true, remove duplicate sites from the lattice.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(4, 4);\n\njulia> l2 = setboundaries(l, [4, 0] => true, [0, 4] => pi);\n\njulia> l2.boundaries\nBoundary conditions (depth = 1):\n  Bravais[4, 0] → periodic\n  Bravais[0, 4] → twist θ = 3.14\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeValue","page":"API","title":"LatticeValue","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"core/latticevalue.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"API","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LT}\n\nRepresents a value of type T on a LT lattice.\n\nFields\n\nlattice: the AbstractLattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, AbstractVector}","page":"API","title":"LatticeModels.LatticeValue","text":"LatticeValue(lat, values)\n\nConstructs a LatticeValue object.\n\nArguments\n\nlat: the lattice the value is defined on.\nvalues: an AbstractVector of values on the lattice.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(2, 2);\n\njulia> LatticeValue(l, [1, 2, 3, 4])    # Custom values\nLatticeValue{Int64} on a 4-site SquareLattice in 2D space\nValues stored in a Vector{Int64}:\n[1, 2, 3, 4]\n\njulia> x = LatticeValue(l, :x)          # x-coordinate\nLatticeValue{Float64} on a 4-site SquareLattice in 2D space\nValues stored in a Vector{Float64}:\n[1.0, 1.0, 2.0, 2.0]\n\njulia> l2 = SquareLattice(3, 3);\n\njulia> y = LatticeValue(l2, :y)          # y-coordinate\nLatticeValue{Float64} on a 9-site SquareLattice in 2D space\nValues stored in a Vector{Float64}:\n[1.0, 2.0, 3.0, 1.0, 2.0, 3.0, 1.0, 2.0, 3.0]\n\njulia> x + y\nERROR: Matching lattices expected.\nGot following:\n  #1: 4-site SquareLattice in 2D space\n  #2: 9-site SquareLattice in 2D space\n[...]\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, LatticeModels.SiteProperty}","page":"API","title":"LatticeModels.LatticeValue","text":"LatticeValue(lat, prop)\n\nGenerates a LatticeValue representing the site property prop on lattice lat.\n\nArguments\n\nlat: the lattice the value is defined on.\nprop: the SiteProperty to be represented. Can be a SiteProperty or a Symbol defining it.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.brastate-Tuple{LatticeValue}","page":"API","title":"LatticeModels.brastate","text":"brastate(lv)\n\nConverts a LatticeValue to a Bra wavefunction vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coordvalue-Tuple{LatticeModels.AbstractLattice, Int64}","page":"API","title":"LatticeModels.coordvalue","text":"coordvalue(lat, coord)\n\nGenerates a LatticeValue representing the spatial coordinate coord on lattice lat.\n\nArguments\n\nlat: the lattice the value is defined on.\ncoord: the coordinate to be represented. Can be an integer or a symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coordvalues-Tuple{LatticeModels.AbstractLattice}","page":"API","title":"LatticeModels.coordvalues","text":"coordvalues(lat)\n\nGenerates a tuple of LatticeValues representing spatial coordinates on lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ketstate-Tuple{LatticeValue}","page":"API","title":"LatticeModels.ketstate","text":"ketstate(lv)\n\nConverts a LatticeValue to a Ket wavefunction vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#Operators-and-observables","page":"API","title":"Operators and observables","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"operators/bases.jl\", \"operators/miscoperators.jl\", \"operators/manybody.jl\", \n    \"operators/latticeutils.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeBasis","page":"API","title":"LatticeModels.LatticeBasis","text":"LatticeBasis <: QuantumOpticsBase.Basis\n\nBasis for a lattice system.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coordoperator-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}, Any}","page":"API","title":"LatticeModels.coordoperator","text":"coordoperator(sys, crd)\ncoordoperator(basis, crd)\ncoordoperator(lat[, internal], crd)\n\nGenerate a coordinate operator for the given lattice.\n\nArguments\n\nsys: a System for which the coordinate operators are to be generated.\nbasis: a one-particle Basis for which the coordinate operators are to be generated.\nlat: a lattice for which the coordinate operators are to be generated.\ninternal: The basis for the internal degrees of freedom.\ncrd: The coordinate to generate the operator for. Must be an integer representing the   coordinate index (e. g. 1 for x, 2 for y, etc.) or a symbol (e. g. :x, :y, etc.).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coordoperators-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"API","title":"LatticeModels.coordoperators","text":"coordoperators(sys)\ncoordoperators(basis)\ncoordoperators(lat[, internal])\n\nGenerate a Tuple of coordinate operators for the given lattice.\n\nArguments\n\nsys: a System for which the coordinate operators are to be generated.\nbasis: a one-particle Basis for which the coordinate operators are to be generated.\nlat: a lattice for which the coordinate operators are to be generated.\ninternal: The basis for the internal degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.interaction-Tuple{Function, Type{<:Number}, NParticles}","page":"API","title":"LatticeModels.interaction","text":"interaction(f, [T, ]sys)\n\nCreate an two-site interaction operator for a given NParticles system. The function f takes two arguments, which are the two sites, and returns the interaction energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.interaction-Union{Tuple{K}, Tuple{Function, Type{<:Number}, NParticles, Val{K}}} where K","page":"API","title":"LatticeModels.interaction","text":"interaction(f, [T, ]sys, K[; affect_internal=true])\n\nCreate an 2K-site interaction operator for a given NParticles system. The function f takes two K-tuples of integer numbers, which are site indices for creation and annihilation operators, and returns the interaction energy.\n\nIf affect_internal is true (default), the interaction operator will act on the internal degrees of freedom as well, and f will take four K-tuples — lattice and internal indices for creation and annihilation operators. If the system has no internal degrees of freedom, affect_internal will automatically be set to false and f will take two K-tuples.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.AdjacencyMatrix-Tuple{DataOperator{BT, BT} where BT<:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"API","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix(op::Operator)\n\nGenerates an AdjacencyMatrix for the provided operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.localdensity-Tuple{Union{DataOperator{var\"#s190\", var\"#s190\"}, Bra{var\"#s190\"}, Ket{var\"#s190\"}} where var\"#s190\"<:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"API","title":"LatticeModels.localdensity","text":"localdensity(state)\n\nCompute the local density of given state. The result is a LatticeValue with the same lattice as the input state.\n\nArguments\n\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.localexpect-Tuple{DataOperator, Union{DataOperator{var\"#s188\", var\"#s188\"}, Bra{var\"#s188\"}, Ket{var\"#s188\"}} where var\"#s188\"<:(CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT})}","page":"API","title":"LatticeModels.localexpect","text":"localexpect(op, state)\n\nCompute the expectation values of the operator op acting on the local Hilbert space of state. The result is a LatticeValue with the same lattice as the input state.\n\nArguments\n\nop: A DataOperator representing the operator.\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/#Hamiltonians","page":"API","title":"Hamiltonians","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"operators/system.jl\", \"operators/builder.jl\", \"operators/constructoperator.jl\",\n    \"operators/magneticfield.jl\", \"zoo/magneticfields.jl\"]","category":"page"},{"location":"library/#LatticeModels.Hamiltonian","page":"API","title":"LatticeModels.Hamiltonian","text":"Hamiltonian <: QuantumOpticsBase.DataOperator\n\nA wrapper for a Hamiltonian operator. Contains the operator matrix and the system it acts on.\n\n\n\nHamiltonian(sys, op)\n\nCreate a Hamiltonian operator for a given system and a given operator.\n\nArguments\n\nsys: the system the Hamiltonian acts on.\nop: the operator matrix.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(4, 4);\n\njulia> H = tightbinding_hamiltonian(l)\nHamiltonian(dim=16x16)\nSystem: One particle on 16-site SquareLattice in 2D space\n16×16 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 48 stored entries:\n⎡⠪⡢⠑⢄⠀⠀⠀⠀⎤\n⎢⠑⢄⠪⡢⠑⢄⠀⠀⎥\n⎢⠀⠀⠑⢄⠪⡢⠑⢄⎥\n⎣⠀⠀⠀⠀⠑⢄⠪⡢⎦\n\njulia> l2 = SquareLattice(5, 5);\n\njulia> H2 = tightbinding_hamiltonian(l2)\nHamiltonian(dim=25x25)\nSystem: One particle on 25-site SquareLattice in 2D space\n25×25 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 80 stored entries:\n⎡⠪⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠢⡈⠠⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠈⠢⡈⠊⡠⡈⠢⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⠢⡈⠪⠂⡈⠢⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠈⠢⡈⠪⡢⠈⠢⡀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠈⠢⡀⠪⡢⡀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠈⠀⎦\n\njulia> H + H2\nERROR: Incompatible Hamiltonians:\n  #1: One particle on 16-site SquareLattice in 2D space\n  #2: One particle on 25-site SquareLattice in 2D space\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NParticles-Union{Tuple{SampleT}, Tuple{SampleT, Any}} where SampleT<:LatticeModels.Sample","page":"API","title":"LatticeModels.NParticles","text":"NParticles(lat[, internal], N[; T=0, statistics=FermiDirac])\nNParticles(sys, N[; T=0, statistics=FermiDirac])\n\nCreate a manybody system with a given lattice and a given number of particles.\n\nArguments\n\nlat: the lattice of the system.\ninternal: The basis for the internal degrees of freedom.\nsys: a one-particle system.\nN: the number of particles in the system.\n\nKeyword Arguments\n\nT: the temperature of the system. Default is 0.\nstatistics: the statistics of the particles. Default is FermiDirac.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(3, 3);\n\njulia> NParticles(lat, 4, statistics=BoseEinstein)\nNParticles(4 bosons) on 9-site SquareLattice in 2D space\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.System-Tuple{LatticeModels.Sample}","page":"API","title":"LatticeModels.System","text":"System(lat[, internal; T, μ, N, statistics])\n\nCreate a system with a given lattice and optionally internal degrees of freedom.\n\nArguments\n\nlat: the lattice of the system.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword Arguments\n\nT: the temperature of the system. Default is 0.\nμ: the chemical potential of the system. Use mu synonym if Unicode input is not available.\nN: the number of particles in the system.\nstatistics: the statistics of the particles. Default is FermiDirac.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(3, 3);\n\njulia> System(lat)\nOne particle on 9-site SquareLattice in 2D space\n\njulia> System(lat, N=4, statistics=BoseEinstein)\n4 non-interacting bosons on 9-site SquareLattice in 2D space\n\njulia> System(lat, mu=0, statistics=BoseEinstein)\nNon-interactng bosons with fixed μ=0.0 on 9-site SquareLattice in 2D space\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sample-Tuple{LatticeBasis}","page":"API","title":"LatticeModels.sample","text":"Returns the Sample of the object.\n\nDefine this function for your type to implement Sample API.\n\ninfo: Info\nThis function can be considered stable internal API. Feel free to use it in your packages.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.OperatorBuilder","page":"API","title":"LatticeModels.OperatorBuilder","text":"OperatorBuilder\n\nA helper struct for building custom operators. This struct is used to build operators for a given system or lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.OperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{<:Number}, SystemT}} where {SystemT<:System, FieldT<:LatticeModels.AbstractField}","page":"API","title":"LatticeModels.OperatorBuilder","text":"OperatorBuilder([T, ]sys, [; field, auto_hermitian, occupations_type])\nOperatorBuilder([T, ]lat, [internal; field, auto_hermitian, occupations_type])\n\nConstruct an OperatorBuilder for a given system or lattice.\n\nArguments\n\nT: The type of the matrix elements. Defaults to ComplexF64.\nsys: A System object representing the system.\nlat: The lattice on which the operator is defined.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword arguments\n\nfield: The gauge field to use for the bond operators. Defaults to NoField(), which   corresponds to zero magnetic field.\nauto_hermitian: Whether to automatically add the hermitian conjugate of the operator.   Defaults to false.\noccupations_type: The occupations type for the many-body operator. Ignored for one-body   operators. By default, the occupation numbers are stored in vectors.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(5, 5);\n\njulia> builder = OperatorBuilder(l, field=LandauGauge(0.1), auto_hermitian=true)\nOperatorBuilder(field=LandauGauge(0.1), auto_hermitian=true)\nSystem: One particle on 25-site SquareLattice in 2D space\n\njulia> hx = Bravais[1, 0]; hy = Bravais[0, 1];\n\njulia> for site in l; builder[site, site + hx] = builder[site, site + hy] = 1; end\n\njulia> H = Hamiltonian(builder)\nHamiltonian(dim=25x25)\nSystem: One particle on 25-site SquareLattice in 2D space\n25×25 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 80 stored entries:\n⎡⠪⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠢⡈⠠⡢⡈⠢⡀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠈⠢⡈⠊⡠⡈⠢⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⠢⡈⠪⠂⡈⠢⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠈⠢⡈⠪⡢⠈⠢⡀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠈⠢⡀⠪⡢⡀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠈⠀⎦\n\njulia> H == tightbinding_hamiltonian(l, field=LandauGauge(0.1))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.FastOperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{<:Number}, SystemT}} where {SystemT<:System, FieldT<:LatticeModels.AbstractField}","page":"API","title":"LatticeModels.FastOperatorBuilder","text":"FastOperatorBuilder([T, ]sys, [; field, auto_hermitian, occupations_type])\nFastOperatorBuilder([T, ]lat, [internal; field, auto_hermitian, occupations_type])\n\nConstruct an OperatorBuilder for a given system or lattice. This version of the constructor uses a slightly faster internal representation of the operator matrix, but only allows increment/decrement assignments: builder[site1, site2] += 1 is allowed, but builder[site1, site2] = 1 is not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.construct_hamiltonian-Tuple{Type, System, Vararg{Any}}","page":"API","title":"LatticeModels.construct_hamiltonian","text":"construct_hamiltonian([T, ]sys, terms...[; field])\nconstruct_hamiltonian([T, ]lat[, internal, terms...; field])\n\nConstruct a Hamiltonian for the given system. Does the same as construct_operator, but wraps the result in a Hamiltonian type.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.construct_operator-Tuple{Type, System, Vararg{Any}}","page":"API","title":"LatticeModels.construct_operator","text":"construct_operator([T, ]sys, terms...[; field])\nconstruct_operator([T, ]lat[, internal, terms...; field])\n\nConstruct an operator for the given system.\n\nEach of the terms describes a term of the Hamiltonian. The term can be given in several ways:\n\nA DataOperator on the lattice, internal or composite basis (will be matched automatically).\nA Pair of an \"internal\" and an \"on-lattice\" part (e.g. int_p => lat_p):\nThe \"internal\" part can be a DataOperator, a matrix or a number.\nThe \"on-lattice\" part can be a LatticeValue (represents a diagonal term), a site   (represents a local on-site potential), a bond (represents a hopping term) or a site1 => site2   pair (represents a single hopping).\nIdentity \"internal\" or \"on-lattice\" parts can be omitted.\n\nSee documentation for more details.\n\nArguments\n\nT: The element type of the Hamiltonian. Default is ComplexF64.\nsys: The System for which the Hamiltonian is constructed.\nlat: The lattice for which the Hamiltonian is constructed.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword Arguments\n\nfield: The gauge field to use for the bond operators. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.tightbinding_hamiltonian-Tuple{Type, System, Vararg{Any}}","page":"API","title":"LatticeModels.tightbinding_hamiltonian","text":"tightbinding_hamiltonian([T, ]sys[, args...; t1=1, t2=0, t3=0, field])\ntightbinding_hamiltonian([T, ]lat[, internal, args...; t1=1, t2=0, t3=0, field])\n\nConstruct a tight-binding Hamiltonian for the given system.\n\nArguments\n\nT: The element type of the Hamiltonian. Default is ComplexF64.\nsys: The System for which the Hamiltonian is constructed.\nlat: The lattice for which the Hamiltonian is constructed.\ninternal: The basis for the internal degrees of freedom.\n\nAll other arguments are interpreted as terms of the Hamiltonian and passed to construct_hamiltonian.\n\nKeyword Arguments\n\nt1, t2, t3: The hopping amplitudes for the nearest, next-nearest, and next-next-nearest   neighbors, respectively.\nfield: The gauge field to use for the bond operators. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GaugeField","page":"API","title":"LatticeModels.GaugeField","text":"GaugeField <: AbstractField\n\nA gauge field defined by a vector potential function.\n\n\n\nGaugeField(func; n)\n\nCreate a gauge field with a given vector potential function func.\n\nArguments\n\nfunc: a function that takes a point in space and returns the vector potential at this point as a SVector or Tuple.\nn: the number of steps to use in the trapezoidal rule integration.\n\nExample\n\nfield = GaugeField(n = 10) do p\n    (-0.5 * p[2], 0.5 * p[1], 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LineIntegralGaugeField","page":"API","title":"LatticeModels.LineIntegralGaugeField","text":"LineIntegralGaugeField <: AbstractField\n\nA gauge field defined by a line integral function.\n\n\n\nLineIntegralGaugeField(func)\n\nCreate a gauge field with a given line integral function func. The function should take two points in space and return the line integral of the vector potential between these points.\n\nExample\n\nfield = LineIntegralGaugeField() do p1, p2\n    0.5 * (p1[1] * p2[2] - p1[2] * p2[1])   # A = [-y/2, x/2, 0]\nend\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NoField","page":"API","title":"LatticeModels.NoField","text":"NoField <: AbstractField\n\nA stub object representing zero magnetic field. Use it as a default magnetic field argument in functions — this will not cause any performance overhead.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}","page":"API","title":"LatticeModels.line_integral","text":"line_integral(field, p1, p2[, n_steps=1])\n\nCalculates the int_p1^p2 overrightarrowA cdot overrightarrowdl integral using the trapezoidal rule. Increase n_steps to improve accuracy (note that for linear field gauges like Landau or symmetrical the formula is already pefrectly accurate). If needed, redefine this function for specific field types — this is likely to boost accuracy and performance.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}","page":"API","title":"LatticeModels.vector_potential","text":"vector_potential(field, point)\n\nReturns vector potential overrightarrowA for field in location point.\n\nThis function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.LandauGauge","page":"API","title":"LatticeModels.LandauGauge","text":"LandauGauge <: AbstractField\n\nAn object representing Landau gauge uniform magnetic field along z-axis.\n\nFields\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PointFlux","page":"API","title":"LatticeModels.PointFlux","text":"PointFlux{GaugeT} <: AbstractField\n\nAn object representing a small magnetic flux through given point. The field is directed along z-axis.\n\nFields\n\nflux: The magnetic flux value.\npoint: A Tuple of x and y coordinates of the point.\n\n\n\nPointFlux(flux, [point; gauge])\n\nConstruct a PointFlux object with given flux and point.\n\nThe optional gauge argument can be used to specify the gauge of the field. Possible values are :axial (A(r) = B times fracrr) and :singular (the the phase changes if the particle passes below the point). The default is :axial.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SymmetricGauge","page":"API","title":"LatticeModels.SymmetricGauge","text":"SymmetricGauge <: AbstractField\n\nAn object representing symmetrically gauged uniform magnetic field along z-axis.\n\nFields\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#Built-in-models","page":"API","title":"Built-in models","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"zoo/models.jl\"]","category":"page"},{"location":"library/#LatticeModels.bosehubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}","page":"API","title":"LatticeModels.bosehubbard","text":"bosehubbard([type, ]lat, N[; U, T, t1, t2, t3, field])\n\nhatH = sum_ij^textsites t_ij c^dagger_i c_j + sum_i^textsites fracU2 hatn_i (hatn_i - 1)\n\nGenerates a Bose-Hubbard model hamiltonian on given lattice lat.\n\nArguments\n\ntype: The element type of the resulting operator. Default is ComplexF64.\nN: The number of particles.\n\nKeyword arguments\n\nt1, t2, t3 denote the coefficient on first, second and third hoppings respectively.   By default t1 is equal to one, the rest are zero.\nU: The interaction strength. Default is zero.\nT: The temperature of the system. Default is zero.\nfield: The magnetic field. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.fermihubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}","page":"API","title":"LatticeModels.fermihubbard","text":"fermihubbard([type, ]lat, N[; U, T, t1, t2, t3, field])\n\nhatH = sum_ij^textsites t_ij c^dagger_i c_j + sum_i^textsites U hatn_i^uparrow hatn_i^downarrow\n\nGenerates a Fermi-Hubbard model hamiltonian on given lattice lat.\n\nArguments\n\ntype: The element type of the resulting operator. Default is ComplexF64.\nN: The number of particles.\n\nKeyword arguments\n\nt1, t2, t3 denote the coefficient on first, second and third hoppings respectively.   By default t1 is equal to one, the rest are zero.\nU: The interaction strength. Default is zero.\nT: The temperature of the system. Default is zero.\nfield: The magnetic field. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.haldane","page":"API","title":"LatticeModels.haldane","text":"haldane(lat, t1, t2[, m=0; T, μ, field, statistics])\n\nhatH = sum_i^textsublattice A m c^dagger_i c_i + sum_j^textsublattice B m c^dagger_j c_j + sum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) + sum_i j^text2-connected counter-clockwise left( i cdot t_2 c^dagger_i c_j + h c right)\n\nGenerates a Haldane topological insulator hamiltonian operator on given lattice lat.\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.hubbard-Tuple{Type, NParticles, Vararg{Any}}","page":"API","title":"LatticeModels.hubbard","text":"hubbard([type, ]sys[; U, T, t1, t2, t3, field])\n\nGenerates a Hubbard model hamiltonian on given manybody system sys.\n\nSee fermihubbard, bosehubbard for more specific models.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.kanemele-Tuple{System, Real, Real}","page":"API","title":"LatticeModels.kanemele","text":"kanemele(lat, t1, t2[; T, μ, field, statistics])\n\nhatH = sum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) + sum_i j^text2-connected counter-clockwise left( i cdot t_2 c^dagger_i σ_z c_j + h c right)\n\nGenerates a Kane-Mele hamiltonian operator on given lattice lat.\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use keyword mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.qwz-Tuple{LatticeValue}","page":"API","title":"LatticeModels.qwz","text":"qwz(m[; T, μ, field, statistics])\nqwz(lat[, m; T, μ, field, statistics])\n\nhatH = sum_i^textsites m_i c^dagger_i sigma_z c_i + sum_i^textsites left( c^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + c^dagger_i + haty fracsigma_z - i sigma_y2 c_i + h c right)\n\nGenerates a QWZ model hamiltonian operator on given square lattice lat.\n\nArguments\n\nm (either a LatticeValue or a number) defines the m_i factors\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"method"},{"location":"library/#Diagonalization","page":"API","title":"Diagonalization","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"spectrum.jl\"]","category":"page"},{"location":"library/#LatticeModels.Eigensystem","page":"API","title":"LatticeModels.Eigensystem","text":"Eigensystem{LT, MT} where {LT<:AbstractLattice, MT<:AbstractMatrix}\n\nEigenvalues and eigenvectors for some operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{<:LatticeModels.FixedMu}}","page":"API","title":"LatticeModels.densitymatrix","text":"densitymatrix(eig::Eigensystem[; T=0, μ, N, statistics, info=true])\n\nCreates an Operator representing a equilibrium density matrix, given the eigensystem eig of the Hamiltonian.\n\nThe resulting distribution will be Fermi-Dirac or Bose-Einstein if the statistics is specified, otherwise the Gibbs distribution will be used.\n\nKeyword arguments\n\nT is the temperature of the system. Default is zero.\nμ is the chemical potential. Use mu as a synonym if Unicode input is not available.\nN is the number of particles. If specified, the chemical potential is found automatically.\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\ninfo is a boolean flag to enable/disable logging. Default is true.\n\nNote that if eig is a diagonalized Hamiltonian, the μ, N and statistics parameters are inserted automatically.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diagonalize-Tuple{Hamiltonian, Val}","page":"API","title":"LatticeModels.diagonalize","text":"diagonalize(op::DataOperator[, routine; params...])\n\nFinds eigenvalues and eigenvectors for a Operator and stores them in an Eigensystem.\n\nTwo routines are available:\n\n:lapack uses the eigen function from the standard LinearAlgebra package.\n:krylovkit uses the Lanczos algorithm from the KrylovKit package.   Accepts following parameters:\nv0 is the starting vector. Default is rand(ComplexF64, size(op.data, 1)).\nn is the target number of eigenvectors. Default is 10.\nAll other keyword arguments are passed to the KrylovKit.eigsolve function. See its documentation for details.\n:auto automatically selects the routine based on the size of the operator.\n\nThe default routine is :lapack for dense operators. If the operator matrix is less than 5000×5000, it is automatically converted to a dense operator. In other cases :krylovkit is used.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(4, 4);\n\njulia> H = tightbinding_hamiltonian(l)\nHamiltonian(dim=16x16)\nSystem: One particle on 16-site SquareLattice in 2D space\n16×16 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 48 stored entries:\n⎡⠪⡢⠑⢄⠀⠀⠀⠀⎤\n⎢⠑⢄⠪⡢⠑⢄⠀⠀⎥\n⎢⠀⠀⠑⢄⠪⡢⠑⢄⎥\n⎣⠀⠀⠀⠀⠑⢄⠪⡢⎦\n\njulia> eig = diagonalize(H)\nDiagonalized Hamiltonian (16 eigenvectors)\nEigenvalues in range -3.23607 .. 3.23607\nSystem: One particle on 16-site SquareLattice in 2D space\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.findgroundstate-Tuple{LatticeModels.HamiltonianEigensystem}","page":"API","title":"LatticeModels.findgroundstate","text":"findgroundstate(eig::HamiltonianEigensystem)\nfindgroundstate(ham::Hamiltonian)\n\nFinds the ground state of a Hamiltonian. Returns the energy and the state.\n\nExample\n\neig = diagonalize(ham)\nE, ψ = findgroundstate(eig)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.groundstate-Tuple{Any}","page":"API","title":"LatticeModels.groundstate","text":"groundstate(eig::HamiltonianEigensystem)\ngroundstate(ham::Hamiltonian)\n\nFinds the ground state of a Hamiltonian. Returns the state.\n\nExample\n\neig = diagonalize(ham)\nψ = groundstate(eig)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{Any, LatticeModels.AbstractEigensystem}","page":"API","title":"LatticeModels.projector","text":"projector(f, eig::Eigensystem)\n\nReturns an Operator representing a function applied to the diagonalized operator defined by the formula below:\n\nhatmathcalP = sum_i f(A_i) psi_ipsi_i\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{LatticeModels.AbstractEigensystem}","page":"API","title":"LatticeModels.projector","text":"projector(eig::Eigensystem)\n\nreturns an Operator that projects onto the eigenvectors of the spectrum, defined by the formula below.\n\nhatmathcalP = sum_i psi_ipsi_i\n\n\n\n\n\n","category":"method"},{"location":"library/#Green's-function","page":"API","title":"Green's function","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"greenfunction.jl\"]","category":"page"},{"location":"library/#LatticeModels.GreenFunction","page":"API","title":"LatticeModels.GreenFunction","text":"GreenFunction\n\nA Green's function for a given lattice and Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.diagonalelements-Tuple{LatticeModels.GreenFunctionEval{<:System{<:LatticeModels.Sample{LT, Nothing} where LT}}}","page":"API","title":"LatticeModels.diagonalelements","text":"diagonalelements(gf::GreenFunctionEval)\n\nReturn the diagonal elements of the Green's function as a LatticeValue.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.dos-Tuple{LatticeModels.AbstractEigensystem, Any}","page":"API","title":"LatticeModels.dos","text":"dos(eig[, E; broaden])\ndos(gf[, E; broaden])\n\nCalculates the DOS (density of states) for a given eigensystem at energy E. If E is not specified, a function that calculates the DOS at a given energy is returned.\n\nArguments\n\neig is an Eigensystem or HamiltonianEigensystem.\ngf is a GreenFunction.\nE is the energy at which the DOS is calculated.\n\nKeyword arguments\n\nbroaden is the broadening factor for the energy levels, default is 0.1.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.greenfunction-Tuple{Any, Ket, Hamiltonian, Hamiltonian}","page":"API","title":"LatticeModels.greenfunction","text":"greenfunction(psi0, hamp, hamm[; E₀, tol, showprogress, kw...])\n\nCalculates the Green's function for a many-body system with a given initial state psi0.\n\nArguments\n\npsi0 is the initial state.\nhamp is the Hamiltonian for the subspace with one more particle than in psi0.\nhamm is the Hamiltonian for the subspace with one less particle than in psi0.\n\nKeyword arguments\n\nE₀ is the energy shift for the Green's function. Default is 0. Use E0 as a synonym   if Unicode input is not available.\ntol is the tolerance for the new eigenvectors. Default is 1e-5.\nshowprogress is a flag to show the progress bar. Default is true.\n\nAll other keyword arguments are passed to the diagonalize function. See its documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.greenfunction-Tuple{Any, LatticeModels.HamiltonianEigensystem{<:LatticeModels.OneParticleBasisSystem}}","page":"API","title":"LatticeModels.greenfunction","text":"greenfunction(ham_eig::HamiltonianEigensystem)\n\nCreates a Green's function for a given one-body Hamiltonian eigensystem.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ldos-Tuple{GreenFunction, Real, LatticeModels.AbstractSite}","page":"API","title":"LatticeModels.ldos","text":"ldos(gf::GreenFunction, E[, site; broaden])\nldos(gf::GreenFunction, site[; broaden])\n\nCalculates the LDOS (local density of states) for a given Green's function at energy E. broaden is the broadening factor for the energy levels, default is 0.1.\n\nIf site is not specified, the LDOS for all sites is calculated and returned as a LatticeValue. Otherwise, the LDOS for the given site is returned as a Real value.\n\nIf E is not specified, a function that calculates the LDOS at site site for given energy is returned.\n\n\n\n\n\n","category":"method"},{"location":"library/#Currents","page":"API","title":"Currents","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"currents.jl\", \"zoo/currents.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractCurrents, LatticeModels.AbstractTranslation)","category":"page"},{"location":"library/#LatticeModels.Currents","page":"API","title":"LatticeModels.Currents","text":"Currents <: AbstractCurrents\n\nA AbstractCurrents instance that stores values for all currents explicitly.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Currents-Tuple{LatticeModels.AbstractCurrents}","page":"API","title":"LatticeModels.Currents","text":"Currents(currents[, adjacency_matrix])\n\nCreates a Currents instance for currents.\n\nArguments\n\ncurrents: The AbstractCurrents object to be turned into Currents. That might be time-consuming,   because  this requires evaluation of the current between all pairs.\nadjacency_matrix: If provided, the current will be evaluated only between adjacent sites.\n\nExamples\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(4, 4); site1, site2 = lat[1:2];\n\njulia> H0 = tightbinding_hamiltonian(lat); psi = groundstate(H0);\n\njulia> H1 = tightbinding_hamiltonian(lat, field=LandauGauge(0.1));\n\njulia> currents = DensityCurrents(H1, psi)\nDensity currents for system:\nOne particle on 16-site SquareLattice in 2D space\n\njulia> c2 = Currents(currents)\nCurrents{SparseArrays.SparseMatrixCSC{Float64, Int64}} on 16-site SquareLattice in 2D space\n\njulia> c2[site1, site2] ≈ currents[site1, site2]\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.DensityCurrents","page":"API","title":"LatticeModels.DensityCurrents","text":"DensityCurrents <: AbstractCurrents\n\nDensity currents for given state and given hamiltonian.\n\n\n\nDensityCurrents(hamiltonian, state)\n\nConstructs a DensityCurrents object for given hamiltonian and state.\n\nArguments\n\nhamiltonian: A Hamiltonian object representing the Hamiltonian of the system.\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\n\nExample\n\nExamples\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(4, 4);\n\njulia> H0 = tightbinding_hamiltonian(lat); psi = groundstate(H0);\n\njulia> H1 = tightbinding_hamiltonian(lat, field=LandauGauge(0.1));\n\njulia> currents = DensityCurrents(H1, psi)\nDensity currents for system:\nOne particle on 16-site SquareLattice in 2D space\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LocalOperatorCurrents","page":"API","title":"LatticeModels.LocalOperatorCurrents","text":"LocalOperatorCurrents <: AbstractCurrents\n\nLocal operator (e. g. spin) currents for given state and given hamiltonian.\n\n\n\nLocalOperatorCurrents(hamiltonian, state, op)\n\nConstructs a DensityCurrents object for given hamiltonian and state.\n\nArguments\n\nhamiltonian: A Hamiltonian object representing the Hamiltonian of the system.\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\nop: A local (on-site) operator; either an Operator or a matrix of such.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(4, 4); site1, site2 = lat[1:2];\n\njulia> H0 = qwz(lat); psi = groundstate(H0);\n\njulia> H1 = qwz(lat, field=LandauGauge(0.1));\n\njulia> op = [1 0; 0 -1];            # Spin operator\n\njulia> currents = LocalOperatorCurrents(H1, psi, op)\nCurrents of Operator(Spin(1/2))\n 1   0\n 0  -1\nFor system:\nOne particle on (16-site SquareLattice in 2D space) ⊗ Spin(1/2)\n\njulia> op2 = one(SpinBasis(3//2));  # Invalid operator\n\njulia> LocalOperatorCurrents(H1, psi, op2)\nERROR: ArgumentError: Operator must be defined on the internal basis of the Hamiltonian.\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SubCurrents","page":"API","title":"LatticeModels.SubCurrents","text":"SubCurrents{CT<:AbstractCurrents} <: AbstractCurrents\n\nA lazy wrapper for a Currents object representing the same currents but on a smaller lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.currentsfrom-Tuple{LatticeModels.AbstractCurrents, Any}","page":"API","title":"LatticeModels.currentsfrom","text":"currentsfrom(currents, src)\n\nCreate a LatticeValue object with the currents from src region to all other sites.\n\nArguments\n\ncurrents: The AbstractCurrents object to process.\nsrc: The source region. Can be a site/collection of sites or a LatticeValue{Bool} mask.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.currentsfromto","page":"API","title":"LatticeModels.currentsfromto","text":"currentsfromto(currents, src[, dst])\n\nFinds the total current from src to dst regions. If dst is not provided, the current from src to all other sites is returned.\n\nArguments\n\ncurrents: The AbstractCurrents object to process.\nsrc: The source region.\ndst: The destination region.\n\nBoth src and dst can be a site/collection of sites or a LatticeValue{Bool} mask.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}","page":"API","title":"LatticeModels.lattice","text":"Gets the lattice where the given AbstractCurrents object is defined.\n\n\n\n\n\n","category":"method"},{"location":"library/#Evolution","page":"API","title":"Evolution","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"Modules = [LatticeModels]\nPages = [\"evolution.jl\", \"timesequence.jl\"]\nFilter = t -> t ∉ (LatticeModels.EvolutionSolver,)","category":"page"},{"location":"library/#LatticeModels.CachedExp","page":"API","title":"LatticeModels.CachedExp","text":"CachedExp([ham; threshold=1e-10, nztol=1e-14])\n\nA EvolutionSolver that finds the matrix exponential of the Hamiltonian and caches it. The matrix exponential is computed using a scaling and squaring method, so this solver works well with sparse or GPU arrays.\n\nArguments\n\nham: The Hamiltonian of the system. It can be an Operator or its matrix.\nthreshold: The threshold for the error in the matrix exponential.\nnztol: The tolerance for dropping small elements in the matrix exponential if it is   sparse.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Evolution","page":"API","title":"LatticeModels.Evolution","text":"Evolution([solver, ]hamiltonian, states...; timedomain, namedstates...)\n\nCreate an Evolution object that can be used to evolve states in time according to the Schrödinger equation.\n\nArguments\n\nsolver: A EvolutionSolver object that will be used to evolve the states. If omitted,   a CachedExp solver will be created.\nhamiltonian: The Hamiltonian of the system. It can be a matrix, a time-dependent operator   or a function that returns the Hamiltonian at a given time.\nstates and namedstates: The states to be evolved. They can be Ket wavefunctions or   DataOperator density matrices.\ntimedomain: The time domain to be used for the evolution. If omitted, the non-iterable Evolution   object will be returned, and you will be able to call it with   the time domain later.\n\nSee EvolutionSolver for more information about solvers.\n\nwarning: Warning\nPlease note that the Evolution object is a stateful iterator. This means that it keeps track of the current time and the states as they evolve. You can perform evolution multiple times, but the timeline will be kept and the states will be updated in place.Also do not edit the states in place, as this will affect the evolution. If you need to modify the states or save them, make a copy of them first.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.KrylovKitExp","page":"API","title":"LatticeModels.KrylovKitExp","text":"KrylovKitExp([ham; kw...])\n\nA EvolutionSolver that uses the exponentiate function from KrylovKit.jl to evolve the wavefunction vectors. This solver is useful for large, sparse, time-dependent Hamiltonians.\n\nArguments\n\nham: The Hamiltonian of the system. It can be an Operator or its matrix.\nkw...: Keyword arguments to be passed to exponentiate.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence","page":"API","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}\n\nA time-ordered sequence of values.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}","page":"API","title":"LatticeModels.TimeSequence","text":"TimeSequence(times, values)\n\nConstructs a TimeSequence with the given times and values.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Function, LatticeModels.EvolutionIterator}","page":"API","title":"LatticeModels.TimeSequence","text":"TimeSequence(f, ev, times)\nTimeSequence(f, ev_iter)\n\nConstructs a TimeSequence by iterating the evolution iterator ev and applying the function f to each moment.\n\nArguments\n\nf: A function that takes a moment and returns a value. The function is applied to each moment in the evolution.\nev: An Evolution object.\ntimes: A range of times to evaluate the function at.\nev_iter: An evoltuion iterator that yields moments. Think of it as ev(times).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Union{Tuple{}, Tuple{ET}} where ET","page":"API","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}()\n\nConstructs an empty TimeSequence with eltype ET.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate!-Tuple{TimeSequence}","page":"API","title":"LatticeModels.differentiate!","text":"differentiate!(tseq::TimeSequence)\n\nDifferentiate the values stored in tseq by time using the symmetric difference formula. The new values are written into tseq.\n\nExample\n\njulia> using LatticeModels\n\njulia> tseq = TimeSequence(0:0.1:10, 0:0.1:10)  # f(t) = t\nTimeSequence{Float64} with 101 entry\nTimestamps in range 0.0 .. 10.0:\n  0.0 => 0.0\n  0.1 => 0.1\n  0.2 => 0.2\n  0.3 => 0.3\n  0.4 => 0.4\n  0.5 => 0.5\n  0.6 => 0.6\n  0.7 => 0.7\n  0.8 => 0.8\n  ⋮\n\njulia> differentiate!(tseq)                     # f'(t) = 1\nTimeSequence{Float64} with 100 entries\nTimestamps in range 0.05 .. 9.95:\n  0.05 => 1.0\n  0.15 => 1.0\n  0.25 => 1.0\n  0.35 => 1.0\n  0.45 => 1.0\n  0.55 => 1.0\n  0.65 => 1.0\n  0.75 => 1.0\n  0.85 => 1.0\n  ⋮\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate-Tuple{TimeSequence}","page":"API","title":"LatticeModels.differentiate","text":"differentiate(tseq::TimeSequence)\n\nDifferentiate the values stored in tseq and create a copy; see differentiate!.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate!-Tuple{TimeSequence}","page":"API","title":"LatticeModels.integrate!","text":"integrate!(tseq::TimeSequence)\n\nIntegrate the values stored in tseq over time using the trapezoidal rule. The new values are written into tseq. The first value is set to zero.\n\nExample\n\njulia> using LatticeModels\n\njulia> tseq = TimeSequence(0:0.1:10, 0:0.1:10)  # f(t) = t\nTimeSequence{Float64} with 101 entry\nTimestamps in range 0.0 .. 10.0:\n  0.0 => 0.0\n  0.1 => 0.1\n  0.2 => 0.2\n  0.3 => 0.3\n  0.4 => 0.4\n  0.5 => 0.5\n  0.6 => 0.6\n  0.7 => 0.7\n  0.8 => 0.8\n  ⋮\n\njulia> integrate!(tseq)                         # F(t) = t^2 / 2\nTimeSequence{Float64} with 101 entry\nTimestamps in range 0.0 .. 10.0:\n  0.0 => 0.0\n  0.1 => 0.005\n  0.2 => 0.02\n  0.3 => 0.045\n  0.4 => 0.08\n  0.5 => 0.125\n  0.6 => 0.18\n  0.7 => 0.245\n  0.8 => 0.32\n  ⋮\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate-Tuple{TimeSequence}","page":"API","title":"LatticeModels.integrate","text":"integrate(tseq::TimeSequence)\n\nIntegrate the values stored in tseq and create a copy; see integrate!.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timerange-Tuple{TimeSequence}","page":"API","title":"LatticeModels.timerange","text":"timerange(tseq::TimeSequence)\n\nReturns the range of the timestamps of the TimeSequence.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timestamps-Tuple{TimeSequence}","page":"API","title":"LatticeModels.timestamps","text":"timestamps(tseq::TimeSequence)\n\nReturns the timestamps of the TimeSequence.\n\n\n\n\n\n","category":"method"},{"location":"library/#Internals-2","page":"API","title":"Internals","text":"","category":"section"},{"location":"library/","page":"API","title":"API","text":"LatticeModels.AbstractLattice\nLatticeModels.AbstractSite\nLatticeModels.AbstractBonds\nLatticeModels.DirectedBonds\nLatticeModels.AbstractTranslation\nLatticeModels.AbstractCurrents\nLatticeModels.LookupTable\nLatticeModels.EvolutionSolver\nLatticeModels.addlookuptable","category":"page"},{"location":"library/#LatticeModels.AbstractLattice","page":"API","title":"LatticeModels.AbstractLattice","text":"AbstractLattice{SiteT}\n\nAn abstract type for a lattice of SiteT sites.\n\nMethods for subtypes to implement\n\nlength(l::AbstractLattice): Return the number of sites in the lattice.\nsite_index(l::AbstractLattice, site::SiteT): Return the index of the site in the lattice.\ngetindex(l::AbstractLattice, i::Int): Return the site with the given index.\ngetindex(l::AbstractLattice, is::AbstractVector{Int}): Return an AbstractLattice with the sites at the given indices.\n\nOptional methods for mutable lattices\n\nemptymutable(l::AbstractLattice, ::Type{SiteT}): Return an empty mutable instance of lattice.\ncopymutable(l::AbstractLattice): Return a mutable copy of the lattice.\npush!(l::AbstractLattice, site::SiteT): Add a site to the lattice.\ndeleteat!(l::AbstractLattice, is::AbstractVector{Int}): Remove the sites with the given indices from the lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractSite","page":"API","title":"LatticeModels.AbstractSite","text":"AbstractSite{N}\n\nAn abstract type for a site of a N-dimensional lattice.\n\nFields\n\ncoords: A SVector of size N representing the spatial coordinates of the site.   All subtypes are expected to have this field.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractBonds","page":"API","title":"LatticeModels.AbstractBonds","text":"AbstractBonds{LT}\n\nAn abstract type for bonds on some lattice.\n\nMethods for subtypes to implement\n\nlattice(bonds::AbstractBonds): Returns the lattice where the bonds are defined.\nisadjacent(bonds::AbstractBonds, site1::AbstractSite, site2::AbstractSite):   Returns if the sites are connected by the bonds.\n\nOptional methods for subtypes to implement\n\nadapt_bonds(bonds::AbstractBonds, l::AbstractLattice)\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.DirectedBonds","page":"API","title":"LatticeModels.DirectedBonds","text":"DirectedBonds{LT} <: AbstractBonds{LT}\n\nAn abstract type for bonds on some lattice that have a direction.\n\nMethods for subtypes to implement\n\nlattice(bonds::DirectionalBonds): Returns the lattice where the bonds are defined.\ndestinations(bonds::DirectionalBonds, site::AbstractSite): Returns the sites where the\n\nsite is connected to, accounting for the direction of the bonds.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractTranslation","page":"API","title":"LatticeModels.AbstractTranslation","text":"AbstractTranslation{LT}\n\nAn abstract type for translations on some lattice.\n\nMethods for subtypes to implement\n\nlattice(bonds::AbstractTranslation): Returns the lattice where the translations are defined.\ndestination(bonds::AbstractTranslation, site::AbstractSite): Returns the site where the site is translated to.\n\nOptional methods for subtypes to implement\n\nadapt_bonds(bonds::AbstractTranslation, l::AbstractLattice):   Adapt the translation to the lattice l. The output can be a different type of   translation, more fitting for the concrete type of lattice.\ninv(bonds::AbstractTranslation): Returns the inverse of the translation, if any.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractCurrents","page":"API","title":"LatticeModels.AbstractCurrents","text":"AbstractCurrents\n\nSupertype for all type representing currents-like values on a lattice. Subtypes must implement Base.getindex(::Int, ::Int) and lattice functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LookupTable","page":"API","title":"LatticeModels.LookupTable","text":"LookupTable\n\nA helper data structure to quickly find the index of a site in a lattice.\n\nRelies on sitekey(site) and secondarykey(function) functions to determine the index of a site in the lattice.\n\nWorks well under following assumptions:\n\nThe sitekey is some integer property of the sites.\nThe sites in the lattice are ordered by sitekey.\nThe numbering is mostly contiguous, i.e. there are no (or few) gaps in the numbering.\nThe secondarykey is also integer, mostly contiguous, ordered and unique for all sites with the same sitekey.\n\nSet them to nothing to disable usage (this is the default behavior).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.EvolutionSolver","page":"API","title":"LatticeModels.EvolutionSolver","text":"EvolutionSolver\n\nAbstract type for solvers that can be used to evolve states in time according to the Schrödinger equation.\n\nSee also concrete implementations: CachedExp, KrylovKitExp.\n\nMethods to implement\n\nupdate_solver!(solver, hamiltonian, dt, force=false): Update the solver to evolve the   states according to the given Hamiltonian and time step. If force is true, the   solver should always update, even if the Hamiltonian and time step are seemingly the   same as the previous ones.\nstep!(solver, state, cache): Evolve the given state in time using the solver. The cache   argument is used to store intermediate results and can be nothing if the solver does   not need it.\nevolution_cache(solver, state): Return a cache object that can be used to store   intermediate results for the given state. Returns nothing if the solver does not need   a cache for the given state (this is the default implementation).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.addlookuptable","page":"API","title":"LatticeModels.addlookuptable","text":"addlookuptable(lat)\n\nAdds a lookup table to the lattice lat and returns the lattice with the lookup table.\n\nwarning: Warning\nMake sure you add the lookup table to the lattice after you stop making changes to it. Otherwise the results may be unpredictable.This operation is not in-place.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"This section contains the documentation for the internal structure of LatticeModels.jl. ","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"warning: Warning\nThis section of documentation is under construction. Some parts may be incomplete.","category":"page"},{"location":"internals/#Advanced-features","page":"Internals","title":"Advanced features","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These features can be useful in non-trivial cases, but are not necessary for basic usage.","category":"page"},{"location":"internals/#AbstractLattice-interface","page":"Internals","title":"AbstractLattice interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The base of LatticeModels.jl is its interfaces, allowing to define lattices with arbitrary geometry, topology and boundary conditions. The LatticeModels.AbstractLattice interface is the main interface for defining lattices.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Generally speaking, a lattice is a set of sites. Each site, in turn, has its spatial coordinates in its coords field and maybe some additional properties. It also must be a subtype of LatticeModels.AbstractSite.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that the bonds between sites and the boundary conditions are initially not part of the lattice, but are added to its metadata later.","category":"page"},{"location":"internals/#Basic-functions","page":"Internals","title":"Basic functions","text":"","category":"section"},{"location":"internals/#Site-lookup","page":"Internals","title":"Site lookup","text":"","category":"section"},{"location":"internals/#Mutable-lattices","page":"Internals","title":"Mutable lattices","text":"","category":"section"},{"location":"internals/#Site-properties","page":"Internals","title":"Site properties","text":"","category":"section"},{"location":"internals/#Lattice-metadata","page":"Internals","title":"Lattice metadata","text":"","category":"section"},{"location":"internals/#Shapes","page":"Internals","title":"Shapes","text":"","category":"section"},{"location":"internals/#AbstractBonds-interface","page":"Internals","title":"AbstractBonds interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.AbstractBonds interface is used to define different types of bonds between sites. Most generally speaking, such object is a mapping that decides if the sites are connected for each pair.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that there are three basic types of bonds in LatticeModels.jl:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.AbstractBonds: a most general interface. Basically, it is just a mapping from site pairs to boolean values.\nLatticeModels.DirectedBonds: this type of bonds defines a set of bonds that has a defined direction. The whole topology can be defined by the \"destination\" sites for each site. Since the bonds are usually sparse, the general performance of this type of bonds is much higher.\nLatticeModels.AbstractTranslation: this is a subtype of DirectedBonds, where every site has one or zero \"destination\" sites. This allows to increase the performance even more, and also to transform the sites in a convenient manner:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"site1 = lat[!, x = 1, y = 1]    # Get the site at [1, 1]\nT = Translation(lat, [1, 0])    # Translate the site by [1, 0] vector\nsite2 = site1 + T               # `site2` is at [2, 1]","category":"page"},{"location":"internals/#Adapting-bonds-to-the-lattice","page":"Internals","title":"Adapting bonds to the lattice","text":"","category":"section"},{"location":"internals/#Boundary-conditions","page":"Internals","title":"Boundary conditions","text":"","category":"section"},{"location":"internals/#Diagonalizing-the-Hamiltonian","page":"Internals","title":"Diagonalizing the Hamiltonian","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"It is very easy to diagonalize a matrix in Julia. However, problems can arise when the matrix is of some custom type (e. g. sparse or a GPU array). By default LatticeModels.jl makes use of KrylovKit.jl to solve the eigenproblem using the Lanczos algorithm for non-trivial matrix types. However, sometimes it is necessary to use a different algorithm. The LatticeModels.diagonalize_routine is a simple way to add a new algorithm to the default toolchain.","category":"page"},{"location":"internals/#EvolutionSolvers","page":"Internals","title":"EvolutionSolvers","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.EvolutionSolver interface is used to solve the time-dependent Schrödinger equation. It is used in the Evolution struct to perform unitary evolution. As with the diagonalization problem, one can add a new algorithm to the default toolchain by creating a new EvolutionSolver type.","category":"page"},{"location":"internals/#Currents","page":"Internals","title":"Currents","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.AbstractCurrents interface allows to define different types of currents on the lattice. This allows it to be a lazy object, which computes the currents only when needed.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To implement basic currents semantics, you need to define the following methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.lattice(your_currents): returns the lattice, on which the currents are defined.\nBase.getindex(your_currents, i::Int, j::Int): returns the current between sites with numbers i and j. This is done in such a manner, because you do not usually need the site properties to calculate the currents.","category":"page"},{"location":"manual/greenfunction/#GreenFunction_chapter","page":"Green's function","title":"Green's function","text":"","category":"section"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"This chapter is dedicated to the (time-ordered) Green's function formalism. It is a powerful tool for studying many-body systems, especially in the context of condensed matter physics. The Green's function is a matrix-valued function of two variables, which can be used to calculate various physical quantities, such as the density of states or some topological invariants.","category":"page"},{"location":"manual/greenfunction/#Introduction","page":"Green's function","title":"Introduction","text":"","category":"section"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"In the scope of this package, the (time-ordered) Green's function is defined by this formula:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"G_alphabeta(omega) = langle 0  hata_alpha frac1omega - (hatH - E_0) hata_beta^dagger  0 rangle + q cdot\nlangle 0  hata_alpha^dagger frac1omega + (hatH - E_0) hata_beta  0 rangle \nhspace1cm \nq = begincases 1  textfor fermions  -1  textfor bosons endcases","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"where H is the Hamiltonian of the system,  0 rangle is the ground state of the system (which is the vacuum for non-interacting systems), E_0 is its energy and hata_alpha and hata_beta are the annihilation operators of the basis states. The Green's function is a matrix-valued function of the frequency omega.","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"This is how we can calculate the Green's function in the package:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"julia> using LatticeModels\n\njulia> l = SquareLattice(3, 2);\n\njulia> H = tightbinding_hamiltonian(l);\n\njulia> G = greenfunction(diagonalize(H))\nGreen's function for 6-site SquareLattice in 2D space\n\njulia> G(0.1)       # Evaluate the Green's function at the frequency 0.1\nEvaluated Green's function for 6-site SquareLattice in 2D space\n6×6 Matrix{ComplexF64}:\n -0.209531+0.0im  0.0321264+0.0im  …  -0.108521+0.0im    1.04223+0.0im\n 0.0321264+0.0im  -0.209531+0.0im       1.04223+0.0im  -0.108521+0.0im\n  -1.05308+0.0im   0.212743+0.0im      -1.05308+0.0im   0.212743+0.0im\n  0.212743+0.0im   -1.05308+0.0im      0.212743+0.0im   -1.05308+0.0im\n -0.108521+0.0im    1.04223+0.0im     -0.209531+0.0im  0.0321264+0.0im\n   1.04223+0.0im  -0.108521+0.0im  …  0.0321264+0.0im  -0.209531+0.0im\n\njulia> site1 = l[!, x=1, y=1]; site2 = l[!, x=2, y=2];\n\njulia> G[site1, site2]\nGreen's function element (6 â†, 0 â bands)\n\njulia> G[site1, site2](0.1) == G(0.1)[site1, site2]\ntrue","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Note that the Green's function is evaluated by exactly diagonalizing the Hamiltonian. This is not the most efficient way to calculate it, but it is the easiest to implement. Use brackets G[site1, site2] to get the Green's function between two sites, and call it with a frequency to evaluate it. ","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"There are three main types that provide the Green's function functionality:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"The GreenFunction, which is the main type for Green's functions. It stores the diagonalized Hamiltonian in an efficient way to optimize the Green's function calculation. Can be indexed with sites (or (site, internal_ind) tuples) and called with a frequency.\nThe GreenFunctionElement, which is an element of the Green's function matrix. It stores the bands that correspond to the Green's function element. Can be called with a frequency.\nThe GreenFunctionEval, which is the result of the Green's function evaluation. It stores the evaluated Green's function and the lattice it corresponds to. Can be indexed with sites.","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Thus, G[site1, site2] creates a GreenFunctionElement object, while G(0.1) creates a GreenFunctionEval object. This explains why G[site1, site2](0.1) is the same as G(0.1)[site1, site2], but the former is more efficient — it doesn't have to evaluate the whole Green's function matrix.","category":"page"},{"location":"manual/greenfunction/#Many-body-Green's-function","page":"Green's function","title":"Many-body Green's function","text":"","category":"section"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"The Green's function can be evaluated for many-body systems as well. The formula remains the same, but the process of calculating it is a bit more complicated. You have to provide three Hamiltonian matrices for the N-1, N and N+1 particle systems. Here is how it's done:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\nH = bosehubbard(l, 2, U = 10) # Bose-Hubbard model, 2 particles\nHp1 = bosehubbard(l, 3, U = 10) # Bose-Hubbard model, 3 particles\nHm1 = bosehubbard(l, 1, U = 10) # Bose-Hubbard model, 1 particle\nG = greenfunction(H, Hp1, Hm1, showprogress=false)\nnothing # hide","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Here is what happens in the code above:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Firstly, we find the ground state of the N-particle system and its energy. These will be  0 rangle and E_0 in the Green's function formula.\nAct with the annihilation and creation operators on  0 rangle.\nUse greenfunction to calculate the Green's function for the N-particle system.\nThe Green's function will be evaluated by exactly diagonalizing the Hamiltonian — this is why greenfunction requires the Hamiltonians for N-1 and N+1 particles.\nFor large Hamiltonian matrices, full diagonalization can be slow. In this case, the Lanczos algorithm with hata_alpha^dagger  0 rangle as initial vectors will be used. ","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"This is how you do it in code, line-by-line:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\nH = bosehubbard(l, 2, U = 10) # Bose-Hubbard model, 2 particles\nE, psi = findgroundstate(H)\n\nHm1 = bosehubbard(l, 1, U = 10) # Bose-Hubbard model, 1 particle\nHp1 = bosehubbard(l, 3, U = 10) # Bose-Hubbard model, 3 particles\nG = greenfunction(psi, Hp1, Hm1, E0=E, showprogress=false)\nnothing # hide","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"This is equivalent to the example before, but it allows you to set the ground state of the system manually.","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Note that you can pass additional keyword arguments to greenfunction to control the diagonalization process. For example, the routine keyword argument allows you to choose the diagonalization routine, and the other keyword arguments are passed to the diagonalize function, see its documentation for more information.","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"warning: Warning\nRemember the order of the Hamiltonians in the greenfunction function. The first Hamiltonian should correspond to the N-particle system, the second to the N+1-particle system and the third to the N-1-particle system. If you pass them in the wrong order, an error will be thrown.","category":"page"},{"location":"manual/greenfunction/#Density-of-states","page":"Green's function","title":"Density of states","text":"","category":"section"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"The density of states (DOS) is a physical quantity that can be calculated from the Green's function. It is defined as:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"DOS(omega) = frac1pi textIm textTr G(omega - idelta)","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"where delta is the broadening. The DOS is a scalar function of the frequency omega. To showcase, let us calculate the DOS for the Bose-Hubbard model using the Green's function we calculated before:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"df = dos(G, broaden=0.1)\nplot(df, lab=\"\", xlab=\"ω\", ylab=\"DOS\", xlims=(-15, 45))","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"This will plot the DOS for the Bose-Hubbard model with a broadening of 0.1. The DOS is a scalar function of the frequency, so it can be plotted as a line plot. ","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Here dos produced a function that takes the frequency as an argument and returns the DOS at that frequency. You can also calculate the DOS for a specific frequency:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"dos(G, 0.1, broaden=0.1)\ndos(G, 0.1, broaden=0.1) == df(0.1)","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"You can also calculate the local density of states (LDOS) using the ldos function. Here is how you do it:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"ld = ldos(G, 0.1, broaden=0.1)\nplot(ld, st=:shape)","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Note that ld here is a LatticeValue object, which can be plotted as a shape plot. ","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"To efficiently calculate the LDOS on one site, use this notation:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"site = l[!, x=1, y=1]\nld_value = ldos(G, 0.1, site, broaden=0.1)\nld[site] == ld_value","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"This will calculate the LDOS on the site (1, 1) of the lattice. This notation is more efficient than calculating the LDOS for the whole lattice and then indexing it, as it doesn't have to calculate the LDOS for the whole lattice and allocate memory for it.","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"Let's compare the LDOS in the bulk of the lattice and on the edge:","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"site_bulk = l[!, x=2, y=2]\nsite_edge = l[!, x=1, y=2]\nld_bulk = ldos(G, site_bulk, broaden=0.1)\nld_edge = ldos(G, site_edge, broaden=0.1)\nplot(title=\"LDOS comparison\", xlims=(-10, 20), xlab=\"ω\", ylab=\"LDOS\")\nplot!(ld_bulk, lab=\"Bulk\")\nplot!(ld_edge, lab=\"Edge\")\nvline!([-1], lab=\"Edge modes\", c=:grey, ls=:dash)","category":"page"},{"location":"manual/greenfunction/","page":"Green's function","title":"Green's function","text":"This will plot the LDOS for the bulk and the edge of the lattice. Note the edge modes — they are visible as peaks in the edge LDOS around ω = -1.","category":"page"},{"location":"manual/hamiltonian/#Systems-and-Hamiltonians","page":"Constructing the Hamiltonian","title":"Systems and Hamiltonians","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"This section describes how to define the Hamiltonian of a system. The system, in this context, is a lattice, a basis describing on-site degrees of freedom, and some additional parameters like temperature or chemical potential.","category":"page"},{"location":"manual/hamiltonian/#Defining-the-system","page":"Constructing the Hamiltonian","title":"Defining the system","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"First of all, we need to define the system. This is done by calling System. For example, if we want to create non-interacting fermions with spin 1/2, zero chemical potential and temperature 1, we can do the following:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4);\nsys = System(l, SpinBasis(1//2), μ = 0, T = 1)\nH = tightbinding_hamiltonian(sys)\nP = densitymatrix(H, info=false)\nheatmap(localdensity(P))","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"In this case we have created a system with defined chemical potential and temperature. Note that you can use mu instead of μ if you prefer (or if you are using a non-UTF8 compatible editor). The tightbinding_hamiltonian function creates a tight-binding Hamiltonian for the given system, and the densitymatrix function calculates the density matrix.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"The first two arguments of the System constructor are the lattice and the basis of the on-site degrees of freedom.  The latter can be any QuantumOptics.Basis object — refer to the QuantumOptics.jl documentation for more information. Omit the second argument if you don't have any on-site degrees of freedom.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Here are all parameters that can be passed to the System constructor:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"mu or μ: the chemical potential of the system.\nN: set this instead of mu to fix the number of particles — the chemical potential will be calculated automatically. Setting both N and mu will raise an error.\nstatistics: the statistics of the particles, either FermiDirac or BoseEinstein. If not set, the statistics is FermiDirac if mu or N is set, and Gibbs otherwise (i.e. the system consist of one particle).\nT: the temperature of the system. The default is 0.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Note that you can pass the very same arguments directly to the tightbinding_hamiltonian. Also keyword arguments  can be passed to the densitymatrix function — they will be used to evaluate the distribution function. These  lines are equivalent to the previous example:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"H = tightbinding_hamiltonian(l, SpinBasis(1//2))\nP = densitymatrix(H, μ = 0, T = 1, info = false)","category":"page"},{"location":"manual/hamiltonian/#Basic-tight-binding-Hamiltonian","page":"Constructing the Hamiltonian","title":"Basic tight-binding Hamiltonian","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"The tightbinding_hamiltonian function creates a basic tight-binding Hamiltonian defined by this formula:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"H = t_1 sum_langle i j rangle c_i^dagger c_j + texthc + \n    t_2 sum_langlelangle i j ranglerangle c_i^dagger c_j + texthc + \n    t_3 sum_langlelanglelangle i j rangleranglerangle c_i^dagger c_j + texthc +\n    ldots","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"where c_i^dagger and c_i are the creation and annihilation operators on site i. The t_1, t_2 and t_3 are responsible for the hopping between the nearest, next-nearest, etc. neighbors. Note that they can be factors or operators that act on the on-site degrees of freedom.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"By default only the nearest-neighbor hopping is included, all other factors are zero. You can set them to any value you want using the t1, t2, t3, keyword arguments:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"sz = sigmaz(SpinBasis(1//2))\nH2 = tightbinding_hamiltonian(sys, t1 = sz, t2 = [1 0; 0 -1], t3 = -0.5)\nP2 = densitymatrix(H2, info=false)\nheatmap(localdensity(P2))","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Here sz is the operator that projects the spin on the z axis. Note that we can use a matrix instead, how we did with t2: in this case it will be interpreted as the hopping operator acting on the on-site degrees of freedom.","category":"page"},{"location":"manual/hamiltonian/#The-constructor-function","page":"Constructing the Hamiltonian","title":"The constructor function","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"There are many cases where more complex Hamiltonians are needed. In this case, you can use the construct_hamiltonian function. This function takes a system and several arguments, each describing a term in the Hamiltonian. As an example, let's consider the same Hamiltonian as in the previous example:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\nspin = SpinBasis(1//2)\nsys = System(l, spin, μ = 0, T = 1)\n\nsz = sigmaz(spin)\nH = construct_hamiltonian(sys, \n    sz => NearestNeighbor(1),\n    [1 0; 0 -1] => NearestNeighbor(2),\n    -0.5 => NearestNeighbor(3))\nP = densitymatrix(H, info=false)\nheatmap(localdensity(P))","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Basically, every term is a pair of an operator acting on the on-site degrees of freedom and an object describing the lattice part. The lattice part can be one of the following:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"On-site term: sum_i t_i c_i^dagger c_i. In this case, the operator is applied to every site.\nA single site describes a single t_i c_i^dagger c_i term. A convenient way to create an on-site potential.\nA LatticeValue object describes the t_i coefficients for every site.\nHopping term: sum_langle i j rangle t_ij c_i^dagger c_j + hc. Terms like this are used to describe the hopping between different sites.\nA single site1 => site2 pair describes a single hopping term between site1 and site2.\nAn AbstractBonds object describes the hopping topology. See the Adjacency and boundary conditions section for more information on them.\nArbitrary operator: any QuantumOptics.Operator object can be passed as a term, in which case it will be automatically embedded into the Hamiltonian.\nNote that a matrix can be passed as an operator, in which case it will be interpreted as one acting on the on-site degrees of freedom. To act on the lattice, use Operator(l, matrix) — this will create a lattice operator that acts on the lattice l with the given matrix.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"To showcase the flexibility of the construct_hamiltonian function, let's consider a more complex example. We will create a Hamiltonian of the QWZ model of a topological insulator (on a square lattice).","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"The QWZ model Hamiltonian is defined by the following formula:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"hatH =\nsum_i^textsites m_i c^dagger_i sigma_z c_i +\nsum_i^textsites left(\nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i +\nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i +\nh c right)","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"We will take m_i = 1 and add some disorder to the on-site term. Also we will add electric field in the x direction, local on-site potential on site at (2 2) and a new hopping term between the next-nearest neighbors.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"To do this, we need to create the Hamiltonian like this:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\nspin = SpinBasis(1//2)\nsys = System(l, spin, μ = 0, T = 1)\n\nsx, sy, sz = sigmax(spin), sigmay(spin), sigmaz(spin)\nsite = l[!, x = 2, y = 2]\nx = LatticeValue(l, :x)\nE = 0.1                                     # Electric field strength\n\nH = construct_hamiltonian(sys,\n    sz => 1 .+ 0.1 .* randn(l),             # Random on-site potential\n    (sz - im * sx) / 2 => Bravais[1, 0],    # x-direction hoppings\n    (sz - im * sy) / 2 => Bravais[0, 1],    # y-direction hoppings\n    0.5 => site,                            # Local potential on site (2, 2)\n    E * x,                                  # Electric field in the x direction\n    0.1 => NearestNeighbor(2))              # Next-nearest neighbor hopping\n\nP = densitymatrix(H, info=false)\nheatmap(localdensity(P))","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Note that the qwz function can be used to create the QWZ Hamiltonian in a more convenient way. The construct_hamiltonian function is more flexible and can be used to create any Hamiltonian you want.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"note: Note\nThe construct_hamiltonian function creates a Hamiltonian object, which is a QuantumOptics.Operator object, but with some additional info like particle statistics or chemical potential. You can use it as a regular  operator, but if you encounter any problems, you can always convert it to a regular operator using the Operator function or by calling construct_operator instead of construct_hamiltonian.","category":"page"},{"location":"manual/hamiltonian/#The-operator-builder","page":"Constructing the Hamiltonian","title":"The operator builder","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"The construct_hamiltonian function is a convenient way to create Hamiltonians, but it is sometimes more convenient to set all the individual c_i^dagger c_j terms manually. This can be done using the OperatorBuilder object.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Here is an example of how to create the same Hamiltonian as in the previous example using the OperatorBuilder:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\nspin = SpinBasis(1//2)\nsys = System(l, spin, μ = 0, T = 1)\n\nsx, sy, sz = sigmax(spin), sigmay(spin), sigmaz(spin)\nbuilder = OperatorBuilder(sys, auto_hermitian = true)\nfor site in l\n    site_x = site + Bravais[1, 0]\n    site_y = site + Bravais[0, 1]\n    builder[site, site] = (1 + 0.1 * randn()) * sz\n    builder[site, site_x] = (sz - im * sx) / 2\n    builder[site, site_y] = (sz - im * sy) / 2\n\n    builder[site, site] += 0.5 * E * site.x\n    for site2 in adjacentsites(NearestNeighbor(l, 2), site)\n        # note that the coefficient is 0.05, not 0.1, because every bond is counted twice\n        builder[site, site2] += 0.05    \n    end\nend\n\nc_site = l[!, x = 2, y = 2]\nbuilder[c_site, c_site] += 0.5  # Added local potential on site (2, 2)\n\nH2 = Hamiltonian(builder)\nP = densitymatrix(H, info=false)\nheatmap(localdensity(P))","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Note that builder[site1, site2] is not a regular indexing operation. The return value of it is not an matrix or operator, but rather a special object that makes increment/decrement operations possible. Do not use this value in other contexts.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"tip: Tip\nUse FastOperatorBuilder instead of OperatorBuilder if you need to create a large Hamiltonian. It is a little  bit faster, but doesn't support direct assignment builder[site, site] = ...; use += or -= instead.","category":"page"},{"location":"manual/hamiltonian/#Gauge-fields","page":"Constructing the Hamiltonian","title":"Gauge fields","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"There is a convenient way to add gauge fields to the Hamiltonian, and it is done by using the GaugeField objects. It is an interface for different types of gauge fields, like the Landau gauge. To add field to the Hamiltonian, use the field keyword argument:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\nH = tightbinding_hamiltonian(l, field=LandauGauge(0.1))\nP = densitymatrix(H, info=false)\nheatmap(localdensity(P))","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"This adds a magnetic field in the Landau gauge to the Hamiltonian: overrightarrowmathcalA = B x overrightarrowe_y. It adds a phase factor to the hopping terms, which is calculated using Peierls substitution.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Here are all types of gauge fields supported by this package:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"LandauGauge(B) — the Landau gauge, with the magnetic field B in the z direction.\nSymmetricGauge(B) — the symmetric gauge, with the magnetic field B in the z direction.\nPointFlux(Phi, center=(0, 0); gauge=:axial) — a point flux in the point center with the flux Phi. The gauge argument can be either :axial (default) or :singular.\nGaugeField(f; n) — a general magnetic field. The f is a function that takes a coordinate vector and returns the vector potential mathcalA at this point. The line integrals are calculated using the n-point trapezoidal rule. Note that the n must be set explicitly.\nLineIntegralGaugeField(f) — a general magnetic field. The f is a function that takes two coordinate vectors and returns the int_vecr_1^vecr_2 mathcalA cdot dvecr line integral of the vector potential between these points.","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"Different types of fields can be added together:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"julia> using LatticeModels\n\njulia> f1 = LandauGauge(0.1)\nLandau gauge uniform field; B = 0.1 flux quanta per 1×1 area\n\njulia> f2 = SymmetricGauge(0.2)\nSymmetric gauge uniform field; B = 0.2 flux quanta per 1×1 area\n\njulia> f3 = PointFlux(0.3, (0.5, 0.5))\nPoint flux field through point (0.5, 0.5), axial gauge; Φ = 0.3 flux quanta\n\njulia> f1 + f2 + f3\nLandauGauge(0.1) + SymmetricGauge(0.2) + PointFlux(0.3, (0.5, 0.5); gauge=:axial)","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"You can pass these objects using the field keyword argument to the tightbinding_hamiltonian, construct_hamiltonian, and OperatorBuilder functions to add the gauge field to the Hamiltonian:","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"builder = OperatorBuilder(l, auto_hermitian = true, field = LandauGauge(0.1) + PointFlux(0.3, (0.5, 0.5)))\nfor site in l\n    site_x = site + Bravais[1, 0]\n    site_y = site + Bravais[0, 1]\n    builder[site, site_x] = 1\n    builder[site, site_y] = 1\nend\nH2 = Hamiltonian(builder)\nH2 == tightbinding_hamiltonian(l, field=LandauGauge(0.1) + PointFlux(0.3, (0.5, 0.5)))","category":"page"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"To find out more about operators, diagonalization and observables, proceed to the next section.","category":"page"},{"location":"manual/latticevalue/#Working-with-LatticeValues","page":"Working with 'LatticeValue's","title":"Working with LatticeValues","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"This chapter introduces the LatticeValue type, which describes a value defined on the sites of a lattice. LatticeValue implements the AbstractArray interface and is used to represent quantities such as the magnetization or local density of a state.","category":"page"},{"location":"manual/latticevalue/#Basics","page":"Working with 'LatticeValue's","title":"Basics","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"The LatticeValue type is actually a wrapper around a Vector of values, where each value is associated with a site of the lattice. Working with LatticeValue is very similar to working with a Vector, but with some additional functionality.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"using LatticeModels, Plots\n\nl = SquareLattice(-2:2, -2:2)\nx = coordvalue(l, :x)       # get the x coordinate of the lattice sites\nv = zeros(Int, l)           # create a lattice value with zeros\nv[x = 1 .. 2, y = 1 .. 2] = x   # set the value to the x coordinate on the top right\nv[x = -2 .. 0] .= 3           # set the value to 3 on the left half of the lattice\nr = randn(l)                # create a random lattice value (normal distribution)\nv2 = v .^ 2 .+ r            # broadcast operations work as expected\nheatmap(v2)","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"The LatticeValue type implements basic vector creation operations: zero, zeros, one, ones, rand, randn, fill, copy. Slices and views are also supported.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"There are also other AbstractVector methods you can use:","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"sum(abs2, v2)\nextrema(v2)\nargmax(v2)\nms = findall(x -> x < 3, v2)\nv2[first(ms)]","category":"page"},{"location":"manual/latticevalue/#Indexing-and-slicing","page":"Working with 'LatticeValue's","title":"Indexing and slicing","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Let's talk a bit more about the indexing and slicing of LatticeValue. There are several ways to index a LatticeValue. The return value in this case is either a scalar or another LatticeValue with a narrowed domain. The following indexing methods are supported:","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"v[site] returns the value at site site.\nv[[site1, site2, ...]] returns a LatticeValue with the values at the specified sites. site1, site2, etc. are single sites grouped into an abstract array. The return value is a LatticeValue with the same values but narrowed to the specified sites.\nv[lat] returns a LatticeValue with the same values but narrowed to the sites of lattice lat. lat here must be a lattice, which is a subset of the lattice of v.\nv[mask] returns a LatticeValue with the same values but narrowed to the sites where mask is true. mask here must be a LatticeValue of Bool type, defined on the same (or a superset of the) lattice.\nv[x = 1 .. 2, y = 1 .. 2] returns a LatticeValue with the same values but narrowed to the sites where the x coordinate is in the range 1 .. 2 and the y coordinate is in the range 1 .. 2. The keyword arguments here must be the names of the site parameters (see Sites), and the values can be any containers or single values. Pair notation is also supported: v[Coord(1) => 1 .. 2, Coord(2) => 1 .. 2].","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"This indexing is valid for both reading and writing. Remember, however, that the right-hand side of the assignment must be a LatticeValue or a scalar value (in which case the destination site must be a single site, otherwise an error will be thrown). ","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Therefore, l[x=1, y=1] = 1 is not a valid assignment, because the left-hand side can contain multiple sites[1] (for example, if it is a 3D lattice). But l[!, x=1, y=1] = 1 is a valid assignment — adding ! to the index means that the left-hand side is a single site.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"[1]: This is somewhat similar to the behavior of arrays in Julia: v[1:1] = 1 will throw an error, even though the left-hand side is a single-element array.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"note: Note\nThe same indexing methods can be used to slice a lattice, a GreenFunction, a Currents object or a TimeSequence.","category":"page"},{"location":"manual/latticevalue/#Iteration-and-broadcasting","page":"Working with 'LatticeValue's","title":"Iteration and broadcasting","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"You can consider a LatticeValue as a vector of values, with its indices being the sites of the lattice. Therefore,  iterating over v will yield the values of the LaticeValue, and eachindex(v) will return the lattice it is defined on.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Broadcasting operations work as expected. For example, v .+ 1 will add 1 to each value of v, and v .+ r will add the corresponding values of v and r. However, there are some limitations: you cannot broadcast a LatticeValue with anything other than a scalar or another LatticeValue. Also the lattices must be the same, otherwise an error will be thrown.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"using LatticeModels\nl = SquareLattice(4, 4);\nx, y = coordvalues(l)\nv = zeros(l)\nv[x .< y] = x               # This will work\nv[y = 1] .= 1               # This will work\nv[x .> y] .= y              # This will not work - RHS on a different lattice\nv[x = 1] .= [1, 2, 3, 4]    # This will not work - RHS is a vector","category":"page"},{"location":"manual/latticevalue/#Common-operations","page":"Working with 'LatticeValue's","title":"Common operations","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"There are several common use-cases for the LatticeValue type. We will discuss some of them here.","category":"page"},{"location":"manual/latticevalue/#External-parameter-of-a-system","page":"Working with 'LatticeValue's","title":"External parameter of a system","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"In many cases, you need to define a parameter that depends on the site that is used in the Hamiltonian. For example, the on-site potential in the tight-binding model. You can use LatticeValue for this purpose.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"using LatticeModels\nl = SquareLattice(4, 4)\nv = zeros(l)\nv[y = 0 .. 2] .= 1.0                          # add a potential barrier\nH = tightbinding_hamiltonian(l, v, t1=-1.0) # create a tight-binding Hamiltonian","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Here v is a LatticeValue that represents the on-site potential. In other models you can use it to represent the magnetic field, for example: see qwz.","category":"page"},{"location":"manual/latticevalue/#Wavefunctions","page":"Working with 'LatticeValue's","title":"Wavefunctions","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"In some cases you need a custom-defined wavefunction. You can use LatticeValue for this purpose.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"using LatticeModels\nl = SquareLattice(10, 10)\nx, y = coordvalues(l)\nspin = SpinBasis(1//2)                  # create a spin basis\ngauss = @. exp(-0.05 * ((x - 5.5) ^ 2 + (y - 5.5) ^ 2))\nwave = @. exp(im * (x + y))             # create a plane wave\nψ = basisstate(spin, 1) ⊗ (@. gauss .* wave) + \n    basisstate(spin, 2) ⊗ (@. gauss * conj(wave))","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Here ψ is a QuantumOptics.Ket wavefunction. In this example it is a superposition of two states with opposite spins and different momenta.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"We will discuss this theme in more detail in the [States and Operators] section.","category":"page"},{"location":"manual/latticevalue/#Processing-data","page":"Working with 'LatticeValue's","title":"Processing data","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Many observables like local density are returned as a LatticeValue. You can process it quite easily.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"using LatticeModels, Statistics\nl = HoneycombLattice(Hexagon(), sites=120)\nH = tightbinding_hamiltonian(l, t1=-1.0)    # create a tight-binding Hamiltonian\ndens = localdensity(groundstate(H))         # calculate the local density of the ground state\nr = shaperadius(l, Hexagon())               # get the radius of the lattice\nbulk = HoneycombLattice(Hexagon(r * 0.8))\nedge = setdiff(l, bulk)\nprintln(\"Average bulk density: \", round(mean(dens[bulk]), digits=6))\nprintln(\"Average edge density: \", round(mean(dens[edge]), digits=6))","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"The average local density in the bulk is much higher than on the edge, as expected.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"We will discuss this theme in more detail in the [Measurements] section.","category":"page"},{"location":"manual/latticevalue/#Visualization","page":"Working with 'LatticeValue's","title":"Visualization","text":"","category":"section"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"One key feature of LatticeValue is that it can be visualized using the Plots.jl package. There are several ways to do it.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"The \"classical\" way is just to use the plot function. The result will be a scatter plot of the lattice sites with the value of the LatticeValue as the color and size of the markers.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Let us continue with the previous example:","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"using Plots\nplot(dens)","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"This is the default behavior. You can customize the plot as usual with Plots.jl — for example, you can change the colormap, the marker size, etc. You can also set markerscale=false to disable the scaling of the marker size by the value of the LatticeValue:","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"# Dark theme makes everything look cooler\nplot(dens, markerscale=false, markersize=12, c=:inferno, \n    title=\"Local density of the ground state\", bg=:black)","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Another way to visualize a LatticeValue is to use the shape plot seriestype=:shape, or heatmap function. This will create a tile plot of the lattice sites with the value of the LatticeValue as the color of the tiles.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"heatmap(dens, title=\"Local density of the ground state\")","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"You can also use pass shape=:circle to create a scatter plot with large circles instead of the default markers. The difference here is that the size of the circles will scale with the plot, unlike the markers in the scatter plot. markerscale is also supported here, but by default it is set to false.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Let's showcase all of these options:","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"p = plot(size=(1000, 850), layout=(2, 2))\nheatmap!(p[1], dens, title=\"Hexagons, no scale\")\nheatmap!(p[2], dens, markerscale=true, title=\"Hexagons, scale\")\nheatmap!(p[3], dens, shape=:circle, title=\"Circles, no scale\")\nheatmap!(p[4], dens, shape=:circle, markerscale=true, title=\"Circles, scale\")","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"tip: Tip\nThe shape plot is slower than the scatter plot, because it creates a separate shape for each site. If you are creating an animation or a large plot, you may want to use the scatter plot with custom-shaped markers instead.","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"Another important use case is dimension reduction. Before we already discussed how to plot a 2D slice of a 3D lattice. Here is an example of plotting a 1D slice of a 2D LatticeValue:","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"p = plot(size=(1000, 500), layout=(1, 2))\nplot!(p[1], dens, st=:shape)\nplot!(p[1], lattice(dens[j2 = 0]), :high_contrast)\nplot!(p[2], dens[j2 = 0], axes=:x)","category":"page"},{"location":"manual/latticevalue/","page":"Working with 'LatticeValue's","title":"Working with 'LatticeValue's","text":"By projecting axes=:x the selected values on j2 = 0 (e.g. the horizontal line in the middle of the plot) are shown as a 1D plot. Also we have shown the exact line where we took the slice from by plotting the markers with the :high_contrast setting.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Lowest-states-in-a-tight-binding-model","page":"Examples","title":"Lowest states in a tight-binding model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The tight-binding model Hamiltonian is defined by this formula (the sum is performed over adjacent sites):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hatH = sum_i j^textsites left( c^dagger_i c_j + h c right)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we take a square lattice and build a Hamiltonian for it. Then we find its eigenstates and plot their local density on heatmaps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\n# Generate a 40x40 square lattice\nl = SquareLattice(40, 40)\n# Define the tight-binding model Hamiltonian\nH = tightbinding_hamiltonian(l)\n\n# Calculate eigenvalues and eigenvectors\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], localdensity(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", st=:shape, \n        clims=clims, c=:inferno, cbar=:none, lw=0, framestyle=:none, xlab=\"\", ylab=\"\")\nend\n\n# The following lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, subplot=n^2+2, \n    background_subplot=:transparent, framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9))\nsavefig(\"local_density.png\")\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Related sections: Lattices, Systems and Hamiltonians, Diagonalizing.","category":"page"},{"location":"examples/#Currents-on-a-ring-shaped-sample","page":"Examples","title":"Currents on a ring-shaped sample","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we create a ring-shaped sample of a triangular lattice. Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\n\nl = TriangularLattice(Circle(10), !Circle(5))\nremovedangling!(l)\nh(B) = tightbinding_hamiltonian(l, field=PointFlux(B))\ndiag = diagonalize(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = densitymatrix(diag, mu = 0)\n# Perform unitary evolution\nτ = 10\nev = Evolution(t -> h(0.1 * min(t, τ) / τ), P_0)\nanim = @animate for state in ev(0:0.1:2τ)\n    P, H, t = state\n    # Find the density and plot it\n    p = plot(layout=2, size=(1000, 500))\n    plot!(p[1], localdensity(P), clims=(0, 1), st=:shape)\n\n    # Show currents on the plot\n    plot!(p[2], DensityCurrents(H, P), clims=(0, 0.005), lw=1, arrowheadsize=0.3)\n    plot!(plottitle=\"t = $t\")\nend\n\ngif(anim, \"adiabatic_flux.gif\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Related sections: Currents, Evolution.","category":"page"},{"location":"examples/#Time-sequences","page":"Examples","title":"Time sequences","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will see how to use TimeSequence to store and manipulate time-dependent data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will calculate the evolution of a ground state of a tight-binding model after a magnetic field is turned on. We will store the local density at each time step and use it to plot the local density depending on time, as well as its time derivative and integral over time.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels, Plots\n\nl = SquareLattice(20, 20)\nH = tightbinding_hamiltonian(l)\npsi_0 = groundstate(H)\nH1 = tightbinding_hamiltonian(l, field=LandauGauge(0.1))\nev = Evolution(H1, psi_0)\n\ndensities = TimeSequence{LatticeValue}()\nfor (psi, _, t) in ev(0:0.1:10)\n    densities[t] = localdensity(psi)\nend\n\nsite_bulk = l[!, x = 10, y = 10]\nsite_edge = l[!, x = 10, y = 1]\nds_bulk = densities[site_bulk]\nds_edge = densities[site_edge]\nplot(ds_bulk, label=\"ρ(t) (bulk)\")\nplot!(differentiate(ds_bulk), label=\"dρ(t)/dt (bulk)\")\nplot!(ds_edge, label=\"ρ(t) (edge)\")\nplot!(integrate(ds_edge), label=\"∫ρ(t)dt (edge)\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Related sections: Gauge fields, Evolution, TimeSequence.","category":"page"},{"location":"examples/#Hofstadter-butterfly","page":"Examples","title":"Hofstadter butterfly","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Hofstadter butterfly is a fractal-like structure that appears when the tight-binding model is subjected to a magnetic field. It is a plot of the energy spectrum as a function of the magnetic flux through the unit cell.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To create the Hofstadter butterfly, we will use the Landau gauge for the magnetic field. Note that we have to set periodic boundary conditions, and to make them compatible with the gauge field, they should be tweaked a little:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"psi(x + L_x y) = psi(x y) e^2pi i B y L_x\npsi(x y + L_y) = psi(x y)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let us plot the Hofstadter butterfiles for square, triangular and honeycomb lattices. The magnetic field field will be changed from zero to one phi_0 flux quantum per plaquette.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels, Plots\n\nfunction get_butterfly(l, lx, ly, plaquette_area)\n    xs = Float64[]\n    ys = Float64[]\n    area = lx * ly\n    dflux = 1 / area\n    totflux = 1 / plaquette_area\n    for B in 0:dflux:totflux\n        # magnetic boundary conditions\n        f(site) = exp(2pi * im * B * site.y * lx)\n        lb = setboundaries(l, [lx, 0] => f, [0, ly] => true)\n        H = tightbinding_hamiltonian(lb, field=LandauGauge(B))\n        dg = diagonalize(H)\n        append!(xs, fill(B, length(dg.values)))\n        append!(ys, dg.values)\n    end\n    return xs, ys\nend\n\np = plot(layout = @layout[a b; _ c{0.5w} _], size=(800, 500), leg=false,\n    xlabel=\"B\", ylabel=\"E\")\nscatter!(p[1], title=\"Square lattice\",\n    get_butterfly(SquareLattice(10, 10), 10, 10, 1), ms=1)\nscatter!(p[2], title=\"Triangluar lattice\",\n    get_butterfly(TriangularLattice(10, 10), 10, 5 * sqrt(3), sqrt(3) / 4), ms=1)\nscatter!(p[3], title=\"Honeycomb lattice\",\n    get_butterfly(HoneycombLattice(10, 10), 10, 5 * sqrt(3), sqrt(3) / 2), ms=1)\nsavefig(\"hofstadter_butterfly.png\")\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Related sections: Lattices, Boundary conditions, Gauge fields.","category":"page"},{"location":"examples/#LDOS-animation","page":"Examples","title":"LDOS animation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Local density can be a bit ambiguous for degenerate eigenstates. That's where the LDOS (e. g. the Local Density of States) will be helpful.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The formula for the LDOS is the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"textLDOS_alpha(E) = frac1pi textIm G_alphaalpha(E - idelta)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where G is the Green's function and delta is the broadening.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's create an animation presenting the DOS and LDOS for a square lattice with a hole indside. We will use the QWZ model hamiltonian, because it has a two-zone band structure, which will make the results more interesting. See qwz for more information about the QWZ model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\nl = SquareLattice(20, 20)\nl_center = l[j1 = 8 .. 13, j2 = 8 .. 13]\nsetdiff!(l, l_center)   # remove the center\nH = qwz(l)\n\ndg = diagonalize(H)\nδ = 0.1\nEs = -4:0.1:4\nEs_d = -4:0.01:4\nG = greenfunction(dg)\nanim = @animate for E in Es\n    print(\"\\rE = $E\") # hide\n    p = plot(layout=2, size=(800, 400))\n    plot!(p[1], Es_d, dos(G, broaden=δ), lab=\"\", title=\"DOS\")\n    vline!(p[1], [E], lab=\"\")\n    plot!(p[2], ldos(G, E, broaden=δ), st=:shape, \n        c=:inferno, clims=(0, NaN), title=\"LDOS\", lw=0)\n    plot!(p, plot_title=\"E = $E, δ = $δ\")\nend\n\ngif(anim, \"ldos_animation.gif\", fps=10)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Related sections: Green's function, Density of states.","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paste the following line into the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/aryavorskiy/LatticeModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/aryavorskiy/LatticeModels.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Compat\nThis package has tested compatibility with Julia v1.6. Use with caution on lower versions.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry or boundary conditions.\nPowerful operator generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nManybody computations.\nSmart unitary evolution reducing excessive computations where possible.\nSupports visualization with Plots.jl.\nCompatible with QuantumOptics.jl.","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This simple code plots local density for lowest energy states of a square tight-binding lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels, Plots\n\nl = SquareLattice(40, 40)\nH = tightbinding_hamiltonian(l)\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    # Plot local density on each subplot\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], localdensity(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", st=:shape, \n        clims=clims, c=:inferno, cbar=:none, lw=0, framestyle=:none, xlab=\"\", ylab=\"\")\nend\n\n# The following lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, subplot=n^2+2, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), background_subplot=:transparent)\nsavefig(\"example.png\")\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"See more examples in the Examples section.","category":"page"},{"location":"#Similar-packages","page":"Home","title":"Similar packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Packages such as Quantica.jl, pybinding and Kwant provide similar functionality. And while they are all great packages, pybinding and Quantica are mostly focused on static properties of lattices. Kwant is more versatile, but its main focus is on quantum transport problems — it provides dynamic simulations in the Tkwant package, but LatticeModels.jl allows usage of various powerful backends, which improves performance and flexibility.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here are some benchmarks: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: All benchmarks composed)","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can see dramatic performance improvements on small lattice sizes, while being competitive on larger ones. These benchmarks were run on a 4-core Intel Core i7-10510U, 16 GB RAM machine. You can find the benchmarking code in the benchmarks folder of the package repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are other nice features that LatticeModels.jl provides:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Convenient tools for setting periodic boundary conditions and gauge fields. The only way to do this in    Kwant or Pybinding is to manually set the hopping values.\nA flexible interface for defining new types of lattices and bonds. Random lattices can be implemented   on top of GenericLattice with ease.\nFull-fledged quantum mechanics. Any quantum operator can be defined and used in the simulations without much struggle.\nManybody computations. LatticeModels.jl can handle manybody systems with particle interaction.","category":"page"},{"location":"manual/operators/#States-and-Operators","page":"States and Operators","title":"States and Operators","text":"","category":"section"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"In the previous chapter we have seen how to define a Hamiltonian for a lattice model. In this chapter we will see how to work with other types of operators, such as measurements and diagonalizing.","category":"page"},{"location":"manual/operators/#Builtins","page":"States and Operators","title":"Builtins","text":"","category":"section"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"There are some basic building blocks that can be used to create states and operators. These functions are taken from QuantumOptics.jl package, but extended to work with lattices:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"basisstate creates a state vector in the basis of a lattice.\ndiagonaloperator creates a diagonal operator in the basis of a lattice.\ntransition creates a transition operator between two states in the basis of a lattice.\nnumber, destroy, and create are the number, annihilation, and creation operators in the basis of a lattice.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"Remember the general rule of thumb for working with lattices: You can provide a lattice (and optionally the internal basis) instead of a QuantumOptics.Basis, and a site (or a (site, internal_index) tuple) instead of an integer index.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"For example, the basisstate function creates a state vector in the basis of a lattice. Normally it takes a QuantumOptics.Basis and an index as arguments, and returns a Ket object. However, you can use a lattice and a site as arguments to create a state vector in the basis of the lattice:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"using LatticeModels\nl = SquareLattice(6, 6);\nsite = l[!, x = 3, y = 3]\nl_bas, ind = LatticeBasis(l), site_index(l, site);\npsi1 = basisstate(l_bas, ind);  # The pure QuantumOptics.jl way\npsi2 = basisstate(l, site);     # The LatticeModels.jl way\npsi1 == psi2","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"If you work in a composite system (e. g. a lattice with a spin degree of freedom), you can either use composite indexing or construct the state as tensor product of the states for each subsystem:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"spin = SpinBasis(1//2)\npsi1_composite = basisstate(l, spin, (site, 1));\npsi2_composite = basisstate(spin, 1) ⊗ basisstate(l, site); # Note the order!\npsi1_composite == psi2_composite","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"note: Note\nThe order of the tensor product is important. The first argument is the on-site degrees of freedom, and the second is the lattice. This convention is consistent in the rest of the package — the reason behind this is performance of construct_operator and OperatorBuilder.If this order is not followed, you will probably get an error somewhere in your calculations.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"The diagonaloperator function creates a diagonal operator in the basis of a lattice. Normally it takes a QuantumOptics.Basis and a vector of values (or a single value) as arguments, and returns an Operator object. There are several convenient ways to use this function with lattices. As an example let's consider the position operator in the basis of a lattice:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"xval = coordvalue(l, :x)\nX_1 = diagonaloperator(l_bas, xval.values); # The pure QuantumOptics.jl way\nX_2 = diagonaloperator(l, :x);      # The LatticeModels.jl way, with a site property\nX_3 = diagonaloperator(xval);       # The LatticeModels.jl way, with a LatticeValue\nX_1 == X_2 == X_3","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"This notation allows converting any LatticeValue or Site parameter to an operator. Hence, diagonaloperator(l, Coord(1)) is also valid and will return the same operator.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"tip: Tip\nGenerally, a good value to create a custom diagonal operator is by using the LatticeValue approach. Consider this example: in the Haldane model the diagonal part is m on the A sublattice and -m on the B sublattice. You can create this operator with the following code:l = HoneycombLattice(6, 6)\nm = 3\nms = LatticeValue(l) do site\n    site.index == 1 ? m : -m\nend\nOp = diagonaloperator(ms)","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"Also note the coordoperator and coordoperators functions that do the same thing as coordvalue and coordvalues, but return the operator instead of the value:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"X, Y = coordoperators(l);\nX == X_1","category":"page"},{"location":"manual/operators/#Measurements","page":"States and Operators","title":"Measurements","text":"","category":"section"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"The most common type of measurements is the local density: the average number of particles at each site. This can be calculated using the localdensity function — it takes a state (a QuantumOptics.Ket vector or a QuantumOptics.Operator representing the density matrix) and returns a LatticeValue with the density at each site.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"using LatticeModels, Plots\nl = GrapheneRibbon(6, 4)\nH = tightbinding_hamiltonian(l)\nd = localdensity(groundstate(H))\nplot(d)","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"The localdensity function uses the following formula to calculate the density at each site: rho_i = textTr(hatn_i hatrho), where hatn_i is the number operator at site i and hatrho is the density matrix. Note that if the values are complex, the function will return the real part of them. This is what makes the next example work.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"The local Chern marker is a quantity that can be used to detect topological phases in a lattice model. It can be calculated using the following formula:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"mathcalC(r) = 4pi textIm langle r  P X P Y P  r rangle","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"Here P is the projector onto the occupied states (e. g. the density matrix), and X and Y are the position operators. The local Chern marker is a real number that can be calculated for each site in the lattice.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"Let's do this for a QWZ model Hamiltonian on a square lattice:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"using LatticeModels, Plots\nl = SquareLattice(6, 6)\nsys = l ⊗ SpinBasis(1//2)\nms = ones(l)\nms[x = 3 .. 4, y = 3 .. 4] .= -1\nH = qwz(l, ms)\n\nP = densitymatrix(H, mu=0, statistics=FermiDirac)\nX, Y = coordoperators(sys)\nc = localdensity(-4π * im * P * X * P * Y * P)\nheatmap(c, title=\"Local Chern marker\")","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"A generalization of the density measurement is the localexpect function. It takes a local operator hatA and a state, and calculates the expectation value of the operator at each site: A_i = textTr((hatA otimes hatn_i) cdot hatrho), where hatn_i is the number operator at site i and hatrho is the density matrix. Note that the result is a complex numbered LatticeValue.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"As an example, let us visualize a spin wavefunction on a square lattice:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"using LatticeModels, Plots\nl = SquareLattice(10, 10)\nx, y = coordvalues(l)\nspin = SpinBasis(1//2)\ngauss = @. exp(-0.05 * ((x - 5.5) ^ 2 + (y - 5.5) ^ 2))\nwave = @. exp(im * (x + y))\nψ = basisstate(spin, 1) ⊗ (@. gauss .* wave) + basisstate(spin, 2) ⊗ (@. gauss * conj(wave))\nnormalize!(ψ)\nσx = sigmax(spin)\n\np = plot(layout=2, size=(800, 400))\nplot!(p[1], localdensity(ψ), title=\"Local density\")\nplot!(p[2], localexpect(σx, ψ) .|> real, title=\"σx projection\")","category":"page"},{"location":"manual/operators/#Diagonalizing","page":"States and Operators","title":"Diagonalizing","text":"","category":"section"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"To diagonalize a Hamiltonian or any other operator, you can use the diagonalize function. It takes an operator and returns a EigenSystem object with the eigenvalues and eigenvectors of the operator.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"using LatticeModels, Plots\nl = GrapheneRibbon(6, 4)\nH = haldane(l, 0.1, 1)\neig = diagonalize(H)","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"This struct simplifies the access to the eigenvalues and eigenvectors of the operator. You can access the eigenvalues with eig.values, and eigenvectors as Kets can be obtained with the bracket notation eig[i] or eig[value = E]:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"# The states are sorted by real part of the eigenvalues, so\npsi = eig[1]                        # `psi` is the ground state\npsi2 = eig[value = 0]               # `psi2` is the state with zero energy\np = plot(layout = @layout[a b; c], size=(800, 800))\nplot!(p[1], localdensity(psi), title=\"Ground state\")\nplot!(p[2], localdensity(psi2), title=\"Zero energy state\")\nscatter!(p[3], eig.values, title=\"Spectrum\", lab=\"\")","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"tip: Tip\nYou can find the ground state of a Hamiltonian in one line using the groundstate function:psi = groundstate(H)To evaluate both the ground state and its energy, use the findgroundstate function:E0, psi = findgroundstate(H)","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"The diagonalize function under its hood uses the eigen function from the LinearAlgebra standard library.  However, this does not work for non-trivial matrix types (e. g. sparse matrices or GPU arrays). For such cases you  can pass the second argument to the diagonalize function, which is a Symbol indicating the method to use for  diagonalization. To use the eigsolve function from the KrylovKit.jl  package, you can pass :krylovkit as the second argument. Since this solves the eigenvalue problem iteratively, you  can also pass the keyword arguments: n for the number of eigenvalues to compute, v0 for the initial guess, and  the keyword arguments for the eigsolve function.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"l = SquareLattice(100, 100)             # A really big lattice\nH = tightbinding_hamiltonian(l)\neig = diagonalize(H, :krylovkit, n=9)   # Compute only 9 eigenvalues with smallest real part\np = plot(layout=9, leg=false, size=(1000, 900))\nfor i in 1:9\n    plot!(p[i], localdensity(eig[i]), title=\"E = $(round(eig.values[i], digits=5))\",\n        ms=2, msw=0, msa=0)             # Plot with small markers with no outline\nend\nplot!()\nsavefig(\"gs_density.png\")   # hide\nnothing                     # hide","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"(Image: )","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"EigenSystem objects have a wide range of applications in this package. One of them is creating equilibrium states for a given Hamiltonian. This can be done using the densitymatrix function, which is described in the next section.","category":"page"},{"location":"manual/operators/#Density-matrix","page":"States and Operators","title":"Density matrix","text":"","category":"section"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"After you diagonalize a Hamiltonian, you can calculate the density matrix for the system. Use the densitymatrix function to do this:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"using LatticeModels\nl = SquareLattice(6, 6)\nsys = System(l, SpinBasis(1//2), mu=0, statistics=FermiDirac, T=0.1)\nH = tightbinding_hamiltonian(sys)\neig = diagonalize(H)\nP1 = densitymatrix(eig)                 # Use the default parameters from the `System`\nP2 = densitymatrix(eig, \n    statistics=BoseEinstein, T=0, mu=1) # Or you can override them\nnothing # hide","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"Note that the densitymatrix function can also be applied to a Hamiltonian object, in which case it will first diagonalize the Hamiltonian and then calculate the density matrix:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"P1_1 = densitymatrix(H)\n@assert P1 ≈ P1_1\nP2_1 = densitymatrix(H, statistics=BoseEinstein, T=0, mu=1)\n@assert P2 ≈ P2_1\nnothing # hide","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"The densitymatrix function uses a simple formula to calculate the density matrix:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"hatrho = sum_i rho(E_i)  psi_i rangle langle psi_i ","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"Here E_i are the eigenvalues of the operator, psi_i are the corresponding eigenvectors, and rho(E) is the distribution function defined by the statistics, T, and mu parameters. By default, when no additional parameters are passed to the System or densitymatrix, the density matrix will be a thermal state at zero temperature.","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"The basis for these computations is the projector function, which takes a function p and an EigenSystem object d that represents the diagonalized operator hatO. The return value is an operator hatP defined by the formula:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"hatO = sum_i E_i  psi_i rangle langle psi_i  hspace1cm\nhatP = sum_i p(E_i)  psi_i rangle langle psi_i ","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"Here E_i are the eigenvalues of the operator hatO, and  psi_i rangle are the corresponding eigenvectors. The function p is applied to the eigenvalues to obtain the diagonal elements of the density matrix. Here is an example of how to use this function:","category":"page"},{"location":"manual/operators/","page":"States and Operators","title":"States and Operators","text":"l = SquareLattice(6, 6)\nH = tightbinding_hamiltonian(l)\neig = diagonalize(H)\nP1 = projector(x -> x < 0, eig)             # Projector onto the states with energy < 0\nP2 = projector(x -> 1 / (1 + exp(x)), eig)  # Fermi-Dirac distribution\nP3 = projector(eig[1:4])                    # Projector onto the first 4 states\n# Note how we slice the `eig` object to get the first 4 states","category":"page"}]
}

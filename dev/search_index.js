var documenterSearchIndex = {"docs":
[{"location":"manual/bonds/#Adjacency-and-boundary-conditions","page":"Adding bonds","title":"Adjacency and boundary conditions","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This chapter describes how to define bonds between sites in a lattice and how to use them to define boundary conditions.","category":"page"},{"location":"manual/bonds/#General-bonds","page":"Adding bonds","title":"General bonds","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"There are several ways to define bonds between sites in a lattice. The most general way is to define a function that takes two sites and returns if they are connected. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"A direct implementation of this approach is the AdjacencyMatrix. It is a simple wrapper around a boolean-valued matrix.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = SquareLattice(4, 4)\n\n# Define a nearest neighbor adjacency matrix\nadj = AdjacencyMatrix(l, NearestNeighbor())\n\n# Let's disconnect the center sites from the rest vertically\nfor x in 2:3\n    site1 = l[x=x, y=2]\n    site2 = l[x=x, y=1]\n    adj[site1, site2] = false\n\n    site3 = l[x=x, y=3]\n    site4 = l[x=x, y=4]\n    adj[site3, site4] = false\nend\n\nplot(adj)                   # Plot what we've got\nplot!(l, showbonds=false)   # And the lattice itself","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"As you can see, the adjacency matrix is a writable object, so you can change the bonds as you like. In this example we deleted vertical bonds between the four center sites and the boundary of the lattice.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"There are many ways to create an adjacency matrix — for example, you can use a function that takes two sites and returns if they are connected. This is useful when you need to define bonds in a more complex way:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"adj2 = AdjacencyMatrix(l) do site1, site2\n    dx = site1.x - site2.x\n    dy = site1.y - site2.y\n    return abs(dx * dy) == 1    # Diagonal bonds\nend\nplot(adj2)\nplot!(l, showbonds=false)","category":"page"},{"location":"manual/bonds/#Translations","page":"Adding bonds","title":"Translations","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"A \"translation\" is a special type of bonds that has a distinct direction (e. g. each pair of sites consists of a \"source\" and a \"target\" site). Also it must define exactly one destination for each source site (if any).","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"An example is the Translation — it allows defining bonds between sites that are shifted by a certain vector. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = GrapheneRibbon(6, 4)        # A convenient constructor for a honeycomb lattice\ntr = Translation(l, [1, 2√3/3])\nplot(tr)\nplot!(l, ls=:dash, linecolor=:grey)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Another type of translation is the BravaisTranslation. It translates sites on a Bravais lattice in terms of the lattice vectors:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"tr2 = BravaisTranslation(1 => 2, [0, 1])\ntr1 == tr2  # true","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"What does this notation mean? We take the first site in the unit cell; then we go to the unit cell shifted by [0, 1] and take the second site from there. Note that the first example described the same translation, but in terms of positions, not unit cell indices.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"note: Note\nYou can omit the pair of indices if you want to translate the unit cell regardless of the site index.  Bravais[j1, j2, ...] is shorthand for BravaisTranslation([j1, j2, ...]).    ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"You can use translations to shift a site, for example: site2 = site1 + tr, just like with regular vectors. Another  use-case for translations is in defining boundary conditions, as we will see in the next section.","category":"page"},{"location":"manual/bonds/#boundary_conditions","page":"Adding bonds","title":"Boundary conditions","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"The most general form of boundary conditions supported by this package is this:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"psi(r + R) = psi(r) f(r)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"where R is a translation vector and f is some function. This is a generalization of periodic boundary conditions, which are a special case of this form.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"These conditions are in fact applied not to the lattice itself, but to the Hamiltonian. Think of it as a way to replace the c(r)^dagger c(r) hopping with c(r)^dagger c(r - R) f(r), if the r site is not present in the lattice, but r - R is.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"In general, there are three types of boundary conditions:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"PeriodicBoundary — the most common type of boundary conditions. Just periodicity with no factor.\nTwistedBoundary — periodicity with a phase factor that does not depend on r.\nFunctionBoundary —  general form of boundary conditions.","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"The constructor for the boundary accepts two arguments — the phase (or the function) and the translation. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"As an example, let us consider the example with the Hofsadter butterfly from the Examples page. The magnetic field B changes from zero to one flux quantum per plaquette, for each value of B we calculate the energy spectrum of an infinite lattice and plot it. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Let's consider a periodic lattice instead. We want to apply magnetic field in the Landau gauge to it, and since  the translation operators include the vector potential mathcalA, we have to tweak the boundary conditions a little:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"psi(x + L_x y) = psi(x y) e^2pi i B y L_x\npsi(x y + L_y) = psi(x y)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This can be done with the FunctionBoundary:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = HoneycombLattice(10, 10)\nLx = 10\nLy = 5√3\nn_plaquettes = 100\nB_step = 1 / (Lx * Ly)          # Field step: one flux quantum through all plaquettes\nB_max = n_plaquettes * B_step   # Until one flux quantum per plaquette\n\npoints_E = Float64[]\npoints_B = Float64[]\nfor B in 0:B_step:B_max\n    f(site) = exp(2π * im * B * site.y * Lx)\n    xboundary = FunctionBoundary(f, [Lx, 0])\n    yboundary = PeriodicBoundary([0, Ly])\n    lb = setboundaries(l, xboundary, yboundary)\n    H = tightbinding_hamiltonian(lb, field=LandauGauge(B))\n    dg = diagonalize(H)\n    append!(points_E, dg.values)\n    append!(points_B, fill(B, length(dg.values)))\nend\nscatter(points_B, points_E, xlabel=\"B\", ylabel=\"E\", leg=false, ms=1)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Note that we could have set the boundary conditions to the lattice in one line. In fact, we already did this in the Examples section:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"lb = setboundaries(l, [Lx, 0] => f, [0, Ly] => true)","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Let's explain this notation:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Each pair consists of a translation on the left and a \"boundary specifier\" on the right. A simple vector, like here, is interpreted as a Translation — you can use any translation type here, Bravais[-5, 10] instead of [0, Ly] would work as well.\nThe second argument can be one of the following:\ntrue/false — a periodic or open boundary condition.\nA number θ — a twisted boundary condition with a phase factor exp(im * θ).\nA function f — a general boundary condition.\nSometimes the lattice includes default translation axes, and you can use their aliases as translations.  For example, for a 10x10 square lattice setboundaries(l, :axis1 => f, :axis2 => true) is equivalent to setboundaries(l, [10, 0] => f, [0, 10] => true).","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"Note that you can pass boundary conditions to the lattice constructor as well. We could not do this in the previous example, because the boundary conditions depended on the magnetic field B. However, if you have a fixed boundary condition, you can pass it to the lattice constructor like this:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"lb = HoneycombLattice(10, 10, boundaries=([Lx, 0] => f, [0, Ly] => true))","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This is equivalent to the setboundaries call from the previous example. ","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"note: Note\nIn our example we imposed periodic boundary conditions in shape of a rectangle 0  x  L_x, 0  y  L_y. However, the lattice itself is more like a parallelogram, because of its unit cell shape. This is not a problem, because this shape is still periodic in terms of these translations along x and y.If the periodicity is violated, for example, if the both r and r + R sites are present in the lattice, an error will be thrown.","category":"page"},{"location":"manual/bonds/#Generic-lattice","page":"Adding bonds","title":"Generic lattice","text":"","category":"section"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"The GenericLattice is a tool you might want to use if you need to define a lattice with a more complex geometry. It is basically just a collection of arbitrary sites. As an example, let's define a lattice with a naive random geometry:","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"using LatticeModels, Plots\nl = GenericLattice{2}()         # 2D lattice\nfor i in 1:100\n    pt = rand(2) * 5\n    md = minimum(site -> norm(pt - site.coords), l, init=1.0)\n    md > 0.5 && push!(l, pt)    # Add a site if it is far enough from the others\nend\nl2 = setboundaries(l)\nbonds = SiteDistance(<(1), l2)  # Connect sites that are closer than 0.5\nplot(bonds)\nplot!(l2)       # Unlike Bravais lattices, GenericLattice does not have default bonds","category":"page"},{"location":"manual/bonds/","page":"Adding bonds","title":"Adding bonds","text":"This tool is not very mature yet, but it can be useful for tasks not related to Braavais lattices. Note that boundary conditions can be set to the GenericLattice as well.","category":"page"},{"location":"manual/currents/#Currents","page":"Currents","title":"Currents","text":"","category":"section"},{"location":"manual/currents/#Basics","page":"Currents","title":"Basics","text":"","category":"section"},{"location":"manual/currents/#Common-Operations","page":"Currents","title":"Common Operations","text":"","category":"section"},{"location":"manual/currents/#Visualization","page":"Currents","title":"Visualization","text":"","category":"section"},{"location":"manual/lattice/#Lattices","page":"Defining the lattice","title":"Lattices","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This chapter describes the basic functionality of this package — creating and manipulating lattices.","category":"page"},{"location":"manual/lattice/#Basics","page":"Defining the lattice","title":"Basics","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Creating a lattice is simple. If you want to work with Bravais lattices, there are plenty of predefined types in the package. For example, to create a square lattice, you can use the SquareLattice type:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = SquareLattice(10, 10)\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This will create a 10x10 square lattice. Note that you can create a plot by simply using the plot function from the Plots package.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"SquareLattice(10, 10) notation means that we take a square lattice unit cell and translate it 10 times in the x and y directions. This syntax can be extended a little bit:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = HoneycombLattice(-2:2, -2:2)\nplot(l)\nplot!(l[j1 = 0, j2 = 0], c=:red, ms=6)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"What happened here? We created a honeycomb lattice by translating the unit cell from -2 to 2 in both directions. Then we plotted the lattice and highlighted the unit cell at the origin to make it more visible. l[j1 = 0, j2 = 0] allowed us selecting part of the lattice by specifying the indices of the unit cell (j1 and j2 are the indices of the unit cell in the first and second directions, respectively).","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"If we need to create a lattice with a less trivial shape, we can use any function we need:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = TriangularLattice(-10:10, -10:10) do site\n    return 4 < sqrt(site.x^2 + site.y^2) < 8     # Create a ring-shaped lattice\nend\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here the lattice constructor first translated the unit cell from -10 to 10 in both directions, and then applied the function to each site to create a ring-shaped lattice. This is similar to the filter function in Julia — in fact, you can use filter or filter! on an existing lattice to create a new one as well.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"There are other things you can control when creating a lattice, such as the lattice offset & rotation.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l1 = SquareLattice(-2:2, -2:2)\nl2 = SquareLattice(-2:2, -2:2, offset=:centeralign)\nl3 = SquareLattice(-2:2, -2:2, rotate=pi/3, offset=[6, -1.5])\nplot(l1, lab=\"No offset\", shape=:circle)\nplot!(l2, lab=\"Center the unit cell\", shape=:star)\nplot!(l3, lab=\"Shifted and rotated by π/3\", shape=:square)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"To find out more about offset and rotation, see UnitCell — the keywords are described there.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"note: Note\nIf you use both offset/rotation and a function to create a lattice, the function will be applied to the sites after the offset/rotation is applied. Use the postoffset and postrotate keywords to control the position and orientation of the lattice after the function is applied.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"The lattices implement the AbstractSet interface, so you can use all the set operations on them — union, intersect, setdiff etc.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l1 = SquareLattice(-2:0, -2:0)\nl2 = SquareLattice(0:2, 0:2)\nl3 = SquareLattice(-3:3, -3:3)\nl = setdiff(l3, union(l1, l2))\nplot(l)\nplot!(union(l1, l2), showbonds=false, alpha=0.3)","category":"page"},{"location":"manual/lattice/#Sites","page":"Defining the lattice","title":"Sites","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Let's find out what sites actually are. A site is generally a point in the lattice. It is defined by its position in space and maybe some additional properties. In case of a Bravais lattice these additional properties are unit cell indices and the index in the unit cell.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"A lattice is generally a set-like structure that allows indexing. Let's take a closer look in the REPL:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = HoneycombLattice(-2:2, -2:2)\nsite = l[1]     # Get the first site\nsite.x          # Get the x-coordinate of the site\nsite.j2         # Get the second index of the unit cell\nsite.index      # Get the index of the site in the unit cell\nx, y = site     # Destructure the site","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"As we see, we can access the properties of the site simply as fields of the site object. We can also destructure the site to get its coordinates.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"compat: Julia 1.8\nAccessing the properties of the site as fields like site.x requires Julia 1.8 and later. This limitation is imposed with purpose, since this seriously affects runtime performance in earlier versions. You will still be able to destructure the site to get its coordinates, or use the following fields:site.coords — the position of the site\nsite.latcoords — the unit cell indices\nsite.index — the index of the site in the unit cell","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Properties like x, j1, index etc. are part of a general SiteProperty interface. You can use them to create 'slices' of lattices:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"slice = l[j1 = 0..2, j2 = -2..0, index=1]  # Get a slice of the lattice\nplot(l)\nplot!(slice, c=:red, ms=6)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here 0..2 and -2..0 are intervals defining the ranges of the unit cell indices. You can use any collection instead of then if you need.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Finding sites by their properties can be done with the same notation:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l[x = 1.5, y = √3/2]    # Find the site with x = 1.5 and y = √3/2\nl[x = 1.2, y = 3]       # No such site, throws an error","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This is notation is convenient yet type-unstable, since it returns a Site object if there is one site satisfying the condition — otherwise a lattice is returned. To make sure that the result is indeed a site, add ! to the beginning of the condition:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l[!, x = 1.5, y = √3/2]    # Find the site with x = 1.5 and y = √3/2\nl[!, x = 1.5]              # More than one site, throws an error","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here is a short list of site parameters you can use:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"x, y, z — the position of the site. ALternatively, you can use x1, x2, x3, x4 and so on to access the coordinates of the site in the unit cell.\nj1, j2, j3 and so on — the indices of the unit cell.\nindex — the index of the site in the unit cell.","category":"page"},{"location":"manual/lattice/#Custom-UnitCell","page":"Defining the lattice","title":"Custom UnitCell","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"You can also create a lattice from a custom unit cell:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\n# This will be our custom honeycomb lattice unit cell\n# First argument - vectors of the unit cell\n# Second argument - radius-vectors for the sites in the unit cell\nuc = UnitCell([[1/2, sqrt(3)/2] [-1/2, sqrt(3)/2]], [[0, sqrt(3)/6] [0, -sqrt(3)/6]])\nplot(uc)    # Plot the unit cell","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Note that both arguments are actually matrices — the first one is a matrix of the unit cell vectors, and the second one is a matrix of the site positions in the unit cell. However, here we used concatenation to create the matrices for the sake of readability: remember that [[a, b] [c, d]] is equivalent to [a c; b d].","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"To create a lattice, we can use the span_unitcells function:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = span_unitcells(uc, -5:5, -5:5) do site\n    x, y = site\n    return abs(y) < 5 && \n        abs(y * 1 / 2 + x * sqrt(3) / 2) < 5 && \n        abs(y * 1 / 2 - x * sqrt(3) / 2) < 5\nend   # Create a hex shape\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"In fact, the constructors we discussed earlier are just a shorthand for span_unitcells with a predefined unit cell. You can use span_unitcells to create a lattice from any unit cell you want.","category":"page"},{"location":"manual/lattice/#Shapes","page":"Defining the lattice","title":"Shapes","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"The shapes framework is a powerful tool for creating lattices of arbitrary geometry:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = SquareLattice{2}(Hexagon(10, [-10, 0]), Circle(10, [10, 0]))\nplot(l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Here we created a square lattice in shape of a hexagon and a circle. The first argument of the shape is its radius (for the hexagon it is the distance from its center to the vortices), and the second argument is the center of the shape. Other possible shapes include Rectangle, Polygon, SiteAt and Path.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"complex_l = SquareLattice{2}(   # Here you have to specify the dimension of the lattice\n    Circle(10), Circle(10, [20, 0]), Circle(10, [10, 10√3]),\n    !Circle(5), !Circle(5, [20, 0]), !Circle(5, [10, 10√3]),\n    Rectangle(-5..5, -14..(-12)), Rectangle(15..25, -14..(-12)),\n    Path([-12, 32], [32, 32]), SiteAt([0, 0]), SiteAt([20, 0])\n)\nplot(complex_l)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Note that adding ! before the shape inverts it. This is useful when you need to create a lattice with a hole in it.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Sometimes the shape can become ill-formed — this happens when the unit cell has non-trivial geometry. In this case you may need to remove the dangling sites using the removedangling! function. For example, they can arise when creating a path on a honeycomb lattice:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = HoneycombLattice(Circle(3, [0, 0]), Circle(3, [-2, 10]), Path([0, 0], [-2, 10]))\np = plot(size=(800, 350), layout=(1, 2))\nplot!(p[1], l, title=\"With dangling sites\")\nremovedangling!(l)\nplot!(p[2], l, title=\"Without dangling sites\")","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Let's discuss what is happening under the hood. The HoneycombLattice constructor calls the fillshapes function, which estimates the unitcells one has to span for each shape, and adds the sites that are in the shape to the lattice. ","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"You can also use addshapes! to add shapes to an existing lattice and deleteshapes! to remove them. These functions, however, do not support the ! notation for inverting shapes.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"One last, but not least, thing to mention is that this framework allows approximate scaling. If you need a lattice with distinct shape and, say, roughly 1000 sites, you can use the sites keyword to specify the number of sites you need:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"l = TriangularLattice(sites=1000, Circle(1, [-1, 0]), Circle(1, [1, 0]), Circle(1, [0, √3]))\nplot(l, title = \"$(length(l)) ≈ 1000 sites\")","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"You can also use the shaperadius function to estimate the radius of the shape that will give you the desired number of sites:[1]","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"circ = SquareLattice{2}(Circle(), sites=150)\nr = shaperadius(circ, Circle())\nplot(circ, lab = \"$(length(circ)) ≈ 150 sites\")\nplot!(Circle(r), c=:grey, ls=:dash, lab = \"r ≈ $r\")","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"[1]: Actually, the shaperadius function returns the scaling factor for the shape set. However, Circle() by default creates a circle with radius 1, so the scaling factor is equal to the radius of the circle.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"note: Note\nRadius estimation is not always precise and works under following assumptions:The shapes are large enough to contain the unit cell and do not intersect with each other.\nThe inverted shapes are all contained in the non-inverted ones, and also do not intersect with each other.","category":"page"},{"location":"manual/lattice/#Multi-dimensional-lattices","page":"Defining the lattice","title":"Multi-dimensional lattices","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"This package supports multi-dimensional lattices. You can create a lattice of any dimension by creating a suitable unit cell first. Or by passing the required amount of axes to the lattice constructor, if the type supports it:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"using LatticeModels, Plots\nl = SquareLattice(5, 4, 3)\nplot(l)     # A 3D cubic lattice","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Also remember that the dimensions of the lattice are not necessarily spatial dimensions. For example, you can create a bilayer Graphene lattice by defining a unit cell with two layers:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"# Bilayer Graphene with shifted layers\nuc = UnitCell([[1, 0, 0] [1/2, √3/2, 0]], \n    [[0, 0, 0] [1/2, √3/6, 0] [0, 0, √3/3] [-1/2, -√3/6, √3/3]]) \nl = span_unitcells(uc, -2:2, -2:2)\nplot(l, lc=:grey, zwiden=1.3)","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"Effectively, it is a 2D lattice in 3D space. Note that you can always project a multi-dimensional lattice or its slice to a 2D plane when plotting it:","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"plot(l[index=(1, 2)], axes=(:x, :y))    # Plot the first layer","category":"page"},{"location":"manual/lattice/#Bonds-and-hoppings","page":"Defining the lattice","title":"Bonds and hoppings","text":"","category":"section"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"In the scope of this package, bonds are not considered part of the lattice, but rather a separate structure that connects sites. You can assign nearest-neighbour hoppings to the lattice (of course, since you can see them on the plot), but in general the lattice and the bonds are separate entities. The reasoning behind this is that in some cases you may need to use different sets of bonds for different models.","category":"page"},{"location":"manual/lattice/","page":"Defining the lattice","title":"Defining the lattice","text":"To find out more about bonds, adjacency and boundary conditions, see the next chapter: Adjacency and boundary conditions.","category":"page"},{"location":"manual/evolution/#Evolution","page":"Unitary evolution","title":"Evolution","text":"","category":"section"},{"location":"manual/evolution/#Basics","page":"Unitary evolution","title":"Basics","text":"","category":"section"},{"location":"manual/evolution/#Solvers","page":"Unitary evolution","title":"Solvers","text":"","category":"section"},{"location":"manual/evolution/#TimeSequence","page":"Unitary evolution","title":"TimeSequence","text":"","category":"section"},{"location":"library/#Internals","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-basics","page":"Library","title":"Lattice basics","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/lattice.jl\", \"lattices/genericlattice.jl\", \"lattices/bravais/unitcell.jl\", \n    \"lattices/bravais/lattice.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractLattice, LatticeModels.AbstractSite)","category":"page"},{"location":"library/#LatticeModels.IncompatibleLattices","page":"Library","title":"LatticeModels.IncompatibleLattices","text":"IncompatibleLattices([header, ]lat1, lat2)\n\nAn exception thrown when two lattices are incompatible.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteProperty","page":"Library","title":"LatticeModels.SiteProperty","text":"SiteProperty\n\nAn abstract type for a property of a site.\n\nThis interface is used to define various properties of a site. They can be accessed using getsiteproperty. This interface is used in following places:\n\nlattice[...] syntax to access sites with specific properties.\nlattice_value[...] syntax to access values defined on sites with specific properties.\nFunctions to generate LatticeValues and operators for specific properties.\n\nExamples\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(3, 3);\n\njulia> l[x = 1, y = 2]          # Get site with x = 1 and y = 2\n2-dim Bravais lattice site in 2D space at [1.0, 2.0]\n\njulia> l[x = 1]                 # Get sublattice with x = 1\n3-site 2-dim Bravais lattice in 2D space\nUnit cell:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\nLattice type: SquareLattice{2}\nDefault translations:\n  :axis1 → Bravais[3, 0]\n  :axis2 → Bravais[0, 3]\nNearest neighbor hoppings:\n  1.00000 =>\n    Bravais[1, 0]\n    Bravais[0, 1]\n  1.41421 =>\n    Bravais[1, -1]\n    Bravais[1, 1]\n  2.00000 =>\n    Bravais[2, 0]\n    Bravais[0, 2]\nBoundary conditions: none\n\njulia> l[x = 1, y = 2, z = 3]   # No site with defined z property on a 2D lattice\nERROR: ArgumentError: Invalid axis index 3 of a 2-dim site\n[...]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.check_issublattice-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.check_issublattice","text":"Checks if l1 is sublattice of l2. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samelattice-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samelattice","text":"Checks if l1 and l2 objects are defined on the same lattice. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samesites-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samesites","text":"Checks if l1 and l2 objects are defined on the same sites. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.lattice","text":"lattice(any)\n\nReturn the lattice of the given object (an operator, LatticeValue, ...)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_index","page":"Library","title":"LatticeModels.site_index","text":"site_index(lat, site[, range])\n\nReturn the index of the site in the lattice lat. If range is given, only search in the given range. Return nothing if the site is not found.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.GenericLattice","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice{SiteT}\n\nA generic lattice of SiteT sites.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = GenericLattice{2}()\n0-site 2-dim GenericLattice{GenericSite{2}}\n\njulia> push!(l, GenericSite(0, 0))  # Add a site at (0, 0)\n1-site 2-dim GenericLattice{GenericSite{2}}:\n  Site at [0.0, 0.0]\n\njulia> push!(l, (0, 1))             # Add a site at (0, 1)\n2-site 2-dim GenericLattice{GenericSite{2}}:\n  Site at [0.0, 0.0]\n  Site at [0.0, 1.0]\n\njulia> push!(l, [1, 0])             # Add a site at (1, 0)\n3-site 2-dim GenericLattice{GenericSite{2}}:\n  Site at [0.0, 0.0]\n  Site at [0.0, 1.0]\n  Site at [1.0, 0.0]\n\njulia> l[2]\n2-dim GenericSite{2} at [0.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.GenericLattice-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice(lat)\n\nConstructs a GenericLattice from some other lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{N}} where N","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice{N}()\n\nConstructs an empty N-dimensional GenericLattice of GenericSites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericLattice-Union{Tuple{}, Tuple{SiteT}} where SiteT<:LatticeModels.AbstractSite","page":"Library","title":"LatticeModels.GenericLattice","text":"GenericLattice{SiteType}()\n\nConstructs an empty GenericLattice of SiteType sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GenericSite","page":"Library","title":"LatticeModels.GenericSite","text":"GenericSite{N}\n\nA generic site in an N-dimensional lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisSite","page":"Library","title":"LatticeModels.BravaisSite","text":"BravaisSite{N,NU,B}\n\nA site of a BravaisLattice{N,NU,B} lattice.\n\nFields\n\nunitcell: a UnitCell object representing the lattice unit cell.\nlatcoords: a SVector of size N representing the lattice coordinates of the site.\nbasindex: an Int representing the index of the site in the lattice basis.\ncoords: a SVector of size N representing the spatial coordinates of the site.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.UnitCell","page":"Library","title":"LatticeModels.UnitCell","text":"UnitCell(translations[, basis; offset, rotate])\n\nConstructs a Bravais lattice unit cell with given translation vectors and locations of basis sites.\n\nArguments\n\ntranslations: an AbstractMatrix of size N×N representing the translation vectors of the lattice.\nbasis: an AbstractMatrix of size N×NB representing the locations of basis sites.   If not provided, the lattice basis will consist of one site located in the bottom-left corner of the unit cell.\n\nKeyword arguments\n\noffset: a keyword argument that specifies how to shift the lattice basis.   Possible values:\n:origin: no shift (default).\n:center: shift the lattice so that the center of the basis is at the origin of the unit cell.\n:centeralign: shift the lattice so that the center of the basis is at the center of the unit cell.\nAlso accepts an AbstractVector of size N to shift the lattice by a custom vector.\nrotate: a keyword argument that specifies how to rotate the lattice basis.   Possible values:\nnothing: no rotation (default).\nAn AbstractMatrix of size N×N to rotate the lattice.\nA Real number to rotate the lattice by this angle in radians.\nAlso accepts an AbstractMatrix of size N×N to rotate the lattice basis.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{<:Integer, <:Integer}}, NU}}} where {N, NU, NB}","page":"Library","title":"LatticeModels.span_unitcells","text":"span_unitcells([f, ]unitcell, dims...[; boundaries, offset])\n\nConstruct a Bravais lattice by spanning unitcell in dims dimensions, filtered by f.\n\nArguments\n\nf: a function that defines if the site is included in the lattice. Takes a BravaisSite, returns a Bool.\nunitcell: a UnitCell object.\ndims: a list of Integers or Ranges specifying the size of the lattice in each dimension.\n\nKeyword arguments\n\ndefault_translations: a list of BravaisTranslations to add to the lattice as default boundary condition axes.\nboundaries: a BoundaryConditions object specifying the boundary conditions of the lattice.\nrmdup: a Bool specifying whether to remove sites that are equivalent after applying the boundary conditions.\noffset: the offset of the lattice from the origin. See UnitCell for details.\nrotate: a rotation matrix to apply to the lattice. See UnitCell for details.\n\nKeep in mind that the offset and rotation are applied to the unit cell before the lattice is spanned (and f is applied). To apply them after the lattice is spanned, use the postoffset and postrotate keywords.\n\nExamples\n\njulia> using LatticeModels\n\njulia> using LatticeModels\n\njulia> uc = UnitCell([[1, 0] [0, 1]])\n1-site Unit cell of a 2-dim Bravais lattice in 2D space:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\n\njulia> span_unitcells(uc, 3, 3) == SquareLattice(3, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-constructors","page":"Library","title":"Lattice constructors","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"zoo/lattices.jl\", \"zoo/shapes.jl\"]","category":"page"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nRepresents a honeycomb lattice.\n\nLattice vectors: [1, 0] and [0.5, √3/2], two sites at [0, 0] and [0.5, √3/6] in each unit cell.\n\n\n\nHoneycombLattice(a, b)\n\nConstruct a honeycomb lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.KagomeLattice","page":"Library","title":"LatticeModels.KagomeLattice","text":"KagomeLattice\n\nRepresents a kagome lattice.\n\nLattice vectors: [1, 0] and [0.5, √3/2], three sites at [0, 0], [0.5, 0] and [0.25, √3/4] in each unit cell.\n\n\n\nKagomeLattice(a, b)\n\nConstruct a kagome lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nRepresents a square lattice in N dimensions.\n\n\n\nSquareLattice(sz...)\n\nConstruct a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TriangularLattice","page":"Library","title":"LatticeModels.TriangularLattice","text":"TriangularLattice\n\nRepresents a triangular lattice. Lattice vectors: [1, 0] and [0.5, √3/2].\n\n\n\nTriangularLattice(a, b)\n\nConstruct a triangular lattice of a×b spanned unit cells.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Chain-Tuple{Function, Any}","page":"Library","title":"LatticeModels.Chain","text":"Chain(sz)\n\nConstruct a 1D chain lattice of size sz.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GrapheneRibbon","page":"Library","title":"LatticeModels.GrapheneRibbon","text":"GrapheneRibbon(len, wid[, center; kw...])\n\nConstruct a graphene ribbon sample with zigzag edges. To get armchair edges, simply rotate the lattice by 90 degrees.\n\nArguments\n\nlen: the length of the ribbon.\nwid: the width of the ribbon.\ncenter: the unit cell coordinates of the bottom-left corner of the ribbon. Default is (0, 0).\n\nAll other keyword arguments are passed to span_unitcells (see its documentation for details).\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.@bravaisdef-Tuple{Any, Any}","page":"Library","title":"LatticeModels.@bravaisdef","text":"@bravaisdef MyBravaisLattice UnitCell(...)\n@bravaisdef MyBravaisLattice N -> UnitCell(...)\n\nDefine a new Bravais lattice type MyBravaisLattice with a unit cell constructor UnitCell(expr). If the notation is N -> UnitCell(expr), the unit cell constructor will be dependent on the dimensionality N. otherwise, the dimensionality will be inferred from the unit cell. N is the dimensionality of the lattice.\n\nExamples\n\njulia> using LatticeModels\n\njulia> @bravaisdef MyBravaisLattice UnitCell([1 0; 0 1]);   # 2D square lattice\n\njulia> MyBravaisLattice(3, 3)\n9-site 2-dim Bravais lattice in 2D space\nUnit cell:\n  Basis site coordinates:\n    ┌      ┐\n    │ 0.000│\n    │ 0.000│\n    └      ┘\n  Translation vectors:\n    ┌      ┐ ┌      ┐\n    │ 1.000│ │ 0.000│\n    │ 0.000│ │ 1.000│\n    └      ┘ └      ┘\nLattice type: MyBravaisLattice\nDefault translations:\n  :axis1 → Bravais[3, 0]\n  :axis2 → Bravais[0, 3]\nNearest neighbor hoppings:\n  1.00000 =>\n    Bravais[1, 0]\n    Bravais[0, 1]\n  1.41421 =>\n    Bravais[1, -1]\n    Bravais[1, 1]\n  2.00000 =>\n    Bravais[2, 0]\n    Bravais[0, 2]\nBoundary conditions: none\n\n\n\n\n\n","category":"macro"},{"location":"library/#LatticeModels.BallND","page":"Library","title":"LatticeModels.BallND","text":"BallND{N}([radius, center])\n\nConstruct a N-dimensional ball with a given radius and center. Note the aliases: Circle and Ball are BallND{2} and BallND{3} respectively.\n\nArguments\n\nradius: The radius of the ball.\ncenter: The center of the ball.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Path","page":"Library","title":"LatticeModels.Path","text":"Path(start, stop)\n\nConstruct a path from start to stop.\n\nArguments\n\nstart: The start of the path.\nstop: The end of the path.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Polygon","page":"Library","title":"LatticeModels.Polygon","text":"Polygon{N}([radius, center])\nPolygon{N}([center; h])\n\nConstruct a regular N-sided polygon with a given (circumscribed) radius and center. Note the aliases: Triangle, Square, and Hexagon are Polygon{3}, Polygon{4}, and Polygon{6} respectively.\n\nArguments\n\nradius: The (circumscribed) radius of the polygon.\ncenter: The center of the polygon.\n\nKeyword Arguments\n\nh: The distance from the center to the vertices. If given, the radius is calculated as h / cos(pi / N).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Rectangle","page":"Library","title":"LatticeModels.Rectangle","text":"Rectangle(w, h)\n\nConstruct a rectangle with given horizontal and vertical intervals. Usage: Rectangle(1..3, 2..4).\n\nArguments\n\nw: The horizontal range.\nh: The vertical range.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteAt","page":"Library","title":"LatticeModels.SiteAt","text":"SiteAt(coords)\n\nRepresents a single site at the given coordinates.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.fillshapes-Union{Tuple{N}, Tuple{UnitCell{Sym, N} where Sym, Vararg{LatticeModels.AbstractShape}}} where N","page":"Library","title":"LatticeModels.fillshapes","text":"fillshapes(uc, shapes...[; sites, scale, kw...])\n\nCreate a lattice sample with geometry defined by the given shapes. The lattice is filled with sites that are inside the shapes.\n\nArguments\n\nuc: The UnitCell of the lattice. Might also be a lattice type.\nshapes: The shapes to fill the lattice with.\n\nKeyword Arguments\n\nsites: If given, an attepmt will be made to fill the lattice with the given number of sites.   The scaling will be approximate and relying on assumptions that the shapes do not overlap.\nscale: The scaling factor for the shapes. If sites is given, the scaling factor will be   calculated automatically.\n\nAll other keyword arguments are passed to the lattice constructor. See span_unitcells for more information.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.removedangling!-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.removedangling!","text":"removedangling!(lat[; maxdepth])\n\nRemove dangling sites from the lattice. A site is considered dangling if it has less than 2 neighbors. The function will remove all dangling sites and their neighbors recursively up to maxdepth levels.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.shaperadius-Tuple{UnitCell, LatticeModels.AbstractShape, Int64}","page":"Library","title":"LatticeModels.shaperadius","text":"shape_radius(unitcell, shape, sites)\nshape_radius(lat, shape[, sites])\n\nCalculate the radius of a shape such that it contains appriximately sites sites.\n\nArguments\n\nunitcell: The UnitCell of the lattice. Might also be a lattice type.\nlat: The lattice. It is considered that the lattice was constructed in the same shape.\nshape: The shape to calculate the radius for.\nsites: The number of sites the shape should contain.\n\n\n\n\n\n","category":"method"},{"location":"library/#Bonds","page":"Library","title":"Bonds","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/bonds.jl\", \"lattices/bravais/bonds.jl\", \"lattices/bravais/nearestneighbor.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractBonds, LatticeModels.AbstractTranslation, \n    LatticeModels.DirectedBonds)","category":"page"},{"location":"library/#LatticeModels.AdjacencyMatrix","page":"Library","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix{LT} where {LT<:Lattice}\n\nRepresents the bonds on some lattice.\n\n\n\nAdjacencyMatrix(lat[, mat])\n\nConstruct an adjacency matrix from the mat matrix on the lat lattice.\n\nIf mat is not provided, it is assumed to be a zero matrix.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(2, 2);\n\njulia> a = AdjacencyMatrix(l)\nAdjacency matrix on 4-site 2-dim Bravais lattice in 2D space\nValues in a 4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 0 stored entries:\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n\njulia> site1, site2, site3, site4 = l;\n\njulia> a[site1, site2] = a[site2, site4] = a[site3, site4] = true;\n\njulia> a\nAdjacency matrix on 4-site 2-dim Bravais lattice in 2D space\nValues in a 4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 6 stored entries:\n ⋅  1  ⋅  ⋅\n 1  ⋅  ⋅  1\n ⋅  ⋅  ⋅  1\n ⋅  1  1  ⋅\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AdjacencyMatrix-Tuple{Function, LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix(f, lat)\n\nConstructs an adjacency matrix from the function f that returns if the sites are connected on the lat lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.AdjacencyMatrix-Tuple{LatticeModels.AbstractBonds, Vararg{LatticeModels.AbstractBonds}}","page":"Library","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix([lat, ]bonds...)\n\nConstructs an adjacency matrix from the bonds. If lat is not provided, it is inferred from the bonds.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.SiteDistance","page":"Library","title":"LatticeModels.SiteDistance","text":"SiteDistance(f, lat)\n\nA bonds type that connects sites based on the distance between them.\n\nArguments\n\nf: A function that takes a distance and returns if the distance is allowed.\nlat: The lattice where the bonds are defined.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Translation","page":"Library","title":"LatticeModels.Translation","text":"Translation <: AbstractTranslation\n\nA spatial translation on some lattice.\n\nFields\n\nlat: The lattice where the translations are defined.\nR: The vector of the translation.\n\nExample\n\njulia> using LatticeModels\n\njulia> gl = GenericLattice([(1, 1), (1, 2), (2, 1), (2, 2)])\n4-site 2-dim GenericLattice{GenericSite{2}}:\n  Site at [1.0, 1.0]\n  Site at [1.0, 2.0]\n  Site at [2.0, 1.0]\n  Site at [2.0, 2.0]\n\njulia> tr = Translation(gl, [1, 0])     # Translation by [1, 0]\nTranslation by [1.0, 0.0]\n on 4-site 2-dim GenericLattice{GenericSite{2}}\n\njulia> site1 = gl[!, x = 1, y = 1]      # Site at [1, 1]\n2-dim GenericSite{2} at [1.0, 1.0]\n\njulia> site1 + tr                       # Translated site\n2-dim GenericSite{2} at [2.0, 1.0]\n\njulia> site1 - tr                       # Inverse translation\n2-dim GenericSite{2} at [0.0, 1.0]\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.UndefinedLattice","page":"Library","title":"LatticeModels.UndefinedLattice","text":"UndefinedLattice\n\nA lattice that is not defined. The bonds can be 'defined' on it in context where the lattice is already defined before, e. g. in construct_operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.adapt_bonds-Tuple{Any, LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.adapt_bonds","text":"adapt_bonds(bonds, lat)\n\nAdapt the bonds to the lattice lat. The output can be a different type of bonds, more fitting for the concrete type of lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.adjacentsites-Tuple{AdjacencyMatrix, LatticeModels.AbstractSite}","page":"Library","title":"LatticeModels.adjacentsites","text":"adjacentsites(bonds, site)\n\nReturns the sites that are connected to site by the bonds.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sitedistance-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}","page":"Library","title":"LatticeModels.sitedistance","text":"sitedistance([lat, ]site1, site2)\n\nReturns the distance between two sites on the lat lattice, taking boundary conditions into account.\n\nArguments\n\nlat: The lattice where the sites are defined.\nsite1 and site2: The sites to measure the distance between.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.Bravais","page":"Library","title":"LatticeModels.Bravais","text":"Bravais[ lattice_coords ]\n\nA convenient constructor for a BravaisTranslation that does not permute sublattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisTranslation","page":"Library","title":"LatticeModels.BravaisTranslation","text":"BravaisTranslation([site_indices, ]translate_uc)\nBravaisTranslation(site_indices)\nBravaisTranslation([site_indices; ]axis[, dist=1])\n\nA convenient constructor for a BravaisTranslation object.\n\nArguments\n\nsite_indices: a ::Int => ::Int pair with indices of sites connected by the bond;\n\nif omitted, the bond connects sites with the same sublattice index.\n\ntranslate_uc: The unit cell offset.\n\nKeyword arguments\n\naxis: The hopping direction axis in terms of unit cell vectors.\ndist: The hopping distance in terms of unit cell vectors.\n\nIf site_indices are equal or undefined and translate_uc is zero, the translation is considered to be a translation of all sites to themselves. An error will be thrown in this case.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.BravaisTranslation-2","page":"Library","title":"LatticeModels.BravaisTranslation","text":"BravaisTranslation{T, N}\n\nA struct representing bonds in some direction in a lattice.\n\nNote that though the dimension count for the bond is static, it is automatically compatible with higher-dimensional lattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NearestNeighbor","page":"Library","title":"LatticeModels.NearestNeighbor","text":"NearestNeighbor(lat[, N=1])\n\nReturns the nearest neighbor bonds of order N for the lattice lat.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = HoneycombLattice(5, 5);\n\njulia> NearestNeighbor(lat)\nBravaisSiteMapping with 3 translations:\n  1 => 2, [0, -1]\n  1 => 2, [-1, 0]\n  1 => 2, [0, 0]\n on 50-site 2-dim Bravais lattice in 2D space (2-site basis)\n\njulia> lat = SquareLattice(3, 3, 3, 3);\n\njulia> NearestNeighbor(lat, 4)\nBravaisSiteMapping with 12 translations:\n  Bravais[1, -1, -1, -1]\n  Bravais[1, 1, -1, -1]\n  Bravais[1, -1, 1, -1]\n  Bravais[1, 1, 1, -1]\n  Bravais[2, 0, 0, 0]\n  Bravais[0, 2, 0, 0]\n  Bravais[0, 0, 2, 0]\n  Bravais[1, -1, -1, 1]\n  Bravais[1, 1, -1, 1]\n   ⋮\n on 81-site 4-dim Bravais lattice in 4D space\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NearestNeighbor-2","page":"Library","title":"LatticeModels.NearestNeighbor","text":"NearestNeighbor{N}\n\nA bonds type that connects sites that are nearest neighbors of order N on some lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.getnnbonds-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.getnnbonds","text":"getnnbonds(lat)\n\nReturns the nearest neighbor bonds of the lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#Boundary-conditions","page":"Library","title":"Boundary conditions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/boundaries.jl\"]","category":"page"},{"location":"library/#LatticeModels.BoundaryConditions","page":"Library","title":"LatticeModels.BoundaryConditions","text":"BoundaryConditions\n\nA collection of boundary conditions for a lattice.\n\nFields\n\nbcs: A tuple of boundary conditions.\ndepth: The upper limit of the depth of the boundary conditions (used for routing).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.FunctionBoundary","page":"Library","title":"LatticeModels.FunctionBoundary","text":"FunctionBoundary <: Boundary\n\nA boundary condition with a function that returns the phase factor for a given site. The boundary condition is encoded in form ψ(x + R) = f(x)ψ(x), where f(x) is the function and R is the translation vector.\n\n\n\nFunctionBoundary(f, translation)\n\nConstruct a FunctionBoundary with a given function and translation.\n\nArguments\n\nf: The function that returns the phase factor for a given site.\ntranslation: The translation vector of the boundary representad as AbstractTranslation.   If an array is passed, it is converted to Translation automatically.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TwistedBoundary","page":"Library","title":"LatticeModels.TwistedBoundary","text":"TwistedBoundary <: Boundary\n\nA boundary condition with a phase twist. A PeriodicBoundary is a special case of TwistedBoundary with zero twist.\n\n\n\nTwistedBoundary(translation, Θ)\n\nConstruct a TwistedBoundary with a given translation and twist angle.\n\nArguments\n\ntranslation: The translation vector of the boundary representad as AbstractTranslation.   If an array is passed, it is converted to Translation automatically.\nΘ: The twist angle in radians.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PeriodicBoundary-Tuple{Any}","page":"Library","title":"LatticeModels.PeriodicBoundary","text":"PeriodicBoundary(translation)\n\nConstruct a PeriodicBoundary with a given translation.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.setboundaries-Tuple{LatticeModels.AbstractLattice, BoundaryConditions}","page":"Library","title":"LatticeModels.setboundaries","text":"setboundaries(lat, boundaries...[; checkboundaries=true, rmdup=false])\n\nSet the boundary conditions for the lattice lat.\n\nArguments\n\nlat: The lattice.\nboundaries: The boundary conditions. It can be a single Boundary or a Tuple of Boundary objects.\n\nKeyword arguments\n\ncheckboundaries: If true, check if the boundary conditions overlap within the lattice sites.\nrmdup: If true, remove duplicate sites from the lattice.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(4, 4);\n\njulia> l2 = setboundaries(l, [4, 0] => true, [0, 4] => pi);\n\njulia> l2.boundaries\nBoundary conditions (depth = 1):\n  Bravais[4, 0] → periodic\n  Bravais[0, 4] → twist θ = 3.14\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.translate_to_nearest-Tuple{LatticeModels.AbstractLattice, LatticeModels.AbstractSite, LatticeModels.AbstractSite}","page":"Library","title":"LatticeModels.translate_to_nearest","text":"translate_to_nearest(lat, site1, site2)\n\nTranslate site2 to its equivalent nearest to site1 in the lattice lat, taking the boundary conditions into account.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeValue","page":"Library","title":"LatticeValue","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"core/latticevalue.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LT}\n\nRepresents a value of type T on a LT lattice.\n\nFields\n\nlattice: the AbstractLattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, AbstractVector}","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue(lat, values)\n\nConstructs a LatticeValue object.\n\nArguments\n\nlat: the lattice the value is defined on.\nvalues: an AbstractVector of values on the lattice.\n\nExample\n\njulia> using LatticeModels\n\njulia> l = SquareLattice(2, 2);\n\njulia> LatticeValue(l, [1, 2, 3, 4])    # Custom values\nLatticeValue{Int64} on a 4-site 2-dim Bravais lattice in 2D space\nValues stored in a Vector{Int64}:\n[1, 2, 3, 4]\n\njulia> LatticeValue(l, :x)              # x-coordinate\nLatticeValue{Float64} on a 4-site 2-dim Bravais lattice in 2D space\nValues stored in a Vector{Float64}:\n[1.0, 1.0, 2.0, 2.0]\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.LatticeValue-Tuple{LatticeModels.AbstractLattice, LatticeModels.SiteProperty}","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue(lat, prop)\n\nGenerates a LatticeValue representing the site property prop on lattice lat.\n\nArguments\n\nlat: the lattice the value is defined on.\nprop: the SiteProperty to be represented. Can be a SiteProperty or a Symbol defining it.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.brastate-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.brastate","text":"brastate(lv)\n\nConverts a LatticeValue to a Bra wavefunction vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coordvalue-Tuple{LatticeModels.AbstractLattice, Int64}","page":"Library","title":"LatticeModels.coordvalue","text":"coordvalue(lat, coord)\n\nGenerates a LatticeValue representing the spatial coordinate coord on lattice lat.\n\nArguments\n\nlat: the lattice the value is defined on.\ncoord: the coordinate to be represented. Can be an integer or a symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coordvalues-Tuple{LatticeModels.AbstractLattice}","page":"Library","title":"LatticeModels.coordvalues","text":"coordvalues(lat)\n\nGenerates a tuple of LatticeValues representing spatial coordinates on lattice lat.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ketstate-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.ketstate","text":"ketstate(lv)\n\nConverts a LatticeValue to a Ket wavefunction vector.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.project-Tuple{LatticeValue, LatticeModels.SiteProperty}","page":"Library","title":"LatticeModels.project","text":"project(lv, axis)\n\nProjects the lv::LatticeValue along the given axis.\n\nArguments\n\nlv: the LatticeValue to be projected.\naxis: the SiteProperty describing the axis to be projected along.\n\n\n\n\n\n","category":"method"},{"location":"library/#Operators-and-observables","page":"Library","title":"Operators and observables","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"operators/bases.jl\", \"operators/miscoperators.jl\", \"operators/manybody.jl\", \n    \"operators/latticeutils.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeBasis","page":"Library","title":"LatticeModels.LatticeBasis","text":"LatticeBasis <: QuantumOpticsBase.Basis\n\nBasis for a lattice system.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.coordoperators-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"Library","title":"LatticeModels.coordoperators","text":"coordoperators(sys)\ncoordoperators(basis)\ncoordoperators(lat[, internal])\n\nGenerate a Tuple of coordinate operators for the given lattice.\n\nArguments\n\nsys: a System for which the coordinate operators are to be generated.\nbasis: a one-particle Basis for which the coordinate operators are to be generated.\nlat: a lattice for which the coordinate operators are to be generated.\ninternal: The basis for the internal degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"library/#QuantumOpticsBase.transition","page":"Library","title":"QuantumOpticsBase.transition","text":"QuantumOpticsBase.transition(sys::System, site1::LatticeSite, site2::LatticeSite[, op; field])\nQuantumOpticsBase.transition(sys::System, i1::Int, i2::Int[, op; field])\n\nGenerate a transition operator between two local states in lattice space. States can be defined by LatticeSites or integers.\n\nStandard rules for functions accepting Systems apply.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.interaction-Tuple{Function, Type{<:Number}, NParticles}","page":"Library","title":"LatticeModels.interaction","text":"interaction(f, [T, ]sys)\n\nCreate an two-site interaction operator for a given NParticles system. The function f takes two arguments, which are the two sites, and returns the interaction energy.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.interaction-Union{Tuple{K}, Tuple{Function, Type{<:Number}, NParticles, Val{K}}} where K","page":"Library","title":"LatticeModels.interaction","text":"interaction(f, [T, ]sys, K[; affect_internal=true])\n\nCreate an 2K-site interaction operator for a given NParticles system. The function f takes two K-tuples of integer numbers, which are site indices for creation and annihilation operators, and returns the interaction energy.\n\nIf affect_internal is true (default), the interaction operator will act on the internal degrees of freedom as well, and f will take four K-tuples - lattice and internal indices for creation and annihilation operators. If the system has no internal degrees of freedom, affect_internal will automatically be set to false and f will take two K-tuples.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.AdjacencyMatrix-Tuple{DataOperator{BT, BT} where BT<:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"Library","title":"LatticeModels.AdjacencyMatrix","text":"AdjacencyMatrix(op::Operator)\n\nGenerates an AdjacencyMatrix for the provided operator.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.localdensity-Tuple{Union{DataOperator{var\"#s177\", var\"#s177\"}, Bra{var\"#s177\"}, Ket{var\"#s177\"}} where var\"#s177\"<:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}","page":"Library","title":"LatticeModels.localdensity","text":"localdensity(state)\n\nCompute the local density of given state. The result is a LatticeValue with the same lattice as the input state.\n\nArguments\n\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\n\n\n\n\n\n","category":"method"},{"location":"library/#Hamiltonians","page":"Library","title":"Hamiltonians","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"operators/system.jl\", \"operators/builder.jl\", \"operators/constructoperator.jl\",\n    \"operators/magneticfield.jl\", \"zoo/magneticfields.jl\"]","category":"page"},{"location":"library/#LatticeModels.NParticles-Union{Tuple{SampleT}, Tuple{SampleT, Any}} where SampleT<:LatticeModels.Sample","page":"Library","title":"LatticeModels.NParticles","text":"NParticles(lat[, internal], N[; T=0, statistics=FermiDirac])\nNParticles(sys, N[; T=0, statistics=FermiDirac])\n\nCreate a manybody system with a given lattice and a given number of particles.\n\nArguments\n\nlat: the lattice of the system.\ninternal: The basis for the internal degrees of freedom.\nsys: a one-particle system.\nN: the number of particles in the system.\n\nKeyword Arguments\n\nT: the temperature of the system. Default is 0.\nstatistics: the statistics of the particles. Default is FermiDirac.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(3, 3);\n\njulia> NParticles(lat, 4, statistics=BoseEinstein)\nNParticles(4 bosons) on 9-site 2-dim Bravais lattice in 2D space\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.System-Tuple{LatticeModels.Sample}","page":"Library","title":"LatticeModels.System","text":"System(lat[, internal; T, μ, N, statistics])\n\nCreate a system with a given lattice and optionally internal degrees of freedom.\n\nArguments\n\nlat: the lattice of the system.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword Arguments\n\nT: the temperature of the system. Default is 0.\nμ: the chemical potential of the system. Use mu synonym if Unicode input is not available.\nN: the number of particles in the system.\nstatistics: the statistics of the particles. Default is FermiDirac.\n\nExample\n\njulia> using LatticeModels\n\njulia> lat = SquareLattice(3, 3);\n\njulia> System(lat)\nOne particle on 9-site 2-dim Bravais lattice in 2D space\n\njulia> System(lat, N=4, statistics=BoseEinstein)\n4 non-interacting bosons on 9-site 2-dim Bravais lattice in 2D space\n\njulia> System(lat, mu=0, statistics=BoseEinstein)\nNon-interactng bosons with fixed μ=0.0 on 9-site 2-dim Bravais lattice in 2D space\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sample-Tuple{LatticeBasis}","page":"Library","title":"LatticeModels.sample","text":"Returns the Sample of the object.\n\nDefine this function for your type to implement Sample API.\n\ninfo: Info\nThis function can be considered stable internal API. Feel free to use it in your packages.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.OperatorBuilder","page":"Library","title":"LatticeModels.OperatorBuilder","text":"OperatorBuilder\n\nA helper struct for building custom operators. This struct is used to build operators for a given system or lattice.\n\nExample\n\nl = SquareLattice(5, 5)\nbuilder = OperatorBuilder(l, field=LandauGauge(0.1), auto_hermitian=true)\nxhop = Bravais[1, 0]\nyhop = Bravais[0, 1]\nfor site in l\n    x, y = site\n    builder[site, site] = x + 2y\n    builder[site, site + xhop] = 1\n    builder[site, site + yhop] = 1im\n    site2 = l[rand(1:25)]\n    builder[site, site2] += 1\nend\nH = Hamiltonian(builder)\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.OperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{<:Number}, SystemT}} where {SystemT<:System, FieldT<:LatticeModels.AbstractField}","page":"Library","title":"LatticeModels.OperatorBuilder","text":"OperatorBuilder([T, ]sys, [; field=NoField(), auto_hermitian=false])\nOperatorBuilder([T, ]lat, [internal; field=NoField(), auto_hermitian=false])\n\nConstruct an OperatorBuilder for a given system or lattice.\n\nArguments\n\nT: The type of the matrix elements. Defaults to ComplexF64.\nsys: A System object representing the system.\nlat: The lattice on which the operator is defined.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword arguments\n\nfield: The gauge field to use for the bond operators.\nauto_hermitian: Whether to automatically add the hermitian conjugate of the operator. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.FastOperatorBuilder-Union{Tuple{FieldT}, Tuple{SystemT}, Tuple{Type{<:Number}, SystemT}} where {SystemT<:System, FieldT<:LatticeModels.AbstractField}","page":"Library","title":"LatticeModels.FastOperatorBuilder","text":"FastOperatorBuilder([T, ]sys, [; field=NoField(), auto_hermitian=false])\nFastOperatorBuilder([T, ]lat, [internal; field=NoField(), auto_hermitian=false])\n\nConstruct an OperatorBuilder for a given system or lattice. This version of the constructor uses a slightly faster internal representation of the operator matrix, but only allows increment/decrement assignments. builder[site1, site2] += 1 is allowed, but builder[site1, site2] = 1 is not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.construct_hamiltonian-Tuple{Type, System, Vararg{Any}}","page":"Library","title":"LatticeModels.construct_hamiltonian","text":"construct_hamiltonian([T, ]sys, terms...[; field])\nconstruct_hamiltonian([T, ]lat[, internal, terms...; field])\n\nConstruct a Hamiltonian for the given system. Does the same as construct_operator, but wraps the result in a Hamiltonian type.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.construct_operator-Tuple{Type, System, Vararg{Any}}","page":"Library","title":"LatticeModels.construct_operator","text":"construct_operator([T, ]sys, terms...[; field])\nconstruct_operator([T, ]lat[, internal, terms...; field])\n\nConstruct an operator for the given system.\n\nEach of the terms describes a term of the Hamiltonian. The term can be given in several ways:\n\nA DataOperator on the lattice, internal or composite basis (will be matched automatically).\nA Pair of an \"internal\" and an \"on-lattice\" part (e.g. int_p => lat_p):\nThe \"internal\" part can be a DataOperator, a matrix or a number.\nThe \"on-lattice\" part can be a LatticeValue (represents a diagonal term), a site   (represents a local on-site potential), a bond (represents a hopping term) or a site1 => site2   pair (represents a single hopping).\nIdentity \"internal\" or \"on-lattice\" parts can be omitted.\n\nSee documentation for more details.\n\nArguments\n\nT: The element type of the Hamiltonian. Default is ComplexF64.\nsys: The System for which the Hamiltonian is constructed.\nlat: The lattice for which the Hamiltonian is constructed.\ninternal: The basis for the internal degrees of freedom.\n\nKeyword Arguments\n\nfield: The gauge field to use for the bond operators. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.tightbinding_hamiltonian-Tuple{Type, System, Vararg{Any}}","page":"Library","title":"LatticeModels.tightbinding_hamiltonian","text":"tightbinding_hamiltonian([T, ]sys[, args...; t1=1, t2=0, t3=0, field])\ntightbinding_hamiltonian([T, ]lat[, internal, args...; t1=1, t2=0, t3=0, field])\n\nConstruct a tight-binding Hamiltonian for the given system.\n\nArguments\n\nT: The element type of the Hamiltonian. Default is ComplexF64.\nsys: The System for which the Hamiltonian is constructed.\nlat: The lattice for which the Hamiltonian is constructed.\ninternal: The basis for the internal degrees of freedom.\n\nAll other arguments are interpreted as terms of the Hamiltonian and passed to construct_hamiltonian.\n\nKeyword Arguments\n\nt1, t2, t3: The hopping amplitudes for the nearest, next-nearest, and next-next-nearest   neighbors, respectively.\nfield: The gauge field to use for the bond operators. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.GaugeField","page":"Library","title":"LatticeModels.GaugeField","text":"GaugeField <: AbstractField\n\nA gauge field defined by a vector potential function.\n\n\n\nGaugeField(func; n)\n\nCreate a gauge field with a given vector potential function func.\n\nArguments\n\nfunc: a function that takes a point in space and returns the vector potential at this point as a SVector or Tuple.\nn: the number of steps to use in the trapezoidal rule integration.\n\nExample\n\nfield = GaugeField(n = 10) do p\n    (-0.5 * p[2], 0.5 * p[1], 0)\nend\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LineIntegralGaugeField","page":"Library","title":"LatticeModels.LineIntegralGaugeField","text":"LineIntegralGaugeField <: AbstractField\n\nA gauge field defined by a line integral function.\n\n\n\nLineIntegralGaugeField(func)\n\nCreate a gauge field with a given line integral function func. The function should take two points in space and return the line integral of the vector potential between these points.\n\nExample\n\nfield = LineIntegralGaugeField() do p1, p2\n    0.5 * (p2[1] - p1[1]) * (p2[2] + p1[2]) # A = [-y/2, x/2, 0]\nend\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.NoField","page":"Library","title":"LatticeModels.NoField","text":"NoField <: AbstractField\n\nA stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}","page":"Library","title":"LatticeModels.line_integral","text":"line_integral(field, p1, p2[, n_steps=1])\n\nCalculates the int_p1^p2 overrightarrowA cdot overrightarrowdl integral using the trapezoidal rule. Increase n_steps to improve accuracy (note that for linear field gauges like Landau or symmetrical the formula is already pefrectly accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}","page":"Library","title":"LatticeModels.vector_potential","text":"vector_potential(field, point)\n\nReturns vector potential overrightarrowA for field in location point.\n\nThis function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.LandauGauge","page":"Library","title":"LatticeModels.LandauGauge","text":"LandauGauge <: AbstractField\n\nAn object representing Landau gauge uniform magnetic field along z-axis.\n\nFields\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.PointFlux","page":"Library","title":"LatticeModels.PointFlux","text":"PointFlux{GaugeT} <: AbstractField\n\nAn object representing a small magnetic flux through given point. The field is directed along z-axis.\n\nFields\n\nflux: The magnetic flux value.\npoint: A Tuple of x and y coordinates of the point.\n\n\n\nPointFlux(flux, [point; gauge])\n\nConstruct a PointFlux object with given flux and point.\n\nThe optional gauge argument can be used to specify the gauge of the field. Possible values are :axial (A(r) = B times fracrr) and :singular (the the phase changes if the particle passes below the point). The default is :axial.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SymmetricGauge","page":"Library","title":"LatticeModels.SymmetricGauge","text":"SymmetricGauge <: AbstractField\n\nAn object representing symmetrically gauged uniform magnetic field along z-axis.\n\nFields\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#Built-in-models","page":"Library","title":"Built-in models","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"zoo/models.jl\"]","category":"page"},{"location":"library/#LatticeModels.bosehubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}","page":"Library","title":"LatticeModels.bosehubbard","text":"bosehubbard([type, ]lat, N[; U, T, t1, t2, t3, field])\n\nhatH = sum_ij^textsites t_ij c^dagger_i c_j + sum_i^textsites fracU2 hatn_i (hatn_i - 1)\n\nGenerates a Bose-Hubbard model hamiltonian on given lattice lat.\n\nArguments\n\ntype: The element type of the resulting operator. Default is ComplexF64.\nN: The number of particles.\n\nKeyword arguments\n\nt1, t2, t3 denote the coefficient on first, second and third hoppings respectively.   By default t1 is equal to one, the rest are zero.\nU: The interaction strength. Default is zero.\nT: The temperature of the system. Default is zero.\nfield: The magnetic field. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.fermihubbard-Tuple{Type, LatticeModels.AbstractLattice, Int64}","page":"Library","title":"LatticeModels.fermihubbard","text":"fermihubbard([type, ]lat, N[; U, T, t1, t2, t3, field])\n\nhatH = sum_ij^textsites t_ij c^dagger_i c_j + sum_i^textsites fracU hatn_i^uparrow hatn_i^downarrow\n\nGenerates a Fermi-Hubbard model hamiltonian on given lattice lat.\n\nArguments\n\ntype: The element type of the resulting operator. Default is ComplexF64.\nN: The number of particles.\n\nKeyword arguments\n\nt1, t2, t3 denote the coefficient on first, second and third hoppings respectively.   By default t1 is equal to one, the rest are zero.\nU: The interaction strength. Default is zero.\nT: The temperature of the system. Default is zero.\nfield: The magnetic field. Default is NoField().\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.haldane","page":"Library","title":"LatticeModels.haldane","text":"haldane(lat, t1, t2[, m=0; T, μ, field, statistics])\n\nhatH = sum_i^textsublattice A m c^dagger_i c_i + sum_j^textsublattice B m c^dagger_j c_j + sum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) + sum_i j^text2-connected counter-clockwise left( i cdot t_2 c^dagger_i c_j + h c right)\n\nGenerates a Haldane topological insulator hamiltonian operator on given lattice lat.\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.kanemele-Tuple{System, Real, Real}","page":"Library","title":"LatticeModels.kanemele","text":"kanemele(lat, t1, t2[; T, μ, field, statistics])\n\nhatH = sum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) + sum_i j^text2-connected counter-clockwise left( i cdot t_2 c^dagger_i σ_z c_j + h c right)\n\nGenerates a Kane-Mele hamiltonian operator on given lattice lat.\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use keyword mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.qwz-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.qwz","text":"qwz(m[; T, μ, field, statistics])\nqwz(lat[, m; T, μ, field, statistics])\n\nhatH = sum_i^textsites m_i c^dagger_i sigma_z c_i + sum_i^textsites left( c^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + c^dagger_i + haty fracsigma_z - i sigma_y2 c_i + h c right)\n\nGenerates a QWZ model hamiltonian operator on given square lattice lat.\n\nArguments\n\nm (either a LatticeValue or a number) defines the m_i factors\n\nKeyword arguments\n\nT: The temperature of the system. Default is zero.\nμ: The chemical potential. Use mu as a synonym if Unicode input is not available.\nfield: The magnetic field. Default is NoField().\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\n\n\n\n\n\n","category":"method"},{"location":"library/#Diagonalization","page":"Library","title":"Diagonalization","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"spectrum.jl\"]","category":"page"},{"location":"library/#LatticeModels.Eigensystem","page":"Library","title":"LatticeModels.Eigensystem","text":"Eigensystem{LT, MT} where {LT<:AbstractLattice, MT<:AbstractMatrix}\n\nEigenvalues and eigenvectors for some operator.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{<:LatticeModels.FixedMu}}","page":"Library","title":"LatticeModels.densitymatrix","text":"densitymatrix(eig::Eigensystem[; T=0, μ, N, statistics, info=true])\n\nCreates an Operator representing a equilibrium density matrix, given the eigensystem eig of the Hamiltonian.\n\nThe resulting distribution will be Fermi-Dirac or Bose-Einstein if the statistics is specified, otherwise the Gibbs distribution will be used.\n\nKeyword arguments\n\nT is the temperature of the system. Default is zero.\nμ is the chemical potential. Use mu as a synonym if Unicode input is not available.\nN is the number of particles. If specified, the chemical potential is found automatically.\nstatistics defines the particle statistics, either FermiDirac or BoseEinstein.\ninfo is a boolean flag to enable/disable logging. Default is true.\n\nNote that if eig is a diagonalized Hamiltonian, the μ, N and statistics parameters are inserted automatically.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.diagonalize-Tuple{Hamiltonian, Val}","page":"Library","title":"LatticeModels.diagonalize","text":"diagonalize(op::DataOperator[, routine; params...])\n\nFinds eigenvalues and eigenvectors for a Operator and stores them in an Eigensystem.\n\nTwo routines are available:\n\n:lapack uses the eigen function from the standard LinearAlgebra package.\n:krylovkit uses the Lanczos algorithm from the KrylovKit package.   Accepts following parameters:\nv0 is the starting vector. Default is rand(ComplexF64, size(op.data, 1)).\nn is the target number of eigenvectors. Default is 10.\nAll other keyword arguments are passed to the KrylovKit.eigsolve function. See its documentation for details.\n:auto automatically selects the routine based on the size of the operator.\n\nThe default routine is :lapack for dense operators. If the operator matrix is less than 5000×5000, it is automatically converted to a dense operator. In other cases :krylovkit is used.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.findgroundstate-Tuple{LatticeModels.HamiltonianEigensystem}","page":"Library","title":"LatticeModels.findgroundstate","text":"findgroundstate(eig::HamiltonianEigensystem)\nfindgroundstate(ham::Hamiltonian)\n\nFinds the ground state of a Hamiltonian. Returns the energy and the state.\n\nExample\n\neig = diagonalize(ham)\nE, ψ = findgroundstate(eig)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.groundstate-Tuple{Any}","page":"Library","title":"LatticeModels.groundstate","text":"groundstate(eig::HamiltonianEigensystem)\ngroundstate(ham::Hamiltonian)\n\nFinds the ground state of a Hamiltonian. Returns the state.\n\nExample\n\neig = diagonalize(ham)\nψ = groundstate(eig)\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{Any, LatticeModels.AbstractEigensystem}","page":"Library","title":"LatticeModels.projector","text":"projector(f, eig::Eigensystem)\n\nReturns an Operator representing a function applied to the diagonalized operator defined by the formula below:\n\nhatmathcalP = sum_i f(A_i) psi_ipsi_i\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.projector-Tuple{LatticeModels.AbstractEigensystem}","page":"Library","title":"LatticeModels.projector","text":"projector(eig::Eigensystem)\n\nreturns an Operator that projects onto the eigenvectors of the spectrum, defined by the formula below.\n\nhatmathcalP = sum_i psi_ipsi_i\n\n\n\n\n\n","category":"method"},{"location":"library/#Green's-function","page":"Library","title":"Green's function","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"greenfunction.jl\"]","category":"page"},{"location":"library/#LatticeModels.GreenFunction","page":"Library","title":"LatticeModels.GreenFunction","text":"GreenFunction\n\nA Green's function for a given lattice and Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.diagonalelements-Tuple{LatticeModels.GreenFunctionEval{<:System{<:LatticeModels.Sample{LT, Nothing} where LT}}}","page":"Library","title":"LatticeModels.diagonalelements","text":"diagonalelements(gf::GreenFunctionEval)\n\nReturn the diagonal elements of the Green's function as a LatticeValue.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.dos-Tuple{LatticeModels.AbstractEigensystem, Any}","page":"Library","title":"LatticeModels.dos","text":"dos(eig[, E; broaden])\ndos(gf[, E; broaden])\n\nCalculates the DOS (density of states) for a given eigensystem at energy E. If E is not specified, a function that calculates the DOS at a given energy is returned.\n\nArguments\n\neig is an Eigensystem or HamiltonianEigensystem.\ngf is a GreenFunction.\nE is the energy at which the DOS is calculated.\n\nKeyword arguments\n\nbroaden is the broadening factor for the energy levels, default is 0.1.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.greenfunction-Tuple{Any, Ket, Hamiltonian, Hamiltonian}","page":"Library","title":"LatticeModels.greenfunction","text":"greenfunction(psi0, hamp, hamm[; E₀, tol, kw...])\n\nCalculates the Green's function for a many-body system with a given initial state psi0.\n\nArguments\n\npsi0 is the initial state.\nhamp is the Hamiltonian for the subspace with one more particle than in psi0.\nhamm is the Hamiltonian for the subspace with one less particle than in psi0.\n\nKeyword arguments\n\nE₀ is the energy shift for the Green's function. Default is 0. Use E0 as a synonym   if Unicode input is not available.\ntol is the tolerance for the new eigenvectors. Default is 1e-5.\n\nAll other keyword arguments are passed to the diagonalize function. See its documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.greenfunction-Tuple{Any, LatticeModels.HamiltonianEigensystem{<:LatticeModels.OneParticleBasisSystem}}","page":"Library","title":"LatticeModels.greenfunction","text":"greenfunction(ham_eig::HamiltonianEigensystem)\n\nCreates a Green's function for a given one-body Hamiltonian eigensystem.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.ldos-Tuple{GreenFunction, Real}","page":"Library","title":"LatticeModels.ldos","text":"ldos(gf::GreenFunction, E[; broaden])\n\nCalculates the LDOS (local density of states) for a given Green's function at energy E. broaden is the broadening factor for the energy levels, default is 0.1.\n\n\n\n\n\n","category":"method"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"currents.jl\", \"zoo/currents.jl\"]\nFilter = t -> t ∉ (LatticeModels.AbstractCurrents, LatticeModels.AbstractTranslation)","category":"page"},{"location":"library/#LatticeModels.Currents","page":"Library","title":"LatticeModels.Currents","text":"Currents <: AbstractCurrents\n\nA AbstractCurrents instance that stores values for all currents explicitly.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Currents-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.Currents","text":"Currents(currents[, adjacency_matrix])\n\nCreates a Currents instance for currents.\n\nArguments\n\ncurrents: The AbstractCurrents object to be turned into Currents. That might be time-consuming,   because  this requires evaluation of the current between all pairs.\nadjacency_matrix: If provided, the current will be evaluated only between adjacent sites.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.DensityCurrents","page":"Library","title":"LatticeModels.DensityCurrents","text":"DensityCurrents <: AbstractCurrents\n\nDensity currents for given state and given hamiltonian.\n\n\n\nDensityCurrents(hamiltonian, state)\n\nConstructs a DensityCurrents object for given hamiltonian and state.\n\nArguments\n\nhamiltonian: A Hamiltonian object representing the Hamiltonian of the system.\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LocalOperatorCurrents","page":"Library","title":"LatticeModels.LocalOperatorCurrents","text":"LocalOperatorCurrents <: AbstractCurrents\n\nLocal operator (e. g. spin) currents for given state and given hamiltonian.\n\n\n\nLocalOperatorCurrents(hamiltonian, state, op)\n\nConstructs a DensityCurrents object for given hamiltonian and state.\n\nArguments\n\nhamiltonian: A Hamiltonian object representing the Hamiltonian of the system.\nstate: A Ket or Bra representing the wavefunction or an Operator representing the density matrix.\nop: A local (on-site) operator; either an Operator or a matrix of such.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SubCurrents","page":"Library","title":"LatticeModels.SubCurrents","text":"SubCurrents{CT<:AbstractCurrents} <: AbstractCurrents\n\nA lazy wrapper for a Currents object representing the same currents but on a smaller lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.currentsfrom-Tuple{LatticeModels.AbstractCurrents, Any}","page":"Library","title":"LatticeModels.currentsfrom","text":"currentsfrom(currents, src)\n\nCreate a LatticeValue object with the currents from src region to all other sites.\n\nArguments\n\ncurrents: The AbstractCurrents object to process.\nsrc: The source region. Can be a site/collection of sites or a LatticeValue{Bool} mask.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.currentsfromto","page":"Library","title":"LatticeModels.currentsfromto","text":"currentsfromto(currents, src[, dst])\n\nFinds the total current from src to dst regions. If dst is not provided, the current from src to all other sites is returned.\n\nArguments\n\ncurrents: The AbstractCurrents object to process.\nsrc: The source region.\ndst: The destination region.\n\nBoth src and dst can be a site/collection of sites or a LatticeValue{Bool} mask.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.lattice","text":"Gets the lattice where the given AbstractCurrents object is defined.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.mapgroup_currents-Tuple{Function, Function, LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.mapgroup_currents","text":"mapgroup_currents(f, group, currents[; sort=false, sortpairsby])\n\nFind the current between all possible pairs of sites, apply f to every site pair and group the result by value of f,\n\nArguments\n\nf: This function will be applied to all site pairs. Must accept two AbstractSites.\ngroup: This function will be used to group the current values for pairs with the same mapped value. Must accept a Vector of numbers.\ncurrents: The AbstractCurrents object to process.\n\nKeyword arguments\n\nsortresults: if true, the output arrays will be sorted by results of f.\nsortpairsby: if provided, the sites in each pair will be sorted by this function.   Must accept one AbstractSite; by default the order of the sites in the pair matches   their order in the lattice. The sign of the current will match the site order.\n\n\n\n\n\n","category":"method"},{"location":"library/#Evolution","page":"Library","title":"Evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages = [\"evolution.jl\", \"timesequence.jl\"]\nFilter = t -> t ∉ (LatticeModels.SchroedingerSolver,)","category":"page"},{"location":"library/#LatticeModels.CachedExp","page":"Library","title":"LatticeModels.CachedExp","text":"CachedExp(ham[; threshold=1e-10, nonzero_tol=1e-14])\n\nA SchroedingerSolver that finds the matrix exponential of the Hamiltonian and caches it. The matrix exponential is computed using a scaling and squaring method, so this solver works well with sparse or GPU arrays.\n\nArguments\n\nham: The Hamiltonian of the system. It can be an Operator or its matrix.\nthreshold: The threshold for the error in the matrix exponential.\nnonzero_tol: The tolerance for dropping small elements in the matrix exponential if it is   sparse.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.Evolution","page":"Library","title":"LatticeModels.Evolution","text":"Evolution([solver, ]hamiltonian, states...; timedomain, namedstates...)\n\nCreate an Evolution object that can be used to evolve states in time according to the Schroedinger equation.\n\nArguments\n\nsolver: A SchroedingerSolver object that will be used to evolve the states. If omitted,   a CachedExp solver will be created.\nhamiltonian: The Hamiltonian of the system. It can be a matrix, a time-dependent operator   or a function that returns the Hamiltonian at a given time.\nstates and namedstates: The states to be evolved. They can be Ket wavefunctions or   DataOperator density matrices.\ntimedomain: The time domain to be used for the evolution. If omitted, the non-iterable Evolution   object will be returned, and you will be able to call it with   the time domain later.\n\nSee SchroedingerSolver for more information about solvers.\n\nwarning: Warning\nPlease note that the Evolution object is a stateful iterator. This means that it keeps track of the current time and the states as they evolve. You can perform evolution multiple times, but the timeline will be kept and the states will be updated in place.Also do not edit the states in place, as this will affect the evolution. If you need to modify the states or save them, make a copy of them first.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.KrylovKitExp","page":"Library","title":"LatticeModels.KrylovKitExp","text":"KrylovKitExp(ham[; kw...])\n\nA SchroedingerSolver that uses the exponentiate function from KrylovKit.jl to evolve the wavefunction vectors. This solver is useful for large, sparse, time-dependent Hamiltonians.\n\nArguments\n\nham: The Hamiltonian of the system. It can be an Operator or its matrix.\nkw...: Keyword arguments to be passed to exponentiate.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}\n\nA time-ordered sequence of values.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(times, values)\n\nConstructs a TimeSequence with the given times and values.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Real, Any}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(value[; t=0])\n\nConstructs a TimeSequence with one single snapshot. The timestamp is zero by default but can be over riden.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Union{Tuple{}, Tuple{ET}} where ET","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}()\n\nConstructs an empty TimeSequence with eltype ET.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.differentiate!","text":"differentiate!(tseq::TimeSequence)\n\nDifferentiate the values stored in tseq by time using the symmetric difference formula. The new values are written into tseq.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.differentiate","text":"differentiate(tseq::TimeSequence)\n\nDifferentiate the values stored in tseq and create a copy; see differentiate!.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.integrate!","text":"integrate!(tseq::TimeSequence)\n\nIntegrate the values stored in tseq over time using the trapezoidal rule. The new values are written into tseq.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.integrate","text":"integrate(tseq::TimeSequence)\n\nIntegrate the values stored in tseq and create a copy; see integrate!.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timerange-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.timerange","text":"timerange(tseq::TimeSequence)\n\nReturns the range of the timestamps of the TimeSequence.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timestamps-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.timestamps","text":"timestamps(tseq::TimeSequence)\n\nReturns the timestamps of the TimeSequence.\n\n\n\n\n\n","category":"method"},{"location":"library/#Internals-2","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"LatticeModels.AbstractLattice\nLatticeModels.AbstractSite\nLatticeModels.AbstractBonds\nLatticeModels.DirectedBonds\nLatticeModels.AbstractTranslation\nLatticeModels.AbstractCurrents\nLatticeModels.LookupTable\nLatticeModels.SchroedingerSolver\nLatticeModels.addlookuptable","category":"page"},{"location":"library/#LatticeModels.AbstractLattice","page":"Library","title":"LatticeModels.AbstractLattice","text":"AbstractLattice{SiteT}\n\nAn abstract type for a lattice of SiteT sites.\n\nMethods for subtypes to implement\n\nlength(l::AbstractLattice): Return the number of sites in the lattice.\nsite_index(l::AbstractLattice, site::SiteT): Return the index of the site in the lattice.\ngetindex(l::AbstractLattice, i::Int): Return the site with the given index.\ngetindex(l::AbstractLattice, is::AbstractVector{Int}): Return an AbstractLattice with the sites at the given indices.\n\nOptional methods for mutable lattices\n\nemptymutable(l::AbstractLattice, ::Type{SiteT}): Return an empty mutable instance of lattice.\ncopymutable(l::AbstractLattice): Return a mutable copy of the lattice.\npush!(l::AbstractLattice, site::SiteT): Add a site to the lattice.\ndeleteat!(l::AbstractLattice, is::AbstractVector{Int}): Remove the sites with the given indices from the lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractSite","page":"Library","title":"LatticeModels.AbstractSite","text":"AbstractSite{N}\n\nAn abstract type for a site of a N-dimensional lattice.\n\nFields\n\ncoords: A SVector of size N representing the spatial coordinates of the site.   All subtypes are expected to have this field.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractBonds","page":"Library","title":"LatticeModels.AbstractBonds","text":"AbstractBonds{LT}\n\nAn abstract type for bonds on some lattice.\n\nMethods for subtypes to implement\n\nlattice(bonds::AbstractBonds): Returns the lattice where the bonds are defined.\nisadjacent(bonds::AbstractBonds, site1::AbstractSite, site2::AbstractSite):   Returns if the sites are connected by the bonds.\n\nOptional methods for subtypes to implement\n\nadapt_bonds(bonds::AbstractBonds, l::AbstractLattice)\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.DirectedBonds","page":"Library","title":"LatticeModels.DirectedBonds","text":"DirectedBonds{LT} <: AbstractBonds{LT}\n\nAn abstract type for bonds on some lattice that have a direction.\n\nMethods for subtypes to implement\n\nlattice(bonds::DirectionalBonds): Returns the lattice where the bonds are defined.\ndestinations(bonds::DirectionalBonds, site::AbstractSite): Returns the sites where the\n\nsite is connected to, accounting for the direction of the bonds.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractTranslation","page":"Library","title":"LatticeModels.AbstractTranslation","text":"AbstractTranslation{LT}\n\nAn abstract type for translations on some lattice.\n\nMethods for subtypes to implement\n\nlattice(bonds::AbstractTranslation): Returns the lattice where the translations are defined.\ndestination(bonds::AbstractTranslation, site::AbstractSite): Returns the site where the site is translated to.\n\nOptional methods for subtypes to implement\n\nadapt_bonds(bonds::AbstractTranslation, l::AbstractLattice):   Adapt the translation to the lattice l. The output can be a different type of   translation, more fitting for the concrete type of lattice.\ninv(bonds::AbstractTranslation): Returns the inverse of the translation, if any.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.AbstractCurrents","page":"Library","title":"LatticeModels.AbstractCurrents","text":"AbstractCurrents\n\nSupertype for all type representing currents-like values on a lattice. Subtypes must implement Base.getindex(::Int, ::Int) and lattice functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LookupTable","page":"Library","title":"LatticeModels.LookupTable","text":"LookupTable\n\nA helper data structure to quickly find the index of a site in a lattice.\n\nRelies on sitekey(site) and secondarykey(function) functions to determine the index of a site in the lattice.\n\nWorks well under following assumptions:\n\nThe sitekey is some integer property of the sites.\nThe sites in the lattice are ordered by sitekey.\nThe numbering is mostly contiguous, i.e. there are no (or few) gaps in the numbering.\nThe secondarykey is also integer, mostly contiguous, ordered and unique for all sites with the same sitekey.\n\nSet them to nothing to disable usage.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SchroedingerSolver","page":"Library","title":"LatticeModels.SchroedingerSolver","text":"SchroedingerSolver\n\nAbstract type for solvers that can be used to evolve states in time according to the Schroedinger equation.\n\nSee also concrete implementations: CachedExp, KrylovKitExp.\n\nMethods to implement\n\nupdate_solver!(solver, hamiltonian, dt, force=false): Update the solver to evolve the   states according to the given Hamiltonian and time step. If force is true, the   solver should always update, even if the Hamiltonian and time step are seemingly the   same as the previous ones.\nstep!(solver, state, cache): Evolve the given state in time using the solver. The cache   argument is used to store intermediate results and can be nothing if the solver does   not need it.\nevolution_cache(solver, state): Return a cache object that can be used to store   intermediate results for the given state. Returns nothing if the solver does not need   a cache for the given state (this is the default implementation).\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.addlookuptable","page":"Library","title":"LatticeModels.addlookuptable","text":"addlookuptable(lat)\n\nAdds a lookup table to the lattice lat and returns the lattice with the lookup table.\n\nwarning: Warning\nMake sure you add the lookup table to the lattice after you stop making changes to it. Otherwise the results may be unpredictable.This operation is not in-place.\n\n\n\n\n\n","category":"function"},{"location":"internals/","page":"Internals","title":"Internals","text":"This section contains the documentation for the internal structure of LatticeModels.jl. ","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"warning: Warning\nThis section of documentation is under construction. Some parts may be incomplete.","category":"page"},{"location":"internals/#Advanced-features","page":"Internals","title":"Advanced features","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"These features can be useful in non-trivial cases, but are not necessary for basic usage.","category":"page"},{"location":"internals/#AbstractLattice-interface","page":"Internals","title":"AbstractLattice interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The base of LatticeModels.jl is its interfaces, allowing to define lattices with arbitrary geometry, topology and boundary conditions. The LatticeModels.AbstractLattice interface is the main interface for defining lattices.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Generally speaking, a lattice is a set of sites. Each site, in turn, has its spatial coordinates in its coords field and maybe some additional properties. It also must be a subtype of LatticeModels.AbstractSite.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that the bonds between sites and the boundary conditions are initially not part of the lattice, but are added to its metadata later.","category":"page"},{"location":"internals/#Basic-functions","page":"Internals","title":"Basic functions","text":"","category":"section"},{"location":"internals/#Site-lookup","page":"Internals","title":"Site lookup","text":"","category":"section"},{"location":"internals/#Mutable-lattices","page":"Internals","title":"Mutable lattices","text":"","category":"section"},{"location":"internals/#Site-properties","page":"Internals","title":"Site properties","text":"","category":"section"},{"location":"internals/#Lattice-metadata","page":"Internals","title":"Lattice metadata","text":"","category":"section"},{"location":"internals/#Shapes","page":"Internals","title":"Shapes","text":"","category":"section"},{"location":"internals/#AbstractBonds-interface","page":"Internals","title":"AbstractBonds interface","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.AbstractBonds interface is used to define different types of bonds between sites. Most generally speaking, such object is a mapping that decides if the sites are connected for each pair.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Note that there are three basic types of bonds in LatticeModels.jl:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.AbstractBonds: a most general interface. Basically, it is just a mapping from site pairs to boolean values.\nLatticeModels.DirectedBonds: this type of bonds defines a set of bonds that has a defined direction. The whole topology can be defined by the \"destination\" sites for each site. Since the bonds are usually sparse, the general performance of this type of bonds is much higher.\nLatticeModels.AbstractTranslation: this is a subtype of DirectedBonds, where every site has one or zero \"destination\" sites. This allows to increase the performance even more, and also to transform the sites in a convenient manner:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"site1 = lat[!, x = 1, y = 1]    # Get the site at [1, 1]\nT = Translation(lat, [1, 0])    # Translate the site by [1, 0] vector\nsite2 = site1 + T               # `site2` is at [2, 1]","category":"page"},{"location":"internals/#Adapting-bonds-to-the-lattice","page":"Internals","title":"Adapting bonds to the lattice","text":"","category":"section"},{"location":"internals/#Boundary-conditions","page":"Internals","title":"Boundary conditions","text":"","category":"section"},{"location":"internals/#Diagonalizing-the-Hamiltonian","page":"Internals","title":"Diagonalizing the Hamiltonian","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"It is very easy to diagonalize a matrix in Julia. However, problems can arise when the matrix is of some custom type (e. g. sparse or a GPU array). By default LatticeModels.jl makes use of KrylovKit.jl to solve the eigenproblem using the Lanczos algorithm for non-trivial matrix types. However, sometimes it is necessary to use a different algorithm. The LatticeModels.diagonalize_routine is a simple way to add a new algorithm to the default toolchain.","category":"page"},{"location":"internals/#SchroedingerSolvers","page":"Internals","title":"SchroedingerSolvers","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.SchroedingerSolver interface is used to solve the time-dependent Schroedinger equation. It is used in the Evolution struct to perform unitary evolution. As with the diagonalization problem, one can add a new algorithm to the default toolchain by creating a new SchroedingerSolver type.","category":"page"},{"location":"internals/#Currents","page":"Internals","title":"Currents","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The LatticeModels.AbstractCurrents interface allows to define different types of currents on the lattice. This allows it to be a lazy object, which computes the currents only when needed.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To implement basic currents semantics, you need to define the following methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.lattice(your_currents): returns the lattice, on which the currents are defined.\nBase.getindex(your_currents, i::Int, j::Int): returns the current between sites with numbers i and j. This is done in such a manner, because you do not usually need the site properties to calculate the currents.","category":"page"},{"location":"manual/greenfunction/#Green's-function","page":"Green's function","title":"Green's function","text":"","category":"section"},{"location":"manual/greenfunction/#Introduction","page":"Green's function","title":"Introduction","text":"","category":"section"},{"location":"manual/greenfunction/#Many-body-Green's-function","page":"Green's function","title":"Many-body Green's function","text":"","category":"section"},{"location":"manual/greenfunction/#Density-of-states","page":"Green's function","title":"Density of states","text":"","category":"section"},{"location":"manual/hamiltonian/#System","page":"Constructing the Hamiltonian","title":"System","text":"","category":"section"},{"location":"manual/hamiltonian/","page":"Constructing the Hamiltonian","title":"Constructing the Hamiltonian","text":"This section describes how to define the quantum system that will be later worked on.","category":"page"},{"location":"manual/hamiltonian/#Systems","page":"Constructing the Hamiltonian","title":"Systems","text":"","category":"section"},{"location":"manual/hamiltonian/#The-Hamiltonian","page":"Constructing the Hamiltonian","title":"The Hamiltonian","text":"","category":"section"},{"location":"manual/hamiltonian/#The-constructor-function","page":"Constructing the Hamiltonian","title":"The constructor function","text":"","category":"section"},{"location":"manual/hamiltonian/#The-operator-builder","page":"Constructing the Hamiltonian","title":"The operator builder","text":"","category":"section"},{"location":"manual/hamiltonian/#Gauge-fields","page":"Constructing the Hamiltonian","title":"Gauge fields","text":"","category":"section"},{"location":"manual/latticevalue/#LatticeValue","page":"Working with data","title":"LatticeValue","text":"","category":"section"},{"location":"manual/latticevalue/#Basics","page":"Working with data","title":"Basics","text":"","category":"section"},{"location":"manual/latticevalue/#Common-Operations","page":"Working with data","title":"Common Operations","text":"","category":"section"},{"location":"manual/latticevalue/#Broadcasting","page":"Working with data","title":"Broadcasting","text":"","category":"section"},{"location":"manual/latticevalue/#Visualization","page":"Working with data","title":"Visualization","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Lowest-states-in-a-tight-binding-model","page":"Examples","title":"Lowest states in a tight-binding model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The tight-binding model Hamiltonian is defined by this formula (the sum is performed over adjacent sites):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hatH = sum_i j^textsites left( c^dagger_i c_j + h c right)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we take a square lattice and build a Hamiltonian for it. Then we find its eigenstates and plot their local density on heatmaps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\n# Generate a 40x40 square lattice\nl = SquareLattice(40, 40)\n# Define the tight-binding model Hamiltonian\nH = tightbinding_hamiltonian(l)\n\n# Calculate eigenvalues and eigenvectors\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], localdensity(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", st=:shape, \n        clims=clims, c=:inferno, cbar=:none, lw=0, framestyle=:none, xlab=\"\", ylab=\"\")\nend\n\n# The following lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, subplot=n^2+2, \n    background_subplot=:transparent, framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9))\nsavefig(\"local_density.png\")\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Currents-on-a-ring-shaped-sample","page":"Examples","title":"Currents on a ring-shaped sample","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we create a ring-shaped sample of a triangular lattice. Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\n\nl = TriangularLattice(Circle(10), !Circle(5))\nremovedangling!(l)\nh(B) = tightbinding_hamiltonian(l, field=PointFlux(B))\ndiag = diagonalize(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = densitymatrix(diag, mu = 0)\n# Perform unitary evolution\nτ = 10\na = Animation()\nev = Evolution(t -> h(0.1 * min(t, τ) / τ), P_0)\nfor state in ev(0:0.1:2τ)\n    P, H, t = state\n    # Find the density and plot it\n    p = plot(layout=2, size=(1000, 500))\n    plot!(p[1], localdensity(P), clims=(0, 1), st=:shape)\n\n    # Show currents on the plot\n    plot!(p[2], DensityCurrents(H, P), clims=(0, 0.005), lw=1, arrowheadsize=0.3)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"adiabatic_flux.gif\")","category":"page"},{"location":"examples/#Time-sequences","page":"Examples","title":"Time sequences","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we will see how to use TimeSequence to store and manipulate time-dependent data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will calculate the evolution of a ground state of a tight-binding model after a magnetic field is turned on. We will store the local density at each time step and use it to plot the local density depending on time, as well as its time derivative and integral over time.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels, Plots\n\nl = SquareLattice(20, 20)\nH = tightbinding_hamiltonian(l)\npsi_0 = groundstate(H)\nH1 = tightbinding_hamiltonian(l, field=LandauGauge(0.1))\nev = Evolution(H1, psi_0)\n\ndensities = TimeSequence{LatticeValue}()\nfor (psi, _, t) in ev(0:0.1:10)\n    densities[t] = localdensity(psi)\nend\n\nsite_bulk = l[!, x = 10, y = 10]\nsite_edge = l[!, x = 10, y = 1]\nds_bulk = densities[site_bulk]\nds_edge = densities[site_edge]\nplot(ds_bulk, label=\"ρ(t) (bulk)\")\nplot!(differentiate(ds_bulk), label=\"dρ(t)/dt (bulk)\")\nplot!(ds_edge, label=\"ρ(t) (edge)\")\nplot!(integrate(ds_edge), label=\"∫ρ(t)dt (edge)\")","category":"page"},{"location":"examples/#Hofstadter-butterfly","page":"Examples","title":"Hofstadter butterfly","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Hofstadter butterfly is a fractal-like structure that appears when the tight-binding model is subjected to a magnetic field. It is a plot of the energy spectrum as a function of the magnetic flux through the unit cell.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To create the Hofstadter butterfly, we will use the Landau gauge for the magnetic field. Note that we have to set periodic boundary conditions, and to make them compatible with the gauge field, they should be tweaked a little:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"psi(x + L_x y) = psi(x y) e^2pi i B y L_x\npsi(x y + L_y) = psi(x y)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let us plot the Hofstadter butterfiles for square, triangular and honeycomb lattices. The magnetic field field will be changed from zero to one phi_0 flux quantum per plaquette.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels, Plots\n\nfunction get_butterfly(l, lx, ly, plaquette_area)\n    xs = Float64[]\n    ys = Float64[]\n    area = lx * ly\n    dflux = 1 / area\n    totflux = 1 / plaquette_area\n    for B in 0:dflux:totflux\n        # magnetic boundary conditions\n        f(site) = exp(2pi * im * B * site.y * lx)\n        lb = setboundaries(l, [lx, 0] => f, [0, ly] => true)\n        H = tightbinding_hamiltonian(lb, field=LandauGauge(B))\n        dg = diagonalize(H)\n        append!(xs, fill(B, length(dg.values)))\n        append!(ys, dg.values)\n    end\n    return xs, ys\nend\n\np = plot(layout = @layout[a b; _ c{0.5w} _], size=(800, 500), leg=false,\n    xlabel=\"B\", ylabel=\"E\")\nscatter!(p[1], title=\"Square lattice\",\n    get_butterfly(SquareLattice(10, 10), 10, 10, 1), ms=1)\nscatter!(p[2], title=\"Triangluar lattice\",\n    get_butterfly(TriangularLattice(10, 10), 10, 5 * sqrt(3), sqrt(3) / 4), ms=1)\nscatter!(p[3], title=\"Honeycomb lattice\",\n    get_butterfly(HoneycombLattice(10, 10), 10, 5 * sqrt(3), sqrt(3) / 2), ms=1)\nsavefig(\"hofstadter_butterfly.png\")\nnothing # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#LDOS-animation","page":"Examples","title":"LDOS animation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Local density can be a bit ambiguous for degenerate eigenstates. That's where the LDOS (e. g. the Local Density of States) will be helpful.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The formula for the LDOS is the following:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"textLDOS_alpha(E) = textIm G_alphaalpha(E - idelta)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where G is the Green's function and delta is the broadening.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's create an animation presenting the DOS and LDOS for a square lattice with a hole indside. We will use the QWZ model hamiltonian, because it has a two-zone band structure, which will make the results more interesting. See qwz for more information about the QWZ model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeModels\nusing Plots\nl = SquareLattice(20, 20)\nl_center = l[j1 = 8..13, j2 = 8..13]\nsetdiff!(l, l_center)   # remove the center\nH = qwz(l)\n\ndg = diagonalize(H)\nδ = 0.1\nEs = -4:0.1:4\nEs_d = -4:0.01:4\nG = greenfunction(dg)\na = @animate for E in Es\n    print(\"\\rE = $E\") # hide\n    p = plot(layout=2, size=(800, 400))\n    plot!(p[1], Es_d, dos(G, broaden=δ), lab=\"\", title=\"DOS\")\n    vline!(p[1], [E], lab=\"\")\n    plot!(p[2], ldos(G, E, broaden=δ), st=:shape, \n        c=:inferno, clims=(0, NaN), title=\"LDOS\", lw=0)\n    plot!(p, plot_title=\"E = $E, δ = $δ\")\nend\n\ngif(a, \"ldos_animation.gif\", fps=10)","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paste the following line into the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/aryavorskiy/LatticeModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/aryavorskiy/LatticeModels.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Compat\nThis package has tested compatibility with Julia v1.6. Use with caution on lower versions.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry or boundary conditions.\nPowerful operator generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nManybody computations.\nSmart unitary evolution reducing excessive computations where possible.\nSupports visualization with Plots.jl.\nCompatible with QuantumOptics.jl.","category":"page"},{"location":"#Similar-packages","page":"Home","title":"Similar packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Packages such as Quantica.jl, pybinding and Kwant provide similar functionality. However, they are in general designed for other purposes and lack some features that are present in LatticeModels.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Schroedinger equation solvers with time-dependent Hamiltonians. Only Kwant provides similar    functionality with its Tkwant module, but it lacks the performance and flexibility in some cases.\nConvenient tools for setting periodic boundary conditions and gauge fields. The only way to do this in    Kwant or Pybinding is to manually set the hopping values.\nA flexible interface for defining new types of lattices and bonds. Random lattices can be implemented   on top of GenericLattice with ease.\nManybody computations. LatticeModels.jl can handle manybody systems with particle interaction.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Overall, while Kwant and pybinding are mostly focused on quantum transport problems and Quantica.jl is designed to find various properties of lattices, LatticeModels.jl focuses on dynamic simulations.","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This simple code plots local density for lowest energy states of a square tight-binding lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels, Plots\n\nl = SquareLattice(40, 40)\nH = tightbinding_hamiltonian(l)\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    # Plot local density on each subplot\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], localdensity(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", st=:shape, \n        clims=clims, c=:inferno, cbar=:none, lw=0, framestyle=:none, xlab=\"\", ylab=\"\")\nend\n\n# The following lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, subplot=n^2+2, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), background_subplot=:transparent)\nsavefig(\"example.png\")\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"See more examples in the Examples section.","category":"page"},{"location":"manual/operators/#States-and-Operators","page":"Operators","title":"States and Operators","text":"","category":"section"},{"location":"manual/operators/","page":"Operators","title":"Operators","text":"In this chapter we will learn how to create Hamiltonians and other operators.","category":"page"},{"location":"manual/operators/#Basic-operators","page":"Operators","title":"Basic operators","text":"","category":"section"},{"location":"manual/operators/#Measurements","page":"Operators","title":"Measurements","text":"","category":"section"},{"location":"manual/operators/#Diagonalizing","page":"Operators","title":"Diagonalizing","text":"","category":"section"}]
}

var documenterSearchIndex = {"docs":
[{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"danger: Outdated docs\nThis part of the documentation is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"tutorial/#Local-density-for-lowest-states-in-a-tight-binding-model","page":"Tutorial","title":"Local density for lowest states in a tight-binding model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tight-binding model hamiltonian is defined by this formula:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hatH = sum_i^textsites left( c^dagger_i + hatx c_i + c^dagger_i + haty c_i + h c right)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we will find its eigenstates and plot their local density on heatmaps.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\n# Generate a 40x40 square lattice\nl = SquareLattice(40, 40)\n# Define the tight-binding model hamiltonian\nH = tightbinding_hamiltonian(l)\n\n# Calculate eigenvalues and eigenvectors\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], lattice_density(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", clims=clims, cbar=:none)\nend\n\n# The following 2 lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, background_subplot=:transparent, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), subplot=n^2+2)","category":"page"},{"location":"tutorial/#Currents-in-a-tight-binding-model-on-a-ring-shaped-sample","page":"Tutorial","title":"Currents in a tight-binding model on a ring-shaped sample","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example we delete part of the sites in the middle of a square lattice.  Then we adiabatically turn on magnetic field through the hole and see currents emerge.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The tight-binding hamiltonian is the same as in the example above.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\n\nl = SquareLattice(10, 10) do (x, y)\n    !(4 < x < 7 && 4 < y < 7)\nend\nh(B) = tightbinding_hamiltonian(l, field=FluxField(B))\ndiag = diagonalize(h(0))\n\n# Find density matrix for filled bands (e. g. energy < 0)\nP_0 = densitymatrix(diag)\n# Perform unitary evolution\nτ = 10\na = Animation()\n@evolution {\n    H := h(0.1 * min(t, τ) / τ)\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    # Find the partial trace and plot it\n    plot(lattice_density(P), clims=(0,1))\n\n    # Show currents on the plot\n    plot!(DensityCurrents(H, P), arrows_scale=7, arrows_rtol=0.1)\n\n    title!(\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"tutorial/#Local-Chern-marker-with-hamiltonian-quench","page":"Tutorial","title":"Local Chern marker with hamiltonian quench","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Chern insulator hamiltonian is described by this formula:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hatH = \nsum_i^textsites m_i c^dagger_i sigma_z c_i + \nsum_i^textsites left( \nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + \nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i + \nh c right)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this experiment we create a filled state density matrix for a system with m_i = 1.  After that we change the m_i in the center of the lattice to -1 and start the evolution.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\n\nl = SquareLattice(11, 11)\nx, y = coord_values(l)\n\n# Initial hamiltonian: m=1 everywhere\nH1 = qwz(l, 1)\n\n# Quenched hamiltonian: m=-1 in the central 3x3 square\nM = ones(l)\nM[@. 4 < x < 8 && 4 < y < 8] .= -1\nH2 = qwz(M)\nX, Y = coord_operators(l, 2)\n\nsp = diagonalize(H1)\nP_0 = densitymatrix(sp)\n\nτ = 10\na = Animation()\n@evolution {\n    H := H2\n    P_0 --> H --> P\n} for t in 0:0.1:2τ\n    p = plot(layout=2, size=(900, 400))\n\n    # Local Chern marker heatmap\n    lcm_operator = 4pi * im * P * X * P * Y * P\n    chern_marker = lattice_density(lcm_operator)\n    plot!(p[1], chern_marker, clims=(-2, 2))\n\n    # Select sites on y=6 line\n    chern_marker_on_sw = chern_marker[y = 6]\n    # Mark selected sites on the heatmap\n    plot!(p[1], lattice(chern_marker_on_sw), high_contrast=true)\n    # Add a line plot\n    plot!(p[2], project(chern_marker_on_sw, :x), ylims=(-3, 3), lab=:none)\n\n    plot!(plot_title=\"t = $t\")\n    frame(a)\nend\n\ngif(a, \"animation.gif\")","category":"page"},{"location":"tutorial/#LDOS-animation","page":"Tutorial","title":"LDOS animation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Local density can be a bit ambiguous for degenerate eigenstates. That's where the LDOS (Refer to ldos documentation) will be helpful.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's take the same hamiltonian from the previous example and create a LDOS animation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using LatticeModels\nusing Plots\nl = SquareLattice(40, 40)\nH = qwz(l, 1)\n\ndg = diagonalize(H)\nδ = 0.1\nEs = -4:0.1:4\nEs_d = -4:0.01:4\nldosf = ldos(dg, δ)\na = @animate for E in Es\n    print(\"\\rE = $E\") # hide\n    p = plot(layout=2, size=(800, 400))\n    plot!(p[1], Es_d, dos(dg, δ), lab=\"\", title=\"DOS\")\n    vline!(p[1], [E], lab=\"\")\n    plot!(p[2], ldosf(E), clims=(0, NaN), title=\"LDOS\")\n    plot!(p, plot_title=\"E = $E, δ = $δ\")\nend\n\ngif(a, \"animation.gif\", fps=10)","category":"page"},{"location":"currents/#Usage","page":"Currents","title":"Usage","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents object is a lazy object that can calculate any current-like value between any pair of sites.  Usage is pretty simple:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"using LatticeModels, Plots","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"l = SquareLattice(10, 10)\nH = tightbinding_hamiltonian(l, field = FluxField(1, (5.5, 5.5)))\nP = densitymatrix(diagonalize(H), μ = -0.5)\n\ncurr = DensityCurrents(H, P)                    # Create Currents object\nheatmap(lattice_density(P))\nplot!(curr, arrows_scale=25, arrows_rtol=0.1, color=:blue)    # Quiver-plot the currents","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"What happened here? The formula for the density current from site i to site j is J_ij = texttr(-i hath_ij hatc^dagger_i hatc_j hatrho + h c) = 2 textIm tr(hath_ij hatc^dagger_i hatc_j hatrho).  The curr object contains this formula inside and when this object is passed to the plot function, all needed currents are evaluated.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"A current between each pair of sites is shown as an arrow directed from one to another with its length proportional to the strength of the current. The arrows_scale keyword argument scales all arrows by given factor, while arrows_rtol hides all arrows that are shorter than some fraction of the distance between the sites.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"You can display currents between certain sites by using a boolean-typed LatticeValue and bracket-notation:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"x, y = coord_values(l)\nsub_curr = curr[x .< y]\nplot!(sub_curr, arrows_scale=25, arrows_rtol=0.1, color=:green)","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Here all currents between sites in the upper-left coordinate triangle are marked green.","category":"page"},{"location":"currents/#Interface","page":"Currents","title":"Interface","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"It is quite likely that you might want to define your own type of currents. All you need to do is inherit the AbstractCurrents type and define two functions:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"lattice(::MyCurrents) must return the lattice which the currents are defined on\nBase.getindex(::MyCurrents, i::Int, j::Int) must return the current between sites with indices i and j. Note that the function must be skew-symmetric, e. g. curr[i, j] == -curr[j, i].","category":"page"},{"location":"currents/#Materialized-currents","page":"Currents","title":"Materialized currents","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"An AbstractCurrents is a lazy object. This allows to avoid excessive computation of site-to-site currents, but the computations that are needed will be repeated every time when we access that object; also abstract currents cannot be normally stored into a TimeSequence (more precisely, you won't be able to differentiate or integrate such currents over time). That's where the MaterializedCurrents come in, having all their values stored explicitly in an array.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"To convert any type of currents to MaterializedCurrents, simply use the materialize function. You can avoid evaluating some currents (for example, if you know beforehand that they must be zero) by passing a lambda as a first argument (or with do-syntax): it must take the Lattice and two LatticeSites and return whether the current between these sites must be evaluated.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"You can find it similar to the selector function we used back in Hopping operators, which indeed is. You may find the following selector functions useful:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Passing a PairSet produced by the bonds function will keep only the currents between adjacent sites.\npairs_by_distance will allow you to select pairs of sites depending on the distance between them. ","category":"page"},{"location":"currents/#Mapping-currents","page":"Currents","title":"Mapping currents","text":"","category":"section"},{"location":"currents/","page":"Currents","title":"Currents","text":"In some cases we want to find out how currents depend on some lattice properties: for example, the distance between sites. In such case, the map_currents function can be quite helpful.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"Let's find the mean and the standard deviation for currents between sites given the distance between them:","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"using LinearAlgebra, Statistics\n\ndist, adcurr = map_currents(\n    curr, \n    reduce_fn=(x -> [mean(abs.(x)), std(abs.(x))]),\n    sort=true\n) do l, site1, site2\n    norm(site1.coords - site2.coords)\nend\n\nacurr, dcurr = eachcol(adcurr)\nscatter(dist, acurr, err=dcurr, xlims=(0, 14))","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"What happened here? The map_currents function found the distance and the current between each pair of sites. Then for each distance between sites it found the mean and standard deviation for the absolute value of the currents in such pairs, and stored it column-wise in a matrix automatically. In the next line we extracted the mean and standard deviation into separate lists, and plotted the obtained data.","category":"page"},{"location":"currents/","page":"Currents","title":"Currents","text":"From this picture we can see that there are no density currents between non-adjacent sites, as one must have expected.","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"We will begin the tutorial by defining the quantum system we are working with. This package introduces several abstractions to describe various quantum lattices. Let us observe them.","category":"page"},{"location":"system/#Creating-a-lattice","page":"Defining the system","title":"Creating a lattice","text":"","category":"section"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"The Lattice type is the base type for defining Bravais lattices. A Bravais lattice is by definition one or more sites forming a unit cell translated periodically by a set of vectors. The default lattice geometry in this package is a Bravais lattice with finite number of translations. This type of lattices will be further referred to as a macrocell.","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"Let's take a look at an example:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"using LatticeModels, Plots\nl1 = SquareLattice(10, 5)                           # A 10x5 square lattice\nl2 = HoneycombLattice(10, 5)                        # A 10x5 honeycomb lattice macrocell\n\np = plot(layout=2, size=(800, 350))                 # Create a plot with 2 subplots\nplot!(p[1], l1, :pretty, title = \"Square lattice\")  # 'Pretty' lattice plot\nplot!(p[2], l2, title = \"Honeycomb lattice\")        # Simple lattice plot","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"The positional arguments in the lattice constructors stand for number of translations along every lattice axis. Note that SquareLattice(5, 5, 5) will generate a 5x5x5 3D lattice, but HoneycombLattice(5, 5, 5) will throw an error, because a honeycomb lattice is 2D by its definition.","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"To achieve less trivial lattice geometry, you can exclude some sites from the lattice:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"macrocell = SquareLattice(10, 10)\ncenter = macrocell[x = 5..6, y = 5..6]  # The four sites in the center\n\n# All basic set operations work with `Lattice`s (see also `union`, `intersect`)\nl = setdiff(macrocell, center) \nplot(l, :pretty)","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"Let's take a closer look at how we defined the center of the macrocell. x = 5..6, y = 5..6 means that all  sites of the macrocell with x-coordinate between 5 and 6 and y-coordinate also between 5 and 6 will get to the center. This syntax allows selecting sites based on a set of parameters using these kwargs-style accessors:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"x1, x2, x3 etc. stand for spatial coordinates. x, y, z are aliases for x1, x2, x3.\nj1, j2, j3 etc. stand for lattice axes, in other words - the unit cell indices.\nindex stands for number of the site in the unit cell.","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"Also note that instead of the 5..6 interval you can use any collection. Let's use all these techniques in one example:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"macrocell = HoneycombLattice(10, 10)\nl1 = macrocell[j1 = 1:2:9, j2 = 2:2:10, index = 1]\nl2 = macrocell[j1 = 2:2:10, j2 = 1:2:9, index = 2]\n\n# Firstly, let's plot the macrocell with translucent markers\nplot(macrocell, α = 0.3, lab = \"macrocell\")\n# Then plot our resulting lattice\nplot!(l1 ∪ l2, lab = \"our lattice\")","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"In some cases more complex lattice geometry is required. In such case we will need a different approach. But before that, let's get to know how lattice sites are treated within this package.","category":"page"},{"location":"system/#Lattice-sites","page":"Defining the system","title":"Lattice sites","text":"","category":"section"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"A LatticeSite is a struct describing where a site of some Lattice is located. It has three fields:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"unit_cell: the location of the unit cell containing the site\nindex: number of the site in the unit cell\ncoords: the spatial coordinates","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"You can consider a Lattice an array of LatticeSites: accessing a Lattice at an integer index or iterating over it  yields a LatticeSite. You can also obtain a site using the same kwargs-style accessors.","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"l = SquareLattice(5, 5)\nsite1 = l[7]            # Accessing a site by its number\nsite2 = l[x = 2, y = 2] # The same site by coordinates\nsite1 == site2          # true","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"tip: Tip\nPlot your lattice with the :pretty modifier to see the number of each site.","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"Now when you know about how LatticeSites work, the last example can be rewritten:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"l12 = HoneycombLattice(10, 10) do site\n    j1, j2 = site.unit_cell\n    if j1 % 2 == 1 && j2 % 2 == 0\n        return site.index == 1\n    elseif j1 % 2 == 0 && j2 % 2 == 1\n        return site.index == 2\n    else return false\n    end\nend\nplot(macrocell, α = 0.3, lab = \"macrocell\")\nplot!(l12, lab = \"our lattice\")","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"The function written using the do-syntax must return true if the site must be contained in the resulting lattice. This syntax is more powerful, because it allows writing arbitrary code in the function body, which might be crucial in non-trivial cases.","category":"page"},{"location":"system/#The-Sample","page":"Defining the system","title":"The Sample","text":"","category":"section"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"The Lattice does not contain full information about the physical system - it is just a set of sites.  Sometimes the system has additional degrees of freedom (for example, the spin of the particle). Sometimes it has non-trivial boundary conditions. We need a separate type to store this information.","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"That is where the Sample comes in. If the boundaries are open, the Sample can be constructed by simple tensor product:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"l = SquareLattice(10, 10)\nspin = SpinBasis(1//2)\ns = l ⊗ spin","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"Here spin is a QuantumOptics.Basis which describes the on-site phase state. It can be any other QuantumOptics.Basis -  this package is built on top of QuantumOpticsBase and is fully compatible with its type ecosystem.","category":"page"},{"location":"system/#Boundary-conditions","page":"Defining the system","title":"Boundary conditions","text":"","category":"section"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"All boundary conditions in this package are defined in terms of the macrocell: this means that if R_i are the vectors forming the supercell, boundary conditions can be defined in terms of psi(r) psi(r + R_i).  Three types of boundary conditions are supported:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"PeriodicBoundary(axis): simple condition psi(r + R_axis) = psi(r)\nTwistedBoundary(axis, Θ): condition psi(r + R_axis) = e^i theta psi(r)\nFunctionBoundary(f, axis): condition psi(r + R_axis) = f(r) cdot psi(r)","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"Each condition affects only one axis. To use several conditions at once, use BoundaryConditions:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"xbound = FunctionBoundary(1) do site\n    # This construct may be useful in presence of magnetic field\n    return exp(im * site.x) # Return the factor\nend\nybound = TwistedBoundary(2, -pi / 2)\nzbound = PeriodicBoundary(3)\nbc = BoundaryConditions(xbound, ybound, zbound)","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"You can use a shorthand notation for boundary conditions like this:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"f(site) = exp(im * site.x)\nbc2 = BoundaryConditions(1 => f, 2 => -pi / 2, 3 => true)","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"After all this, you can add the boundary conditions to the sample:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"s = Sample(l, spin, boundaries=bc)","category":"page"},{"location":"system/#The-System","page":"Defining the system","title":"The System","text":"","category":"section"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"The Sample contains no information about the particles - the quantity, the statistics etc. To do this, you need  to create a System. It is simple:","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"sys1 = System(s, N = 3, statistics = BoseEinstein)  # Three bosons on the sample `s`\nsys2 = System(s, statistics = FermiDirac, μ = 0)    # Non-interacting fermions with zero chemical potential","category":"page"},{"location":"system/","page":"Defining the system","title":"Defining the system","text":"tip: Tip\nMost functions in this package that create various operators accept a Sample or System as the first argument. You can avoid constructing it explicitly, because all these functions accept the lattice, internal basis and boundary conditions as separate arguments.The two function calls in this example will do the same thing:l = SquareLattice(10, 10)\nspin = Spin(1//2)\nbs = BoundaryConditions(1 => true, 2 => true)\nsys = System(l, spin, boundaries = bs, μ = 0, statistics = FermiDirac)\n\nH1 = tightbinding_hamiltonian(sys)\nH2 = tightbinding_hamiltonian(l, spin, boundaries = bs)","category":"page"},{"location":"library/#LatticeModels.jl","page":"Library","title":"LatticeModels.jl","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]","category":"page"},{"location":"library/#Lattice-system","page":"Library","title":"Lattice system","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"core/lattice.jl\", \"core/sample.jl\"]","category":"page"},{"location":"library/#LatticeModels.Lattice","page":"Library","title":"LatticeModels.Lattice","text":"Lattice{LatticeSym, N, NB}\n\nA finite subset of a Brvais{N, NB}. LatticeSym is a Symbol which represents the type of the lattice (e. g. :square, :honeycomb). This makes Lattice object behavior known at compile-time, which allows to introduce various optimizations or to define specific plot recipes.\n\n\n\nLattice(sym, sz, bvs[, mask])\n\nConstructs a finite Lattice{sym, N, NB} as a subset of the bvs Bravais lattice. sz is a NTuple{N, Int} which represents how many times the unit cell of bvs was translated by each axis - these sites form a macrocell. mask, if defined, is a Vector{Bool} storing information about which of the sites from the macrocell are actually included in the lattice, and which are not.\n\nFor example, a 3×3 square lattice with its center site excluded is represented as Lattice(:square, (3, 3), Bravais([1 0; 0 1]), Bool[1, 1, 1, 1, 0, 1, 1, 1, 1])\n\nTo define a new type of lattice, create an alias for Lattice{YourSym, YourN, YourNB}. Refer to the docs for detailed explanation.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.check_issublattice-Tuple{Lattice, Lattice}","page":"Library","title":"LatticeModels.check_issublattice","text":"Checks if l1 is sublattice of l2. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samelattice-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samelattice","text":"Checks if l1 and l2 objects are defined on one lattice. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.check_samemacrocell-Tuple{Any, Any}","page":"Library","title":"LatticeModels.check_samemacrocell","text":"Checks if l1 and l2 are defined on one macrocell. Throws an error if not.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.radius_vector-Union{Tuple{N}, Tuple{Lattice, LatticeModels.LatticeSite{N}, LatticeModels.LatticeSite{N}}} where N","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(l::Lattice, site1::LatticeSite, site2::LatticeSite) -> vector\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macrocell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_distance-Tuple{Lattice, LatticeModels.LatticeSite, LatticeModels.LatticeSite}","page":"Library","title":"LatticeModels.site_distance","text":"site_distance(l::Lattice, site1::LatticeSite, site2::LatticeSite[; pbc=false])\n\nReturns the distance between two sites on the l lattice.\n\nKeyword arguments:\n\npbc: if true, the boundary conditions will be considered periodic and\n\nthe distance will be measured on the shortest path.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_distance-Tuple{}","page":"Library","title":"LatticeModels.site_distance","text":"site_distance(; pbc)\n\nGenerates a function that finds the distance between sites (see site_distance(::Lattice, ::LatticeSite, ::LatticeSite)). This notation can be handy when passing this function as an argument.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.site_index-Tuple{Lattice, Union{LatticeModels.LatticePointer, LatticeModels.LatticeSite}}","page":"Library","title":"LatticeModels.site_index","text":"site_index(l::Lattice, site::LatticeSite; macrocell=false)\n\nReturns the integer index for given site in lattice. Returns nothing if the site is not present in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.sublattice-Union{Tuple{LatticeSym}, Tuple{Function, Lattice{LatticeSym}}} where LatticeSym","page":"Library","title":"LatticeModels.sublattice","text":"sublattice(lf::Function, l::Lattice) -> Lattice\n\nGenerates a a subset of lattice l by applying the lf function to its sites. The lf function must return a boolean value.\n\n\n\n\n\n","category":"method"},{"location":"library/#Lattice-values","page":"Library","title":"Lattice values","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"core/lattice_value.jl\"]","category":"page"},{"location":"library/#LatticeModels.LatticeValue","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue{T, LT}\n\nRepresents a value of type T on a Lattice{LatticeSym} lattice.\n\nFields:\n\nlattice: the Lattice object the value is defined on\nvalues: the values on different sites\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LatticeValue-Tuple{Lattice, AbstractVector}","page":"Library","title":"LatticeModels.LatticeValue","text":"LatticeValue(l::Lattice, v::AbstractVector)\n\nConstructs a LatticeValue object.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.coord_values-Tuple{Lattice}","page":"Library","title":"LatticeModels.coord_values","text":"coord_values(l::Lattice)\n\nGenerates a tuple of LatticeValues representing spatial coordinates.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.project-Tuple{LatticeValue, Any}","page":"Library","title":"LatticeModels.project","text":"project(lv::LatticeValue, axis)\n\nCreates a mapping from site coordinates to values of lv. The coordinate axis to project the sites onto can be set with the axis argument - it can be either an integer from 1 to 3 or an axis descriptor Symbol.\n\n\n\n\n\n","category":"method"},{"location":"library/#Bonds","page":"Library","title":"Bonds","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"core/bonds.jl\"]","category":"page"},{"location":"library/#LatticeModels.SiteOffset","page":"Library","title":"LatticeModels.SiteOffset","text":"SiteOffset{T, N}\n\nA struct representing bonds in some direction in a lattice.\n\n\n\nSiteOffset([site_indices, ]translate_uc)\n\nConstructs a SiteOffset object.\n\nArguments:\n\nsite_indices: a ::Int => ::Int pair with indices of sites connected by the bond.\n\nWhen not defined, the resulting bonds object will connect site with any basis index to a site with the same basis index, but in another unit cell.\n\ntranslate_uc: the unit cell offset.\n\nIf site_indices are equal or undefined and translate_uc is zero, the bond connects each site with itself. In this case an error will be thrown. Note that though the dimension count for the bond is static, it is automatically compatible to higher-dimensional lattices.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SiteOffset-2","page":"Library","title":"LatticeModels.SiteOffset","text":"SiteOffset(site_indices)\nSiteOffset([site_indices; ]axis[, dist=1])\n\nA convenient constructor for a SiteOffset object. site_indices is 1 => 1 by default.\n\nsite_indices is a ::Int => ::Int pair with indices of sites connected by the bond; 1 => 1 is the default value.\n\nKeyword arguments:\n\naxis: The hopping direction axis in terms of unit cell vectors.\ndist: The hopping distance in terms of\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.radius_vector-Tuple{Lattice, Bonds{<:Pair}}","page":"Library","title":"LatticeModels.radius_vector","text":"radius_vector(l::Lattice, hop::SiteOffset)\n\nFinds the vector between two sites on a lattice according to possibly periodic boundary conditions (site2 will be translated along the macrocell to minimize the distance between them).\n\n\n\n\n\n","category":"method"},{"location":"library/#Magnetic-fields","page":"Library","title":"Magnetic fields","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"field.jl\"]","category":"page"},{"location":"library/#LatticeModels.NoField","page":"Library","title":"LatticeModels.NoField","text":"NoField <: AbstractField\n\nA stub object representing zero magnetic field. Use it as a default magnetic field argument in functions - this will not cause any performance overhead.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.line_integral-Tuple{LatticeModels.AbstractField, Any, Any}","page":"Library","title":"LatticeModels.line_integral","text":"line_integral(field, p1, p2[, n_steps=1])\n\nCalculates the int_p1^p2 overrightarrowA cdot overrightarrowdl integral using the trapezoidal rule. Increase n_steps to improve accuracy (note that for linear fields like Landau or symmetrical calibrations the formula is already pefrectly accurate). If needed, redefine this function for specific field types - this is likely to boost accuracy and performance.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.vector_potential-Tuple{LatticeModels.AbstractField, Any}","page":"Library","title":"LatticeModels.vector_potential","text":"vector_potential(field, point)\n\nReturns vector potential overrightarrowA for field in location point.\n\nThis function should be defined for new field types, but it is not necessary unless you want to use built-in trapezoidal rule integrating.\n\n\n\n\n\n","category":"method"},{"location":"library/#Operators","page":"Library","title":"Operators","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"operators_core.jl\", \"operators_build.jl\", \"operators_manybody.jl\"]","category":"page"},{"location":"library/#Currents","page":"Library","title":"Currents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"currents.jl\"]","category":"page"},{"location":"library/#LatticeModels.AbstractCurrents","page":"Library","title":"LatticeModels.AbstractCurrents","text":"AbstractCurrents\n\nSupertype for all type representing currents-like values on a lattice. Subtypes must implement Base.getindex(::Int, ::Int) and lattice functions.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.MaterializedCurrents","page":"Library","title":"LatticeModels.MaterializedCurrents","text":"MaterializedCurrents <: AbstractCurrents\n\nA AbstractCurrents instance that stores values for all currents explicitly.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SubCurrents","page":"Library","title":"LatticeModels.SubCurrents","text":"SubCurrents{CT<:AbstractCurrents} <: AbstractCurrents\n\nA lazy wrapper for a Currents object representing the same currents but on a smaller lattice.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.lattice-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.lattice","text":"lattice(::AbstractCurrents)\n\nGets the lattice where the given AbstractCurrents object is defined.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.map_currents-Tuple{Function, LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.map_currents","text":"map_currents(map_fn, currs::AnstractCurrents[; reduce_fn, sort=false])\n\nAccepts a function that takes a Lattice and two LatticeSites and returns any value. Applies map_fn to every site pair and returns two Vectors: one with currents, one with results of map_fn.\n\nKeyword arguments:\n\nreduce_fn: if a function is provided, all currents with the same mapped value will be reduced into one value.\n\nFor example, if aggr_fn=(x -> mean(abs.(x))), and map_fn finds the distance between the sites, the returned lists will store the distance between sites and the average absolute current between sites with such distance.\n\nsort: if true, the output arrays will be sorted by mapped value.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.materialize-Tuple{LatticeModels.AbstractCurrents}","page":"Library","title":"LatticeModels.materialize","text":"materialize([function, ]currents)\n\nCreates a MaterializedCurrents instance for currents.\n\nIf function is provided, it must accept a Lattice and two LatticeSites and return if the current between this site must be calculated or not. This can be useful to avoid exsessive calculations.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.pairs_by_distance-Tuple{Any}","page":"Library","title":"LatticeModels.pairs_by_distance","text":"pairs_by_distance(f)\n\nA selector function used for hopping operator definition or currents materialization.\n\nTakes a function and generates a lambda which accepts a lattice and two LatticeSites, returning whether f applied to distance between the two sites returned true.\n\n\n\n\n\n","category":"method"},{"location":"library/#Unitary-evolution","page":"Library","title":"Unitary evolution","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"evolution.jl\"]","category":"page"},{"location":"library/#LatticeModels.evolution_operator!-Tuple{AbstractMatrix, AbstractMatrix, Real}","page":"Library","title":"LatticeModels.evolution_operator!","text":"evolution_operator(H, t)\n\nCalculates the unitary evolution operator using the formula\n\n$ \\mathcal{U}(t) = e^{-\\frac{1}{i\\hbar} \\hat{H} t} $\n\nArguments\n\nH: the hamiltonian matrix\nt: the evolution time\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.@evolution-Tuple","page":"Library","title":"LatticeModels.@evolution","text":"@evolution [kwargs...] {rules...} for_loop\n\nGenerates an environment with defined hamiltonian and density matrices that evolve by certain laws. See Unitary evolution for more details.\n\nKeyword arguments:\n\nk: order of the Taylor expansion for matrix exponent. If omitted, the default exp function will be used.\npade: set this to true to use Padé approximant formula instead of Taylor expansion.\nrtol: the relative tolerance to decide whether the Δt changed between iterations or not. 1e-12 by default.\nshow_progress: defines whether the progress informer must be displayed or not. true by default.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Time-sequences","page":"Library","title":"Time sequences","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"time_sequence.jl\"]","category":"page"},{"location":"library/#LatticeModels.TimeSequence","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence{ET}\n\nSeries of some data depending on time.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Any, AbstractVector}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(times, values)\n\nConstructs a TimeSequence with given timestamps and values.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.TimeSequence-Tuple{Real, Any}","page":"Library","title":"LatticeModels.TimeSequence","text":"TimeSequence(value; t=0)\n\nConstructs a TimeSequence with one single snapshot. The timestamp is zero by default but can be over riden.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.differentiate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.differentiate!","text":"differentiate!(ts::TimeSequence)\n\nDifferentiate the values stored in the TimeSequence object by time using the symmetric difference formula.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.integrate!-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.integrate!","text":"integrate(ts::TimeSequence)\n\nIntegrates the values stored in the TimeSequence object over time using the trapezoidal rule.\n\n\n\n\n\n","category":"method"},{"location":"library/#LatticeModels.timestamps-Tuple{TimeSequence}","page":"Library","title":"LatticeModels.timestamps","text":"timestamps(ts::TimeSequence)\n\nReturns the timestamps of the snapshots.\n\n\n\n\n\n","category":"method"},{"location":"library/#Model-zoo","page":"Library","title":"Model zoo","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [LatticeModels]\nPages   = [\"zoo.jl\"]","category":"page"},{"location":"library/#LatticeModels.DensityCurrents","page":"Library","title":"LatticeModels.DensityCurrents","text":"DensityCurrents <: AbstractCurrents\n\nDensity currents for given density matrix and given hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.FluxField","page":"Library","title":"LatticeModels.FluxField","text":"FluxField <: AbstractField\n\nAn object representing a small magnetic flux through given point. The field is directed along z-axis. Fields:\n\nB: The magnetic field value\npoint: A NTuple{2, Number} representing the point where the magnetic flux is located.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.HoneycombLattice","page":"Library","title":"LatticeModels.HoneycombLattice","text":"HoneycombLattice\n\nType alias for Lattice{:honeycomb,2,2}.\n\n\n\nHoneycombLattice(sz::Vararg{Int, 2})\n\nConstructs a honeycomb lattice with a sz-size macrocell.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.LandauField","page":"Library","title":"LatticeModels.LandauField","text":"LandauField <: AbstractField\n\nAn object representing Landau calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SquareLattice","page":"Library","title":"LatticeModels.SquareLattice","text":"SquareLattice{N}\n\nType alias for Lattice{:square,N,1}.\n\n\n\nSquareLattice(sz::Int...)\n\nConstructs a square lattice of size sz.\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.SymmetricField","page":"Library","title":"LatticeModels.SymmetricField","text":"SymmetricField <: AbstractField\n\nAn object representing symmetrically calibrated uniform magnetic field along z-axis. Fields:\n\nB: The magnetic field value\n\n\n\n\n\n","category":"type"},{"location":"library/#LatticeModels.haldane","page":"Library","title":"LatticeModels.haldane","text":"haldane(l::HoneycombLattice, t1::Real, t2::Real[, m::Real=0; field::AbstractField])\n\nhatH =\nsum_i^textsublattice A m c^dagger_i c_i +\nsum_j^textsublattice B m c^dagger_j c_j +\nsum_i j^textadjacent left( t_1 c^dagger_i c_j + h c right) +\nsum_i j^text2-connectedcounter-clockwise left( i cdot t_2 c^dagger_i c_j + h c right)\n\nGenerates a Haldane topological insulator hamiltonian operator.\n\n\n\n\n\n","category":"function"},{"location":"library/#LatticeModels.qwz-Tuple{LatticeValue}","page":"Library","title":"LatticeModels.qwz","text":"qwz([f, ]mv::LatticeValue[; field::AbstractField, pbc=false])\nqwz([f, ]l::SquareLattice[, m::Number=1; field::AbstractField, pbc=false])\n\nhatH =\nsum_i^textsites m_i c^dagger_i sigma_z c_i +\nsum_i^textsites left(\nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i +\nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i +\nh c right)\n\nGenerates a QWZ model hamiltonian operator with set magnetic field. If the m_i values are set by the mv::LatticeValue, which must be defined on a SquareLattice. Otherwise they will all be set to m.\n\nf here must be a function or a PairSelector describing which hoppings will be excluded.\n\n\n\n\n\n","category":"method"},{"location":"operators/","page":"Operators","title":"Operators","text":"In this chapter we will learn how to create Hamiltonians and other operators. There are several ways to do this in this package","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"from simple tightbinding_hamiltonians to the flexible build_operator function to OperatorBuilders.","category":"page"},{"location":"operators/#Simple-tight-binding-Hamiltonians","page":"Operators","title":"Simple tight-binding Hamiltonians","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"The simplest tight-binding Hamiltonian of possible is described by this formula:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"hatH = \nt sum_i j^textadjacent hatb^dagger_j hatb_i + \nt sum_i j^textsecond adjacent hatb^dagger_j hatb_i + \nt sum_i j^textthird adjacent hatb^dagger_j hatb_i + ldots","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Usually t is equal to 1, while all other factors are zero. Sometimes magnetic field is applied, in which case additional factors emerge according to Peierls substitution.  This adds frac2piphi_0 int_r_i^r_j overrightarrowA cdot overrightarrowdl phase to every hopping.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"To generate the Hamiltonian operator, use the tightbinding_hamiltonian function:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"l = SquareLattice(10, 10)\nH = tightbinding_hamiltonian(l)     # Yes, it is that simple\n# t1 stands for t, t2 - for t', etc.\nH2 = tightbinding_hamiltonian(l, t1 = 2, t2 = 1, t3 = 0)\n\ns = Sample(l, boundaries = BoundaryConditions(1 => true, 2 => true))\nH3 = tightbinding_hamiltonian(s)    # You can use a `Sample` or a `System` as well","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Applying magnetic field is a bit more complicated. You can use a pre-defined magnetic field from the library or define your own. In the latter case  you must provide the number of integration steps to calculate the phase in the Peierls substitution.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"# 0.1 flux quantum per 1x1 plaquette, Landau gauge\nH4 = tightbinding_hamiltonian(l, field=LandauField(0.1))\n\n# Define the very same magnetic field\nlandau_field = MagneticField(n = 100) do crd\n    x, y = crd\n    # The function must return the vector potential as a `Tuple`\n    return (0, 0.1 * x)\nend\nH5 = tightbinding_hamiltonian(l, field=landau_field)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"The pre-defined magnetic field types include:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"LandauField(B::Real) - Landau gauge uniform magnetic field\nSymmetricField(B::Real) - symmetric gauge uniform magnetic field\nFluxField(Φ::Real, point::Tuple{Number, Number}) - point magnetic field flux through point.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Note that using a user-defined MagneticField will most probably result in slower operator generation. See Custom magnetic fields for more info.","category":"page"},{"location":"operators/#Other-basic-operators","page":"Operators","title":"Other basic operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"To create spatial coordinate operators, use the coord_operators function. If you want one specific coordinate operator, use coord_operator. These functions accept a Sample as first argument.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"X = coord_operator(s, :x)   # X spatial coordinate operator\nJ1 = coord_operator(s, :j1) # Unit cell coordinate operator\nX, Y = coord_operators(s)   # Shorthand for generating both coordinate operators\nX, Y = coord_operators(l)   # Also accepts a `Lattice` and optional internal basis","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"If more fine-grained control over the hoppings is required, you can make use of transition operators:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"site1 = l[x = 2, y = 3]\nsite2 = l[x = 3, y = 2]\nt12 = transition(s, site1, site2)\nt34 = transition(s, 3, 4)           # 3 and 4 are integer indices of sites\nH6 = H3 + t12 + t12' + t34 + t34'","category":"page"},{"location":"operators/#Builder-function","page":"Operators","title":"Builder function","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"The build_hamiltonian function allows to created a complicated hamiltonian in one function call. Let's get to know how it works.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Like tightbinding_hamiltonian, this function accepts a System (and all following default behavior) as first positional argument  and magnetic field via field keyword. All other positional arguments describe different terms of the resulting hamiltonian. Each term is a A => B pair, where A describes an operator acting on the internal space, and B acts on the lattice space. The term is thus a tensor product of these operators.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Let's take a look at an example. We want to add spin-orbital interaction to our Hamiltonian. One way is to use the QWZ model, whose Hamiltonian like this:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"hatH = \nsum_i^textsites m_i c^dagger_i sigma_z c_i + \nsum_i^textsites left( \nc^dagger_i + hatx fracsigma_z - i sigma_x2 c_i + \nc^dagger_i + haty fracsigma_z - i sigma_y2 c_i + \nh c right)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"And this is how we can write a function that creates a hamiltonian in such a model.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"using LatticeModels","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"const σ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\n\nqwzmodel(m::LatticeValue{<:Number, <:SquareLattice}; field=NoField()) = \nbuild_hamiltonian(lattice(m), SpinBasis(1//2), field=field,\n    σ[3] => m,\n    (σ[3] - im * σ[1]) / 2 => Bonds(axis = 1),\n    (σ[3] - im * σ[2]) / 2 => Bonds(axis = 2))\nnothing # hide","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Let's explain what happens here line-by-line.  Firstly, the parameter m is a LatticeValue - a struct which contains some value defined on the lattice's sites. This is a very powerful tool, but all that we need now is that LatticeValue{<:Number, <:SquareLattice} stores numeric values on a square lattice. We use implicit Sample construction here by passing the lattice m is defined on and a SpinBasis(1//2) (one half spin, obviously) as the internal  dergee of freedom.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"The σ[3] => m line describes the sum_i^textsites m_i c^dagger_i sigma_z c_i term. m_i values are defined by the LatticeValue provided.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"The next two lines describe the hopping terms in x- and y-direction. Take a closer look: (σ[3] - im * σ[1]) / 2 on the left-hand side of the pair  is the fracsigma_z - i sigma_x2 operator acting on the spin of the particle. And Bonds(axis = 1) can be read as \"hop from site to its neighbor along lattice axis #1\". In context of a square lattice it is the same as the x coordinate axis.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"We can use this function to find the ground state density matrix and plot the local Chern marker. Here we will also showcase  part of the functionality LatticeValues provide, see more in Processing results.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"l = SquareLattice(10, 10)\nm = ones(l)         # m_i will be equal to one everywhere...\nm[x = 4..7] .= -1   # Except this ribbon\nH = qwzmodel(m)\n\nX, Y = coord_operators(l, SpinBasis(1//2))  # Coordinate operators\nP = densitymatrix(H)                        # Density matrix\nC = 4pi * im * P * X * P * Y * P\nlcm = lattice_density(C)                    # Local Chern marker\n\nusing Plots\nplot(lcm)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"note: Note\nbuild_operator is actually the same function as build_hamiltonian, but its output is an Operator rather than a Hamiltonian.  The only difference is that a Hamiltonian stores information about the System it is defined on. It is used to build a density matrix in a more convenient way. ","category":"page"},{"location":"operators/#The-OperatorBuilder","page":"Operators","title":"The OperatorBuilder","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"info: Docs under construction\nThis manual page is not written yet. I'm working on that. You can watch a video on YouTube meanwhile.","category":"page"},{"location":"operators/#Diagonalizing-operators","page":"Operators","title":"Diagonalizing operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"danger: Outdated docs\nAll information below is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"A Eigensystem object contains eigenvalues and eigenvectors of some hermitian operator. ","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"It is a very convenient way to work with eigenvectors. Check this out:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"dg = diagonalize(tightbinding_hamiltonian(SquareLattice(5, 5)))\ndg[1]       # Get the first eigenstate (e. g. the state with lowest energy)\ndg[3]       # Get the third eigenstate\ndg[value = 0]   # Get eigenstate with energy nearest to 0\ndg[1:3]     # Create a new Eigensystem with states from #1 to #3\nE = dg.values   # Get eigenvalues\ndiag_filled = dg[E .< 0]    # Create a new Eigensystem with filled bands only","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"You can use densitymatrix or projector (only in zero-temperature cases) functions to find a density matrix of a system.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"P = projector(E -> E < 0, dg)\nP = projector(diag_filled)              # The same thing\nP = densitymatrix(dg, μ = 0, T = 0)     # The same thing\nP = densitymatrix(dg)                   # The same thing","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"warning: Warning\nThe diagonalize function finds the eigenvalues and eigenvectors using LinearAlgebra.eigen. You will probably have to define it for array types that do not support default LinearAlgebra routines.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"One more thing you can do with Eigensystems is finding the density of states (DOS) and the local density of states (LDOS).  The DOS is the imaginary part of texttrleft(frac1hatH - E - ideltaright) operator, whereas the LDOS is its partial trace.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"It's highly recommended to use the built-in dos and ldos functions, because the Eigensystem object stores the hatH operator already diagonalized, which makes calculations much faster.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"using Plots\n\np = plot(layout=@layout[_ a{0.5w} _; grid(1, 2)], size=(800, 800))\nplot!(p[1], -4:0.1:4, dos(sp, 0.2), title=\"DOS with δ = 0.2\")\nplot!(p[2], ldos(sp, 1, 0.2), title=\"LDOS at E = 1 with δ = 0.2\")\n\n# These two lines produce exactly the same result as the previous\nldos_fun = ldos(sp, 0.2)\nplot!(p[3], ldos_fun(1), title=\"LDOS at E = 1 with δ = 0.2 (via function)\")","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"tip: Tip\nIf you want to find the LDOS for the same spectrum and delta, but for many different energy values, consider using ldos(spectrum, delta): it improves performance dramatically.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"danger: Outdated docs\nThis part of the documentation is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"We often  want to study the behavior of some quantum system in time-dependent conditions. We can use the unitary evolution operator to describe how the density matrix depends on time:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"mathcalU(t) = Tleft e^frac1ihbar int_t_0^t hatH(tau) dtau righthspace05cm\nmathcalP(t) = mathcalU(t) mathcalP_0 mathcalU^dagger (t)","category":"page"},{"location":"evolution/#The-evolution-macro","page":"Unitary evolution","title":"The evolution macro","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro can be quite useful if your hamiltonian depends on time or if there are multiple Hamiltonians in your experiment. It avoids excessive computation in several cases automatically:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian does not change, the mathcalU(t dt) operator will not be re-evaluated.\nIf several wavefunctions or density matrices evolve using the same hamiltonian, neither the hamiltonian nor the evolution operator matrix will be re-evaluated.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us define a function that generates a Chern insulator hamiltonian:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"using LatticeModels, Plots\nσ = [[0 1; 1 0], [0 -im; im 0], [1 0; 0 -1]]\nChern(l, B) = @hamiltonian begin\n    lattice := l\n    field := LandauField(B)\n    dims_internal := 2\n    @diag σ[3]\n    @hop axis=1 (σ[3] - im * σ[1]) / 2\n    @hop axis=2 (σ[3] - im * σ[2]) / 2\nend\nnothing # hide","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The @evolution macro creates a scope where the hamiltonian and wavefunctions (or density matrices) are evaluated for the given time interval.  It takes two arguments: a braced list with evolution specifiers and a for-loop that iterates over the time interval:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"l = SquareLattice(10, 10)\nτ = 30\na = Animation()\nB = 0.01\nP0 = densitymatrix(diagonalize(qwz(l, 0)))\n\n@evolution {\n    H := Chern(l, B * min(t, τ) / τ),\n    P0 --> H --> P\n} for t in 0:0.1:2τ\n    cur = DensityCurrents(H, P)\n    heatmap(lattice_density(P), title=\"Local density, t = $t\", clims=(0.9, 1.1))\n    plot!(cur, arrows_scale=20, color=:blue)\n    frame(a)\nend\ngif(a, \"animation.gif\")","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let us make it clear what an evolution specifier is. In fact, there are two possible variants:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"It is an evolution rule describing the initial state, the hamiltonian it will evolve accroding to, and the name of the variable to write the result. These three arguments must be written in a chain delimited by --> like this: \nP0 --> Chern(l, B * min(t, τ) / τ) --> P\nNote that you can use a hamiltonian alias instead of an expression if it was previously defined.\nIt is an alias declaration, which means that a certain expression will be evaluated on every iteration and assigned to a variable with a given name. For example, H := Chern(l, B * min(t, τ) / τ) evaluates the Chern insulator hamiltonian and writes the result to the H variable.","category":"page"},{"location":"evolution/#Compatibility","page":"Unitary evolution","title":"Compatibility","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"This macro is designed to be compatible with arbitrary array types. This means that hamiltonian expressions or initial states needn't to be LatticeArrays, but they can be of any array type instead, as long as it supports linear algebra operations such as matrix multiplication.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here are the functions that must be defined for the desired array type:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Equality operator: ==\nBasic arithmetic functions: +, -, *, adjoint\nThe identity matrix one(A)\nThe matrix exponent exp(A)\nIf it is not possible to implement this function you can set the k keyword argument (see below) to calculate the matrix exponent as a partial sum of Taylor series.\nIf the inverse matrix inv(A) function is defined, you can use the Padé approximant for the matrix exponent, which is generally more accurate.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"warning: Warning\nIf you use LatticeArrays, you still have to make sure these functions and operators are defined for the underlying array type.","category":"page"},{"location":"evolution/#Performance","page":"Unitary evolution","title":"Performance","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"The evolution macro avoids calculations where possible to improve performance. It is important to know how it achieves this result:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"If the hamiltonian matrix has not changed between two iterations and the time step remained approximately the same, mathcalU(t dt) will not be re-evaluated, because the matrix exponent is the most time-consuming operation compared to others like matrix multiplication or addition.\nThe relative tolerance used to check if the time step has changed can be set via rtol keyword.\nIf the hamiltonian expression does not explicitly depend on the loop variable (t in the example), it will be considered constant and evaluated only once at the beginning. Otherwise it will be evaluated on every iteration in the loop scope.\nIf several states evolve according to the same hamiltonian, both the hamiltonian and the mathcalU(t dt) evolution operator will be evaluated only once per iteration.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"To improve performance with small time intervals you can calculate the matrix exponent as a Taylor polynomial. Its order can be set via k keyword.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"For more precise calculation add pade=true - this will enable matrix exponent calculation via Padé approximant. Note that this formula requires finding an inverse matrix, so this option is not compatible with sparse matrices.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"By default the macro shows a progress informer that shows the task progress, the estimated time remaining and the fraction of time that was spent to perform evolution. To disable it add show_progress=false to the keyword arguments.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Keyword assignments should be placed before the rules list:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"@evolution k=2 rtol=1e-6 show_progress=false {...} for t in ...","category":"page"},{"location":"evolution/#Time-sequences","page":"Unitary evolution","title":"Time sequences","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"A TimeSequence is a struct that stores information about how some value changed during time. It simplifies working with time-dependent values by allowing you to run the computation pass only once and re-evaluate all processing and visualization code as much as you want.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Here is an example:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"P0 = densitymatrix(diagonalize(qwz(l)))\ndensity_rec = TimeSequence()\nderiv_rec = TimeSequence()\n\n@evolution {\n    H := Chern(l, B * min(t, τ) / τ),\n    P0 --> H --> P\n} for t in 0:0.1:2τ\n    insert!(density_rec, t, lattice_density(P))\n    insert!(deriv_rec, t, lattice_density(-im * (H * P - P * H)))\nend\n\nsite = l[50]\np = plot(layout=(2,1))\nplot!(p[1], density_rec[site], lab=\"p\")\n\n# Compare computed time derivative with Heisenberg equation\nplot!(p[2], differentiate(density_rec[site]), lw=5, alpha=0.3, lab=\"dp/dt\")\nplot!(p[2], deriv_rec[site], lab=\"Heisenberg\")","category":"page"},{"location":"evolution/#Indexing-and-iteration","page":"Unitary evolution","title":"Indexing and iteration","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"TimeSequences support two kinds of indexing:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Calling the record with a numeric value selects the time and returns the object in nearest snapshot.  Calling it with two numeric values yields a new TimeSequence with all timestamps between given values.\nIndexing it with square brackets will apply this index to all snapshots. The output will also be a TimeSequence.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Let's see how it works:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"p = plot(layout=(1,3), size=(800, 250))\nplot!(p[1], density_rec(10))                        # The snapshot with time nearest to 10\ntypeof(density_rec(10))                             # LatticeValue{Float64}\nplot!(p[2], density_rec[l[25]])                     # The value on the 25-th site depending on time \ntypeof(density_rec[l[25]])                          # Dict{Float64, Float64}\nplot!(p[3], (density_rec(15, 25) |> diff)[l[25]])   # Derivative of the value by time where 15 ≤ t ≤ 25","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Note that TimeSequence impements the AbstractDict and therefore is iterable. The iterator yields timestamp => value pairs:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"for (t, P) in density_rec\n    # Do what you need with t, P\nend","category":"page"},{"location":"evolution/#Differentiation-and-integration","page":"Unitary evolution","title":"Differentiation and integration","text":"","category":"section"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"You can also automatically differentiate and integrate the TimeSequence with differentiate and integrate functions (or their in-place alternatives differentiate! and integrate!). However, the type of the stored values must implement the following methods:","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Base.copy: the non in-place methods simply call their in-place versions on a copy of the original TimeSequence.\nBase.zero: this function will be called before integrating.\nLinearAlgebra.axpby! to implement basic in-place math.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"Still, types in this library (LatticeValue, LatticeArray, MaterializedCurrents), numbers and arrays are compatible with differentiation and integration out of the box.","category":"page"},{"location":"evolution/","page":"Unitary evolution","title":"Unitary evolution","text":"warning: Warning\nIntegrating or differentiating may produce unexpected results or crash if applied to a TimeSequence with elements of different type or defined on a different Lattice/Basis. Lattice or basis match is not checked when constructing a TimeSequence!","category":"page"},{"location":"#LatticeModels.jl","page":"Home","title":"LatticeModels.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides a set of tools to simulate different quantum lattice systems.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paste the following line into the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/aryavorskiy/LatticeModels.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"or","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(url=\"https://github.com/aryavorskiy/LatticeModels.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Compat\nThis package has tested compatibility with Julia v1.6. Use with caution on lower versions.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bravais lattices with arbitrary geometry or boundary conditions.\nPowerful operator generation tools.\nBackend-independent computations: linear operators can be of any array type, allowing to use sparse or GPU arrays when needed.\nSmart unitary evolution macro reducing excessive computations where possible.\nSupports visualization via Plots.jl.\nCompatible with QuantumOptics.jl.","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This simple code plots density heatmaps for lowest energy states of a square tight-binding lattice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LatticeModels, Plots\n\nl = SquareLattice(40, 40)\nH = tightbinding_hamiltonian(l)\ndiag = diagonalize(H)\n\nn = 5\nclims = (0, 0.0045)\np = plot(layout = @layout[ grid(n, n) a{0.1w}], size=(1000, 850))\nfor i in 1:n^2\n    # Plot a density heatmap on each subplot\n    E_rounded = round(diag.values[i], sigdigits=4)\n    plot!(p[i], lattice_density(diag[i]), title=\"\\$E_{$i} = $E_rounded\\$\", clims=clims, cbar=:none)\nend\n\n# The following 2 lines are kinda hacky; they draw one colorbar for all heatmaps\nplot!(p[n^2+1], framestyle=:none)\nscatter!([NaN], zcolor=[NaN], clims=clims, leg=:none, cbar=:right, background_subplot=:transparent, \n    framestyle=:none, inset=bbox(0.0, 0.05, 0.95, 0.9), subplot=n^2+2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See more examples in the Tutorial section.","category":"page"},{"location":"internals/#Custom-lattice-types","page":"Internals","title":"Custom lattice types","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"It is quite likely that you will need more types of lattices than this package provides by default. In such cases you need to define a new type. Follow these steps:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Create an exact alias","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Select a Symbol that will be the LatticeSym for this type and define an alias for the Lattice{LatticeSym, N, NB} type. The alias must not have any type parameters except for the dimension count if needed:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"const HoneycombLattice = Lattice{:honeycomb, 2, 2}\nconst SquareLattice{N} = Lattice{:square, N, 1}","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Define the constructor","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The only positional arguments allowed are the macrocell size.[1] The Bravais object must be generated in the constructor and passed to the default constructor Lattice(sym, sz, bvs).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"[1]: This is done with purpose to achieve code consistency. Also in-place sublattice generation will almost certainly be broken. Use keyword arguments if you need additional parameters for some lattice type.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Let us define our own lattice type:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"const GrapheneLattice = Lattice{:graphene, 3, 2}\nfunction GrapheneLattice(sz::Vararg{Int, 3})\n    bvs = Bravais([1 1/2 0; 0 √3/2 0; 0 0 2], [0 1/2; 0 √3/6; 0 0])\n    Lattice(:graphene, sz, bvs)\nend\nnothing # hide","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"A sublattice constructor will be generated by default:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"gl = GrapheneLattice(6, 6, 3) do (x, y, z)\n    7 < x * √3 + y < 18\nend\nplot(gl, pretty=false)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"warning: Warning\nPlease note that if the type alias is dimension-parametric, you must define the constructor for a concrete type, otherwise you will almost definitely break the lattice constructor dispatch:SquareLattice(sz::Vararg{Int, N}) where N = ...     # Wrong!\nSquareLattice{N}(sz::Vararg{Int, N}) where N = ...  # CorrectIn the second example SquareLattice(sz::Vararg{Int, N}) where N constructor will be generated automatically.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"danger: Outdated docs\nAll information below is outdated and does not refer to the current functionality of the package.","category":"page"},{"location":"internals/#AbstractGraph-API","page":"Internals","title":"AbstractGraph API","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"A AbstractGraph, as described in the Pair selectors paragraph, is a lambda-like object.  Actually, everything that differs is a built-in sanity check algorithm ensuring that the lattice it is used on is a subset of the lattice it was defined on.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"To implement this interface, you must inherit the LatticeModels.AbstractGraph class and define two methods:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"LatticeModels.lattice(::YourSelector) must return the lattice your selector was defined on.\nLatticeModels.match(::YourSelector, site1::LatticeSite, site2::LatticeSite) must return whether the (site1, site2) pair is selected.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Let's take a look at the built-in DomainsSelector:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct DomainsSelector <: LatticeModels.AbstractAbstractGraph\n    domains::LatticeValue\nend\nLatticeModels.lattice(ps::DomainsSelector) = lattice(ps.domains)\nLatticeModels.match(ps::DomainsSelector, site1::LatticeSite, site2::LatticeSite) =\n    ps.domains[site1] == ps.domains[site2]","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"It's quite likely though that the built-in AbstractGraphs will cover all your needs:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"DomainsSelector can split your lattice into different domains: pass a LatticeValue and the pair will be selected only if the values on both sites match.\nPairLhsGraph takes a boolean-typed LatticeValue and selects a site pair only if the value on the first site of the pair is true. Can be useful for creating a slit in the lattice sample.\nPairRhsGraph is the same as previous, but selects pairs by the second site of the pair.\nPairSet is an arbitrary set of site pairs - you can generate one by yourself or use the bonds function.\nYou may also find the pairs_by_distance function useful: it is not a AbstractGraph because it is lattice-independent, but you may find it convenient if you want to select site pairs depending on the distance between the sites in the pair.","category":"page"},{"location":"internals/#Custom-magnetic-fields","page":"Internals","title":"Custom magnetic fields","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"You can induce magnetic field by setting the vector potential overrightarrowA in every point of the space. This can be done by creating an AbstractField object: this is a lazy object that stores information about the magnetic field and implements the LatticeModels.vector_potential function that calculates the above-mentioned vector potential.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The int_r_1^r_2 overrightarrowA cdot overrightarrowdl integral is found automatically with the LatticeModels.line_integral function. The number of steps can be adjusted, but it is recommended to redefine this method for each new magnetic field type using an exact formula: this will improve performance and accuracy in most cases.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"You can use a convenience macro to simplify definition of new field types:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"@field_def struct LandauField(B::Number=1)\n    # Define the vector potential function\n    vector_potential(x) = (0, x*B)\n\n    # Redefine the integrating function\n    line_integral(p1, p2) = ((p1[1] + p2[1]) / 2) * (p2[2] - p1[2]) * B\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Let's see what happened here.  This macro created a new struct LandauField <: AbstractField with only one field B::Number and a constructor LandauField(B::Number=1).","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"It also defined a suitable LatticeModels.vector_potential function. The only parameter in this function definition is x, which will be the X coordinate of the point (all other coordinate values will not be passed).  The return type must be Tuple or SVector to ensure that it can be converted to SVector by the default LatticeModels.line_integral implementation.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This field object is compatible with lattices of any dimension count. Undefined elements of the overrightarrowA vector will be set to zero, and \"excessive\" ones will be discarded.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"tip: Tip\nTo handle dimension-dependent behavior, you can use vector_potential(p...) = (0, p[1]*B) notation. Here p is a SVector which will allow you to yield different values depending on the dimension count.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"You may notice that here the LatticeModels.line_integral function was also redefined. It simply takes two SVectors describing the coordinates of p_1 and p_2 and returns the value of the int_p_1^p_2 overrightarrowA cdot overrightarrowdl path integral between them.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"tip: Tip\nTo control the accuracy and performance of the integration without redefining LatticeModels.line_integral,  set the default number of integration steps by adding n_steps := <desired number> to the struct definition.","category":"page"},{"location":"internals/#Custom-array-backends","page":"Internals","title":"Custom array backends","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"You can freely change the type of underlying arrays in LatticeArrays by using the @on_lattice macro. It will convert the internal array to the desired type and wrap it with the same Basis:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"using LatticeModels # hide\nX, Y = coord_operators(SquareLattice(50, 50), 2)\nXY = X * Y\nusing SparseArrays\nsp_XY = @on_lattice sparse(XY)","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"In this example the @on_lattice macro transformed the call to sparse so that the internal array was passed to it,  and its output was wrapped into a LatticeArray. Thus, sp_XY here is an operator on a sparse matrix, but equal to XY. ","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Same way, you can send LatticeArrays to your GPU by calling @on_lattice cu(XY) from CUDA.jl.","category":"page"},{"location":"lattice_values/#LatticeValue-basics","page":"Wavefunctions and density matrices","title":"LatticeValue basics","text":"","category":"section"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"A LatticeValue is a struct that maps sites of a certain Lattice to values of some type.  One can be generated using a do-syntax similar to one in Sublattices:","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"using LatticeModels, Plots","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"l = SquareLattice(10, 10)\nlv = LatticeValue(l) do (x, y); x + y + 1; end    # arbitrary site-dependent\nlv2 = rand(l)                               # uniformly distributed random numbers\nlv3 = randn(l)                              # normally distributed random numbers\nlv4 = ones(l)                               # 1 on all sites. Also zeros(l) is possible","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"To generate a tuple of LatticeValues for site coordinates, you can use the coord_values function. Note that LatticeValues support broadcasting, which means you can create coordinate-dependent lattice values in-place:","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"x, y = coord_values(l)\nlv == x .+ y .+ 1","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"note: Note\nA wavefunction cannot and must not be stored as a LatticeValue, use LatticeVector instead.  The reason is that a LatticeValue does not take one-site phase spaces into account, which renders them unusable for these purposes.Linear algebra operations and @on_lattice wrapping are deliberately unsupported for LatticeValues.","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"Lattice values implement a scatter plot recipe, which colors the plot markers according to the value:","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"scatter(lv, markersize=10)","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"Depending on the lattice type, additional plot recipes can be available. For example, a lattice value on a square lattice can be plotted as a heatmap (which will be enabled by default if you do not specify the series type):","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"plot(lv, markersize=10)","category":"page"},{"location":"lattice_values/#Indexing","page":"Wavefunctions and density matrices","title":"Indexing","text":"","category":"section"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"It is often required to select some sites by certain condition.  This can be done using a LatticeValue{Bool} and broadcasting (like with Sublattices).","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"In the example below we will delete all sites from the circle of radius 3 in the center of the lattice  (which will make the according heatmap regions blank).","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"heatmap(lv[@. √(x^2 + y^2) ≥ 10])","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"The approach from above provides a flexible way to edit LatticeValues:","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"lv2 = ones(l)\nlv2[@. x < y] = x .* y          # Assign another LatticeValue\nlv2[@. x ≥ y && x ≥ -y] .= 20   # or a number\nheatmap(lv2)","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"Note that a LatticeValue can be projected to some coordinate axis to create line plots. The projection axis is set by an axis descriptor (see Axis descriptors)","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"lv_on_line = lv[x = 5]\np = plot(layout=(2, 1))\n\nheatmap!(p[1], lv)\nplot!(p[1], lattice(lv_on_line), high_contrast=true)\nplot!(p[2], project(lv_on_line, :y))","category":"page"},{"location":"lattice_values/","page":"Wavefunctions and density matrices","title":"Wavefunctions and density matrices","text":"Note that we can show the sites we selected by plotting the lattice of the selected values with high_contrast=true. This options hides the indices and translucent marks, and also makes the plot markers black-and-white, which prevents them from blending in with the heatmap in the background.","category":"page"}]
}

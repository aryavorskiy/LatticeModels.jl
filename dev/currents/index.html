<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Currents · LatticeModels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LatticeModels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Advanced options</span><ul><li><a class="tocitem" href="../lattice/">Defining a lattice</a></li><li><a class="tocitem" href="../lattice_values/">Lattice values</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li class="is-active"><a class="tocitem" href>Currents</a><ul class="internal"><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Materialized-currents"><span>Materialized currents</span></a></li><li><a class="tocitem" href="#Mapping-currents"><span>Mapping currents</span></a></li></ul></li><li><a class="tocitem" href="../evolution/">Unitary evolution</a></li></ul></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced options</a></li><li class="is-active"><a href>Currents</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Currents</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/currents.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>An <a href="@ref"><code>AbstractCurrents</code></a> object is a lazy object that can calculate any current-like value between any pair of sites.  Usage is pretty simple:</p><pre><code class="language- hljs">l = SquareLattice(10, 10)
H = tightbinding_hamiltonian(l, field = FluxField(1, (5.5, 5.5)))
P = densitymatrix(diagonalize(H), μ = -0.5)

curr = DensityCurrents(H, P)                    # Create Currents object
heatmap(lattice_density(P))
plot!(curr, arrows_scale=25, arrows_rtol=0.1, color=:blue)    # Quiver-plot the currents</code></pre><p>What happened here? The formula for the density current from site <span>$i$</span> to site <span>$j$</span> is <span>$J_{ij} = \text{tr}(-i \hat{h}_{ij} \hat{c}^\dagger_i \hat{c}_j \hat{\rho} + h. c.) = 2 \text{Im tr}(\hat{h}_{ij} \hat{c}^\dagger_i \hat{c}_j \hat{\rho})$</span>.  The <code>curr</code> object contains this formula inside and when this object is passed to the <code>plot</code> function, all needed currents are evaluated.</p><p>A current between each pair of sites is shown as an arrow directed from one to another with its length proportional to the strength of the current. The <code>arrows_scale</code> keyword argument scales all arrows by given factor, while <code>arrows_rtol</code> hides all arrows that are shorter than some fraction of the distance between the sites.</p><p>You can display currents between certain sites by using a boolean-typed <code>LatticeValue</code> and bracket-notation:</p><pre><code class="language- hljs">x, y = coord_values(l)
sub_curr = curr[x .&lt; y]
plot!(sub_curr, arrows_scale=25, arrows_rtol=0.1, color=:green)</code></pre><p>Here all currents <strong>between</strong> sites in the upper-left coordinate triangle are marked green.</p><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>It is quite likely that you might want to define your own type of currents. All you need to do is inherit the <code>AbstractCurrents</code> type and define two functions:</p><ul><li><code>lattice(::MyCurrents)</code> must return the lattice which the currents are defined on</li><li><code>Base.getindex(::MyCurrents, i::Int, j::Int)</code> must return the current between sites with indices <code>i</code> and <code>j</code>. Note that the function must be skew-symmetric, e. g. <code>curr[i, j] == -curr[j, i]</code>.</li></ul><h2 id="Materialized-currents"><a class="docs-heading-anchor" href="#Materialized-currents">Materialized currents</a><a id="Materialized-currents-1"></a><a class="docs-heading-anchor-permalink" href="#Materialized-currents" title="Permalink"></a></h2><p>An <code>AbstractCurrents</code> is a lazy object. This allows to avoid excessive computation of site-to-site currents, but the computations that are needed will be repeated every time when we access that object; also abstract currents cannot be normally stored into a <code>TimeSequence</code> (more precisely, you won&#39;t be able to differentiate or integrate such currents over time). That&#39;s where the <code>MaterializedCurrents</code> come in, having all their values stored explicitly in an array.</p><p>To convert any type of currents to <code>MaterializedCurrents</code>, simply use the <a href="../library/#LatticeModels.materialize-Tuple{LatticeModels.AbstractCurrents}"><code>materialize</code></a> function. You can avoid evaluating some currents (for example, if you know beforehand that they must be zero) by passing a lambda as a first argument (or with <code>do</code>-syntax): it must take the <code>Lattice</code> and two <code>LatticeSite</code>s and return whether the current between these sites must be evaluated.</p><p>You can find it similar to the selector function we used back in <a href="@ref Hopping-operators">Hopping operators</a>, which indeed is. You may find the following selector functions useful:</p><ul><li>Passing a <code>PairSet</code> produced by the <a href="@ref"><code>bonds</code></a> function will keep only the currents between adjacent sites.</li><li><a href="../library/#LatticeModels.pairs_by_distance-Tuple{Any}"><code>pairs_by_distance</code></a> will allow you to select pairs of sites depending on the distance between them. </li></ul><h2 id="Mapping-currents"><a class="docs-heading-anchor" href="#Mapping-currents">Mapping currents</a><a id="Mapping-currents-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-currents" title="Permalink"></a></h2><p>In some cases we want to find out how currents depend on some lattice properties: for example, the distance between sites. In such case, the <a href="../library/#LatticeModels.map_currents-Tuple{Function, LatticeModels.AbstractCurrents}"><code>map_currents</code></a> function can be quite helpful.</p><p>Let&#39;s find the mean and the standard deviation for currents between sites given the distance between them:</p><pre><code class="language- hljs">using LinearAlgebra, Statistics

dist, adcurr = map_currents(
    curr, 
    reduce_fn=(x -&gt; [mean(abs.(x)), std(abs.(x))]),
    sort=true
) do l, site1, site2
    norm(site1.coords - site2.coords)
end

acurr, dcurr = eachcol(adcurr)
scatter(dist, acurr, err=dcurr, xlims=(0, 14))</code></pre><p>What happened here? The <code>map_currents</code> function found the distance and the current between each pair of sites. Then for each distance between sites it found the mean and standard deviation for the absolute value of the currents in such pairs, and stored it column-wise in a matrix automatically. In the next line we extracted the mean and standard deviation into separate lists, and plotted the obtained data.</p><p>From this picture we can see that there are no density currents between non-adjacent sites, as one must have expected.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../operators/">« Operators</a><a class="docs-footer-nextpage" href="../evolution/">Unitary evolution »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 5 September 2023 20:13">Tuesday 5 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

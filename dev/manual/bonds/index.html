<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding bonds · LatticeModels.jl</title><meta name="title" content="Adding bonds · LatticeModels.jl"/><meta property="og:title" content="Adding bonds · LatticeModels.jl"/><meta property="twitter:title" content="Adding bonds · LatticeModels.jl"/><meta name="description" content="Documentation for LatticeModels.jl."/><meta property="og:description" content="Documentation for LatticeModels.jl."/><meta property="twitter:description" content="Documentation for LatticeModels.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LatticeModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattice/">Defining the lattice</a></li><li class="is-active"><a class="tocitem" href>Adding bonds</a><ul class="internal"><li><a class="tocitem" href="#General-bonds"><span>General bonds</span></a></li><li><a class="tocitem" href="#Translations"><span>Translations</span></a></li><li><a class="tocitem" href="#boundary_conditions"><span>Boundary conditions</span></a></li><li><a class="tocitem" href="#Generic-lattice"><span>Generic lattice</span></a></li></ul></li><li><a class="tocitem" href="../latticevalue/">Working with data</a></li><li><a class="tocitem" href="../hamiltonian/">Constructing the Hamiltonian</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../greenfunction/">Green&#39;s function</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li><a class="tocitem" href="../evolution/">Unitary evolution</a></li></ul></li><li><a class="tocitem" href="../../internals/">Internals</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Adding bonds</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adding bonds</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/manual/bonds.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Adjacency-and-boundary-conditions"><a class="docs-heading-anchor" href="#Adjacency-and-boundary-conditions">Adjacency and boundary conditions</a><a id="Adjacency-and-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Adjacency-and-boundary-conditions" title="Permalink"></a></h1><p>This chapter describes how to define bonds between sites in a lattice and how to use them to define boundary conditions.</p><h2 id="General-bonds"><a class="docs-heading-anchor" href="#General-bonds">General bonds</a><a id="General-bonds-1"></a><a class="docs-heading-anchor-permalink" href="#General-bonds" title="Permalink"></a></h2><p>There are several ways to define bonds between sites in a lattice. The most general way is to define a function that takes two sites and returns if they are connected. </p><p>A direct implementation of this approach is the <a href="../../library/#LatticeModels.AdjacencyMatrix"><code>AdjacencyMatrix</code></a>. It is a simple wrapper around a boolean-valued matrix.</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = SquareLattice(4, 4)

# Define a nearest neighbor adjacency matrix
adj = AdjacencyMatrix(l, NearestNeighbor())

# Let&#39;s disconnect the center sites from the rest vertically
for x in 2:3
    site1 = l[x=x, y=2]
    site2 = l[x=x, y=1]
    adj[site1, site2] = false

    site3 = l[x=x, y=3]
    site4 = l[x=x, y=4]
    adj[site3, site4] = false
end

plot(adj)                   # Plot what we&#39;ve got
plot!(l, showbonds=false)   # And the lattice itself</code></pre><img src="54720e2c.svg" alt="Example block output"/><p>As you can see, the adjacency matrix is a writable object, so you can change the bonds as you like. In this example we deleted vertical bonds between the four center sites and the boundary of the lattice.</p><p>There are many ways to create an adjacency matrix — for example, you can use a function that takes two sites and returns if they are connected. This is useful when you need to define bonds in a more complex way:</p><pre><code class="language-julia hljs">adj2 = AdjacencyMatrix(l) do site1, site2
    dx = site1.x - site2.x
    dy = site1.y - site2.y
    return abs(dx * dy) == 1    # Diagonal bonds
end
plot(adj2)
plot!(l, showbonds=false)</code></pre><img src="0d9b91a5.svg" alt="Example block output"/><h2 id="Translations"><a class="docs-heading-anchor" href="#Translations">Translations</a><a id="Translations-1"></a><a class="docs-heading-anchor-permalink" href="#Translations" title="Permalink"></a></h2><p>A &quot;translation&quot; is a special type of bonds that has a distinct direction (e. g. each pair of sites consists of a &quot;source&quot; and a &quot;target&quot; site). Also it must define exactly one destination for each source site (if any).</p><p>An example is the <a href="../../library/#LatticeModels.Translation"><code>Translation</code></a> — it allows defining bonds between sites that are shifted by a certain vector. </p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = GrapheneRibbon(6, 4)        # A convenient constructor for a honeycomb lattice
tr = Translation(l, [1, 2√3/3])
plot(tr)
plot!(l, ls=:dash, linecolor=:grey)</code></pre><img src="a015ab3f.svg" alt="Example block output"/><p>Another type of translation is the <a href="../../library/#LatticeModels.BravaisTranslation"><code>BravaisTranslation</code></a>. It translates sites on a Bravais lattice in terms of the lattice vectors:</p><pre><code class="language-juila hljs">tr2 = BravaisTranslation(1 =&gt; 2, [0, 1])
tr1 == tr2  # true</code></pre><p>What does this notation mean? We take the first site in the unit cell; then we go to the unit cell shifted by <code>[0, 1]</code> and take the second site from there. Note that the first example described the same translation, but in terms of positions, not unit cell indices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You can omit the pair of indices if you want to translate the unit cell regardless of the site index.  <code>Bravais[j1, j2, ...]</code> is shorthand for <code>BravaisTranslation([j1, j2, ...])</code>.    </p></div></div><p>You can use translations to shift a site, for example: <code>site2 = site1 + tr</code>, just like with regular vectors. Another  use-case for translations is in defining boundary conditions, as we will see in the next section.</p><h2 id="boundary_conditions"><a class="docs-heading-anchor" href="#boundary_conditions">Boundary conditions</a><a id="boundary_conditions-1"></a><a class="docs-heading-anchor-permalink" href="#boundary_conditions" title="Permalink"></a></h2><p>The most general form of boundary conditions supported by this package is this:</p><p class="math-container">\[\psi(r + R) = \psi(r) f(r)\]</p><p>where <code>R</code> is a translation vector and <code>f</code> is some function. This is a generalization of periodic boundary conditions, which are a special case of this form.</p><p>These conditions are in fact applied not to the lattice itself, but to the Hamiltonian. Think of it as a way to replace the <span>$c(r)^\dagger c(r&#39;)$</span> hopping with <span>$c(r)^\dagger c(r&#39; - R) f(r&#39;)$</span>, if the <span>$r&#39;$</span> site is not present in the lattice, but <span>$r&#39; - R$</span> is.</p><p>In general, there are three types of boundary conditions:</p><ul><li><a href="../../library/#LatticeModels.PeriodicBoundary-Tuple{Any}"><code>PeriodicBoundary</code></a> — the most common type of boundary conditions. Just periodicity with no factor.</li><li><a href="../../library/#LatticeModels.TwistedBoundary"><code>TwistedBoundary</code></a> — periodicity with a phase factor that does not depend on <span>$r$</span>.</li><li><a href="../../library/#LatticeModels.FunctionBoundary"><code>FunctionBoundary</code></a> —  general form of boundary conditions.</li></ul><p>The constructor for the boundary accepts two arguments — the phase (or the function) and the translation. </p><p>As an example, let us consider the example with the Hofsadter butterfly from the <a href="../../examples/#Examples">Examples</a> page. The magnetic field <code>B</code> changes from zero to one flux quantum per plaquette, for each value of <code>B</code> we calculate the energy spectrum of an infinite lattice and plot it. </p><p>Let&#39;s consider a periodic lattice instead. We want to apply magnetic field in the Landau gauge to it, and since  the translation operators include the vector potential <span>$\mathcal{A}$</span>, we have to tweak the boundary conditions a little:</p><p class="math-container">\[\psi(x + L_x, y) = \psi(x, y) e^{2\pi i B y L_x},
\psi(x, y + L_y) = \psi(x, y)\]</p><p>This can be done with the <code>FunctionBoundary</code>:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = HoneycombLattice(10, 10)
Lx = 10
Ly = 5√3
n_plaquettes = 100
B_step = 1 / (Lx * Ly)          # Field step: one flux quantum through all plaquettes
B_max = n_plaquettes * B_step   # Until one flux quantum per plaquette

points_E = Float64[]
points_B = Float64[]
for B in 0:B_step:B_max
    f(site) = exp(2π * im * B * site.y * Lx)
    xboundary = FunctionBoundary(f, [Lx, 0])
    yboundary = PeriodicBoundary([0, Ly])
    lb = setboundaries(l, xboundary, yboundary)
    H = tightbinding_hamiltonian(lb, field=LandauGauge(B))
    dg = diagonalize(H)
    append!(points_E, dg.values)
    append!(points_B, fill(B, length(dg.values)))
end
scatter(points_B, points_E, xlabel=&quot;B&quot;, ylabel=&quot;E&quot;, leg=false, ms=1)</code></pre><img src="5682c782.svg" alt="Example block output"/><p>Note that we could have set the boundary conditions to the lattice in one line. In fact, we already did this in the Examples section:</p><pre><code class="language-julia hljs">lb = setboundaries(l, [Lx, 0] =&gt; f, [0, Ly] =&gt; true)</code></pre><p>Let&#39;s explain this notation:</p><ul><li>Each pair consists of a translation on the left and a &quot;boundary specifier&quot; on the right. A simple vector, like here, is interpreted as a <a href="../../library/#LatticeModels.Translation"><code>Translation</code></a> — you can use any translation type here, <code>Bravais[-5, 10]</code> instead of <code>[0, Ly]</code> would work as well.</li><li>The second argument can be one of the following:<ul><li><code>true/false</code> — a periodic or open boundary condition.</li><li>A number <code>θ</code> — a twisted boundary condition with a phase factor <code>exp(im * θ)</code>.</li><li>A function <code>f</code> — a general boundary condition.</li></ul></li><li>Sometimes the lattice includes default translation axes, and you can use their aliases as translations.  For example, for a 10x10 square lattice <code>setboundaries(l, :axis1 =&gt; f, :axis2 =&gt; true)</code> is equivalent to <code>setboundaries(l, [10, 0] =&gt; f, [0, 10] =&gt; true)</code>.</li></ul><p>Note that you can pass boundary conditions to the lattice constructor as well. We could not do this in the previous example, because the boundary conditions depended on the magnetic field <code>B</code>. However, if you have a fixed boundary condition, you can pass it to the lattice constructor like this:</p><pre><code class="language-julia hljs">lb = HoneycombLattice(10, 10, boundaries=([Lx, 0] =&gt; f, [0, Ly] =&gt; true))</code></pre><p>This is equivalent to the <code>setboundaries</code> call from the previous example. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In our example we imposed periodic boundary conditions in shape of a rectangle <span>$0 &lt; x &lt; L_x$</span>, <span>$0 &lt; y &lt; L_y$</span>. However, the lattice itself is more like a parallelogram, because of its unit cell shape. This is not a problem, because this shape is still periodic in terms of these translations along x and y.</p><p>If the periodicity is violated, for example, if the both <code>r</code> and <code>r + R</code> sites are present in the lattice, an error will be thrown.</p></div></div><h2 id="Generic-lattice"><a class="docs-heading-anchor" href="#Generic-lattice">Generic lattice</a><a id="Generic-lattice-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-lattice" title="Permalink"></a></h2><p>The <code>GenericLattice</code> is a tool you might want to use if you need to define a lattice with a more complex geometry. It is basically just a collection of arbitrary sites. As an example, let&#39;s define a lattice with a naive random geometry:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = GenericLattice{2}()         # 2D lattice
for i in 1:100
    pt = rand(2) * 5
    md = minimum(site -&gt; norm(pt - site.coords), l, init=1.0)
    md &gt; 0.5 &amp;&amp; push!(l, pt)    # Add a site if it is far enough from the others
end
l2 = setboundaries(l)
bonds = SiteDistance(&lt;(1), l2)  # Connect sites that are closer than 0.5
plot(bonds)
plot!(l2)       # Unlike Bravais lattices, GenericLattice does not have default bonds</code></pre><img src="269db640.svg" alt="Example block output"/><p>This tool is not very mature yet, but it can be useful for tasks not related to Braavais lattices. Note that boundary conditions can be set to the <code>GenericLattice</code> as well.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lattice/">« Defining the lattice</a><a class="docs-footer-nextpage" href="../latticevalue/">Working with data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Monday 18 March 2024 01:49">Monday 18 March 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

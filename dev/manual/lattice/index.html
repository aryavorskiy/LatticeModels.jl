<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Defining the lattice · LatticeModels.jl</title><meta name="title" content="Defining the lattice · LatticeModels.jl"/><meta property="og:title" content="Defining the lattice · LatticeModels.jl"/><meta property="twitter:title" content="Defining the lattice · LatticeModels.jl"/><meta name="description" content="Documentation for LatticeModels.jl."/><meta property="og:description" content="Documentation for LatticeModels.jl."/><meta property="twitter:description" content="Documentation for LatticeModels.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LatticeModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Defining the lattice</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Sites"><span>Sites</span></a></li><li><a class="tocitem" href="#Custom-UnitCell"><span>Custom <code>UnitCell</code></span></a></li><li><a class="tocitem" href="#Shapes"><span>Shapes</span></a></li><li><a class="tocitem" href="#Multi-dimensional-lattices"><span>Multi-dimensional lattices</span></a></li><li><a class="tocitem" href="#Bonds-and-hoppings"><span>Bonds and hoppings</span></a></li></ul></li><li><a class="tocitem" href="../bonds/">Adding bonds</a></li><li><a class="tocitem" href="../latticevalue/">Working with &#39;LatticeValue&#39;s</a></li><li><a class="tocitem" href="../hamiltonian/">Constructing the Hamiltonian</a></li><li><a class="tocitem" href="../operators/">States and Operators</a></li><li><a class="tocitem" href="../greenfunction/">Green&#39;s function</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li><a class="tocitem" href="../evolution/">Evolution</a></li></ul></li><li><a class="tocitem" href="../../library/">API</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Defining the lattice</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Defining the lattice</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/manual/lattice.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Lattices"><a class="docs-heading-anchor" href="#Lattices">Lattices</a><a id="Lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Lattices" title="Permalink"></a></h1><p>This chapter describes the basic functionality of this package — creating and manipulating lattices.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>Creating a lattice is simple. If you want to work with Bravais lattices, there are plenty of predefined types in the package. For example, to create a square lattice, you can use the <code>SquareLattice</code> type:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = SquareLattice(10, 10)
plot(l)</code></pre><img src="7a8b2637.svg" alt="Example block output"/><p>This will create a 10x10 square lattice. Note that you can create a plot by simply using the <code>plot</code> function from the <code>Plots</code> package.</p><p><code>SquareLattice(10, 10)</code> notation means that we take a square lattice unit cell and translate it 10 times in the x and y directions. This syntax can be extended a little bit:</p><pre><code class="language-julia hljs">l = HoneycombLattice(-2:2, -2:2)
plot(l)
plot!(l[j1 = 0, j2 = 0], c=:red, ms=6)</code></pre><img src="3fa3b52f.svg" alt="Example block output"/><p>What happened here? We created a honeycomb lattice by translating the unit cell from -2 to 2 in both directions. Then we plotted the lattice and highlighted the unit cell at the origin to make it more visible. <code>l[j1 = 0, j2 = 0]</code> allowed us selecting part of the lattice by specifying the indices of the unit cell (<code>j1</code> and <code>j2</code> are the indices of the unit cell in the first and second directions, respectively).</p><p>If we need to create a lattice with a less trivial shape, we can use any function we need:</p><pre><code class="language-julia hljs">l = TriangularLattice(-10:10, -10:10) do site
    return 4 &lt; sqrt(site.x^2 + site.y^2) &lt; 8     # Create a ring-shaped lattice
end
plot(l)</code></pre><img src="e2faf2a8.svg" alt="Example block output"/><p>Here the lattice constructor first translated the unit cell from -10 to 10 in both directions, and then applied the function to each site to create a ring-shaped lattice. This is similar to the <code>filter</code> function in Julia — in fact, you can use <code>filter</code> or <code>filter!</code> on an existing lattice to create a new one as well.</p><p>There are other things you can control when creating a lattice, such as the lattice offset &amp; rotation.</p><pre><code class="language-julia hljs">l1 = SquareLattice(-2:2, -2:2)
l2 = SquareLattice(-2:2, -2:2, offset=:centeralign)
l3 = SquareLattice(-2:2, -2:2, rotate=pi/3, offset=[6, -1.5])
plot(l1, lab=&quot;No offset&quot;, shape=:circle)
plot!(l2, lab=&quot;Center the unit cell&quot;, shape=:star)
plot!(l3, lab=&quot;Shifted and rotated by π/3&quot;, shape=:square)</code></pre><img src="fd341959.svg" alt="Example block output"/><p>To find out more about offset and rotation, see <a href="../../library/#LatticeModels.UnitCell"><code>UnitCell</code></a> — the keywords are described there.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you use both offset/rotation and a function to create a lattice, the function will be applied to the sites <strong>after</strong> the offset/rotation is applied. Use the <code>postoffset</code> and <code>postrotate</code> keywords to control the position and orientation of the lattice after the function is applied.</p></div></div><p>The lattices implement the <code>AbstractSet</code> interface, so you can use all the set operations on them — <code>union</code>, <code>intersect</code>, <code>setdiff</code> etc.</p><pre><code class="language-julia hljs">l1 = SquareLattice(-2:0, -2:0)
l2 = SquareLattice(0:2, 0:2)
l3 = SquareLattice(-3:3, -3:3)
l = setdiff(l3, union(l1, l2))
plot(l)
plot!(union(l1, l2), showbonds=false, alpha=0.3)</code></pre><img src="1d98fb6b.svg" alt="Example block output"/><h2 id="Sites"><a class="docs-heading-anchor" href="#Sites">Sites</a><a id="Sites-1"></a><a class="docs-heading-anchor-permalink" href="#Sites" title="Permalink"></a></h2><p>Let&#39;s find out what sites actually are. A site is generally a point in the lattice. It is defined by its position in space and maybe some additional properties. In case of a Bravais lattice these additional properties are unit cell indices and the index <em>in</em> the unit cell.</p><p>A lattice is generally a set-like structure that allows indexing. Let&#39;s take a closer look in the REPL:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LatticeModels, Plots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l = HoneycombLattice(-2:2, -2:2)</code><code class="nohighlight hljs ansi" style="display:block;">50-site 2-dim Bravais lattice with 2-site basis in 2D space
Unit cell:
  Basis site coordinates:
    ┌      ┐ ┌      ┐
    │ 0.000│ │ 0.500│
    │ 0.000│ │ 0.289│
    └      ┘ └      ┘
  Translation vectors:
    ┌      ┐ ┌      ┐
    │ 1.000│ │ 0.500│
    │ 0.000│ │ 0.866│
    └      ┘ └      ┘
Lattice type: HoneycombLattice
Default translations:
  :axis1 → Bravais[5, 0]
  :axis2 → Bravais[0, 5]
Nearest neighbor hoppings:
  0.57735 =&gt;
    1 =&gt; 2, [0, -1]
    1 =&gt; 2, [-1, 0]
    1 =&gt; 2, [0, 0]
  1.00000 =&gt;
    Bravais[1, -1]
    Bravais[1, 0]
    Bravais[0, 1]
  1.15470 =&gt;
    1 =&gt; 2, [-1, -1]
    1 =&gt; 2, [1, -1]
    1 =&gt; 2, [-1, 1]
Boundary conditions: none</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; site = l[1]     # Get the first site</code><code class="nohighlight hljs ansi" style="display:block;">2-dim Bravais lattice site in 2D space at [-3.0, -1.7320508075688772]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; site.x          # Get the x-coordinate of the site</code><code class="nohighlight hljs ansi" style="display:block;">-3.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; site.j2         # Get the second index of the unit cell</code><code class="nohighlight hljs ansi" style="display:block;">-2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; site.index      # Get the index of the site in the unit cell</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x, y = site     # Destructure the site</code><code class="nohighlight hljs ansi" style="display:block;">2-dim Bravais lattice site in 2D space at [-3.0, -1.7320508075688772]</code></pre><p>As we see, we can access the properties of the site simply as fields of the site object. We can also destructure the site to get its coordinates.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.8</header><div class="admonition-body"><p>Accessing the properties of the site as fields like <code>site.x</code> requires Julia 1.8 and later. This limitation is imposed with purpose, since this seriously affects runtime performance in earlier versions. You will still be able to destructure the site to get its coordinates, or use the following fields:</p><ul><li><code>site.coords</code> — the position of the site</li><li><code>site.latcoords</code> — the unit cell indices</li><li><code>site.index</code> — the index of the site in the unit cell</li></ul></div></div><p>Properties like <code>x</code>, <code>j1</code>, <code>index</code> etc. are part of a general <code>SiteProperty</code> interface. You can use them to create &#39;slices&#39; of lattices:</p><pre><code class="language-julia hljs">slice = l[j1 = 0 .. 2, j2 = -2 .. 0, index=1]  # Get a slice of the lattice
plot(l)
plot!(slice, c=:red, ms=6)</code></pre><img src="30f37d0d.svg" alt="Example block output"/><p>Here <code>0 .. 2</code> and <code>-2 .. 0</code> are intervals defining the ranges of the unit cell indices. You can use any collection instead of then if you need.</p><p>Finding sites by their properties can be done with the same notation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; l[x = 1.5, y = √3/2]    # Find the site with x = 1.5 and y = √3/2</code><code class="nohighlight hljs ansi" style="display:block;">2-dim Bravais lattice site in 2D space at [1.5, 0.8660254037844386]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l[x = 1.2, y = 3]       # No such site, throws an error</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: BoundsError: attempt to access 50-site HoneycombLattice in 2D space at index [(x = 1.2, y = 3)]</code></pre><p>This is notation is convenient yet type-unstable, since it returns a <code>Site</code> object if there is one site satisfying the condition — otherwise a lattice is returned. To make sure that the result is indeed a site, add <code>!</code> to the beginning of the condition:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; l[!, x = 1.5, y = √3/2]    # Find the site with x = 1.5 and y = √3/2</code><code class="nohighlight hljs ansi" style="display:block;">2-dim Bravais lattice site in 2D space at [1.5, 0.8660254037844386]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l[!, x = 1.5]              # More than one site, throws an error</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: More than one site satisfies parameter conditions</code></pre><p>Note that <strong>pair notation</strong> is also supported. You can use it to access the properties of the site using the <code>Coord</code> and <code>LatticeCoord</code> types. For example, the following two lines are equivalent to ones above:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; l[!, Coord(1) =&gt; 1.5, Coord(2) =&gt; √3/2] # Same as l[!, x = 1.5, y = √3/2]</code><code class="nohighlight hljs ansi" style="display:block;">2-dim Bravais lattice site in 2D space at [1.5, 0.8660254037844386]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l[!, Coord(1) =&gt; 1.5]                   # Same as l[!, x = 1.5]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: More than one site satisfies parameter conditions</code></pre><p>This notation improves performance on Julia 1.7 and earlier, since it does not need any type-inference tricks to work fast. You may also find it useful when you work with multi-dimensional lattices.</p><p>Here is a short list of site properties you can use:</p><ul><li><code>x</code>, <code>y</code>, <code>z</code> — the position of the site. Alternatively, you can use <code>x1</code>, <code>x2</code>, <code>x3</code>, <code>x4</code> and so on to access the coordinates of the site in the unit cell. Use <code>Coord(i)</code> to access the <code>i</code>-th coordinate using pair notation.</li><li><code>j1</code>, <code>j2</code>, <code>j3</code> and so on — the indices of the unit cell. Use <code>LatticeCoord(i)</code> to access the <code>i</code>-th index using pair notation.</li><li><code>index</code> — the index of the site in the unit cell. Use <code>BasisIndex()</code> to access it using pair notation.</li></ul><h2 id="Custom-UnitCell"><a class="docs-heading-anchor" href="#Custom-UnitCell">Custom <code>UnitCell</code></a><a id="Custom-UnitCell-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-UnitCell" title="Permalink"></a></h2><p>You can also create a lattice from a custom unit cell:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
# This will be our custom honeycomb lattice unit cell
# First argument - vectors of the unit cell
# Second argument - radius-vectors for the sites in the unit cell
uc = UnitCell([[1/2, sqrt(3)/2] [-1/2, sqrt(3)/2]], [[0, sqrt(3)/6] [0, -sqrt(3)/6]])
plot(uc)    # Plot the unit cell</code></pre><img src="e79a4e8f.svg" alt="Example block output"/><p>Note that both arguments are actually matrices — the first one is a matrix of the unit cell vectors, and the second one is a matrix of the site positions in the unit cell. However, here we used concatenation to create the matrices for the sake of readability: remember that <code>[[a, b] [c, d]]</code> is equivalent to <code>[a c; b d]</code>.</p><p>To create a lattice, we can use the <a href="../../library/#LatticeModels.span_unitcells-Union{Tuple{NB}, Tuple{NU}, Tuple{N}, Tuple{Any, UnitCell{N, NU, NB}, Vararg{Union{Integer, OrdinalRange{&lt;:Integer, &lt;:Integer}}, NU}}} where {N, NU, NB}"><code>span_unitcells</code></a> function:</p><pre><code class="language-julia hljs">l = span_unitcells(uc, -5:5, -5:5) do site
    x, y = site
    return abs(y) &lt; 5 &amp;&amp;
        abs(y * 1 / 2 + x * sqrt(3) / 2) &lt; 5 &amp;&amp;
        abs(y * 1 / 2 - x * sqrt(3) / 2) &lt; 5
end   # Create a hex shape
plot(l)</code></pre><img src="95836e4d.svg" alt="Example block output"/><p>In fact, the constructors we discussed earlier are just a shorthand for <code>span_unitcells</code> with a predefined unit cell. You can use <code>span_unitcells</code> to create a lattice from any unit cell you want.</p><h2 id="Shapes"><a class="docs-heading-anchor" href="#Shapes">Shapes</a><a id="Shapes-1"></a><a class="docs-heading-anchor-permalink" href="#Shapes" title="Permalink"></a></h2><p>The shapes framework is a powerful tool for creating lattices of arbitrary geometry:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = SquareLattice{2}(Hexagon(10, [-10, 0]), Circle(10, [10, 0]))
plot(l)</code></pre><img src="808ed77a.svg" alt="Example block output"/><p>Here we created a square lattice in shape of a hexagon and a circle. The first argument of the shape is its radius (for the hexagon it is the distance from its center to the vortices), and the second argument is the center of the shape. Other possible shapes include <code>Box</code>, <code>Polygon</code>, <code>SiteAt</code> and <code>Path</code>.</p><pre><code class="language-julia hljs">complex_l = SquareLattice{2}(   # Here you have to specify the dimension of the lattice
    Circle(10), Circle(10, [20, 0]), Circle(10, [10, 10√3]),
    !Circle(5), !Circle(5, [20, 0]), !Circle(5, [10, 10√3]),
    Box(-5 .. 5, -14 .. -12), Box(15 .. 25, -14 .. -12),
    Path([-12, 32], [32, 32])
)
plot(complex_l)</code></pre><img src="afc9ffdb.svg" alt="Example block output"/><p>Note that adding <code>!</code> before the shape inverts it. This is useful when you need to create a lattice with a hole in it.</p><p>In some cases, the shapes may contain dangling sites. They tend to mess up the calculations, so you can remove them using the <code>removedangling</code> keyword or <a href="../../library/#LatticeModels.removedangling!"><code>removedangling!</code></a> function. By default, the software performs two passes to remove sites that are connected to only one other site, but you can specify the number of passes or set it to <code>Inf</code> to remove all dangling sites recursively:</p><pre><code class="language-julia hljs">l = HoneycombLattice(Circle(3, [0, 0]), Circle(3, [-2, 10]), Path([0, 0], [-2, 10]), removedangling=false)
p = plot(size=(800, 350), layout=(1, 2))
plot!(p[1], l, title=&quot;With dangling sites&quot;)
removedangling!(l)
plot!(p[2], l, title=&quot;Without dangling sites&quot;)</code></pre><img src="3feed4a9.svg" alt="Example block output"/><p>Let&#39;s discuss what is happening under the hood. The <code>HoneycombLattice</code> constructor calls the <a href="../../library/#LatticeModels.fillshapes-Union{Tuple{N}, Tuple{UnitCell{Sym, N} where Sym, Vararg{LatticeModels.AbstractShape}}} where N"><code>fillshapes</code></a> function, which estimates the unitcells one has to span for each shape, and adds the sites that are in the shape to the lattice. </p><p>You can also use <code>addshapes!</code> to add shapes to an existing lattice and <code>deleteshapes!</code> to remove them. These functions, however, do not support the <code>!</code> notation for inverting shapes.</p><p>One last, but not least, thing to mention is that this framework allows approximate scaling. If you need a lattice with distinct shape and, say, roughly 1000 sites, you can use the <code>sites</code> keyword to specify the number of sites you need:</p><pre><code class="language-julia hljs">l = TriangularLattice(sites=1000, Circle(1, [-1, 0]), Circle(1, [1, 0]), Circle(1, [0, √3]))
plot(l, title = &quot;$(length(l)) ≈ 1000 sites&quot;)</code></pre><img src="84fc2ffc.svg" alt="Example block output"/><p>You can also use the <a href="../../library/#LatticeModels.shaperadius-Tuple{UnitCell, LatticeModels.AbstractShape, Int64}"><code>shaperadius</code></a> function to estimate the radius of the shape that will give you the desired number of sites:<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></p><pre><code class="language-julia hljs">circ = SquareLattice{2}(Circle(), sites=150)
r = shaperadius(circ, Circle())
plot(circ, lab = &quot;$(length(circ)) ≈ 150 sites&quot;)
plot!(Circle(r), c=:grey, ls=:dash, lab = &quot;r ≈ $r&quot;)</code></pre><img src="8d8f3357.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Radius estimation is not always precise and works under following assumptions:</p><ul><li>The shapes are large enough to contain the unit cell and do not intersect with each other.</li><li>The inverted shapes are all contained in the non-inverted ones, and also do not intersect with each other.</li></ul></div></div><h2 id="Multi-dimensional-lattices"><a class="docs-heading-anchor" href="#Multi-dimensional-lattices">Multi-dimensional lattices</a><a id="Multi-dimensional-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Multi-dimensional-lattices" title="Permalink"></a></h2><p>This package supports multi-dimensional lattices. You can create a lattice of any dimension by creating a suitable unit cell first. Or by passing the required amount of axes to the lattice constructor, if the type supports it:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = SquareLattice(5, 4, 3)
plot(l)     # A 3D cubic lattice</code></pre><img src="f1bfc058.svg" alt="Example block output"/><p>Also remember that the dimensions of the lattice are not necessarily spatial dimensions. For example, you can create a bilayer Graphene lattice by defining a unit cell with two layers:</p><pre><code class="language-julia hljs"># Bilayer Graphene with shifted layers
uc = UnitCell([[1, 0, 0] [1/2, √3/2, 0]],
    [[0, 0, 0] [1/2, √3/6, 0] [0, 0, √3/3] [-1/2, -√3/6, √3/3]])
l = span_unitcells(uc, -2:2, -2:2)
plot(l, lc=:grey, zwiden=1.3)</code></pre><img src="577bd991.svg" alt="Example block output"/><p>Effectively, it is a 2D lattice in 3D space. Note that you can always project a multi-dimensional lattice or its slice to a 2D plane when plotting it:</p><pre><code class="language-julia hljs">plot(l[index=(1, 2)], axes=(:x, :y))    # Plot the first layer</code></pre><img src="8d63fb06.svg" alt="Example block output"/><h2 id="Bonds-and-hoppings"><a class="docs-heading-anchor" href="#Bonds-and-hoppings">Bonds and hoppings</a><a id="Bonds-and-hoppings-1"></a><a class="docs-heading-anchor-permalink" href="#Bonds-and-hoppings" title="Permalink"></a></h2><p>In the scope of this package, bonds are not considered part of the lattice, but rather a separate structure that connects sites. You can assign nearest-neighbour hoppings to the lattice (of course, since you can see them on the plot), but in general the lattice and the bonds are separate entities. The reasoning behind this is that in some cases you may need to use different sets of bonds for different models.</p><p>To find out more about bonds, adjacency and boundary conditions, see the next chapter: <a href="../bonds/#Adjacency-and-boundary-conditions">Adjacency and boundary conditions</a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Actually, the <code>shaperadius</code> function returns the scaling factor for the shape set. However, <code>Circle()</code> by default creates a circle with radius 1, so the scaling factor is equal to the radius of the circle.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/">« Examples</a><a class="docs-footer-nextpage" href="../bonds/">Adding bonds »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 22:08">Monday 23 September 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

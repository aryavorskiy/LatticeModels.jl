<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evolution · LatticeModels.jl</title><meta name="title" content="Evolution · LatticeModels.jl"/><meta property="og:title" content="Evolution · LatticeModels.jl"/><meta property="twitter:title" content="Evolution · LatticeModels.jl"/><meta name="description" content="Documentation for LatticeModels.jl."/><meta property="og:description" content="Documentation for LatticeModels.jl."/><meta property="twitter:description" content="Documentation for LatticeModels.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LatticeModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattice/">Defining the lattice</a></li><li><a class="tocitem" href="../bonds/">Adding bonds</a></li><li><a class="tocitem" href="../latticevalue/">Working with &#39;LatticeValue&#39;s</a></li><li><a class="tocitem" href="../hamiltonian/">Constructing the Hamiltonian</a></li><li><a class="tocitem" href="../operators/">States and Operators</a></li><li><a class="tocitem" href="../greenfunction/">Green&#39;s function</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li class="is-active"><a class="tocitem" href>Evolution</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Multiple-initial-states"><span>Multiple initial states</span></a></li><li><a class="tocitem" href="#Time-dependent-Hamiltonian"><span>Time-dependent Hamiltonian</span></a></li><li><a class="tocitem" href="#Solvers"><span>Solvers</span></a></li><li><a class="tocitem" href="#TimeSequence_chapter"><span>TimeSequence</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../library/">API</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Evolution</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Evolution</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/manual/evolution.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Evolution_chapter"><a class="docs-heading-anchor" href="#Evolution_chapter">Evolution</a><a id="Evolution_chapter-1"></a><a class="docs-heading-anchor-permalink" href="#Evolution_chapter" title="Permalink"></a></h1><p>This chapter describes several ways to work with time evolution of quantum systems on lattices. It features <a href="../../library/#Evolution"><code>Evolution</code></a> — a powerful struct that represents the time evolution of a quantum system according to the Schrödinger equation, and <code>TimeSequence</code>, which is used to store and process time-dependent data.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>The <code>Evolution</code> struct is used to represent the time evolution of a quantum system. It contains the Hamiltonian and the initial state (or states) of the system. To evaluate the time evolution, you can write this:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
lat = Chain(200)

# Define the initial state: a Gaussian wavepacket
x = coordvalue(lat, :x)
psi0 = ketstate(@. exp(-0.02 * (x - 50) ^ 2 - im * 0.3x))

# Define the Hamiltonian
H = tightbinding_hamiltonian(lat)

# Create the plot
plot(title=&quot;Gaussian wavepacket evolution&quot;, xlabel=&quot;x&quot;, yticks=:none)
# Empty plots for the legend
plot!([NaN], c = :blue, label=&quot;Re&quot;)
plot!([NaN], c = :red, label=&quot;Im&quot;)

ev = Evolution(H, psi0)
for moment in ev(0:5:50)
    psi, Ht, t = moment # Unpack to get the state, Hamiltonian and time
    plot!(real.(psi.data) .+ t / 3, c=:blue, lab=&quot;&quot;)
    plot!(imag.(psi.data) .+ t / 3, c=:red, lab=&quot;&quot;)
end
plot!()</code></pre><img src="be233918.svg" alt="Example block output"/><p>We got a pretty plot of a Gaussian wavepacket moving to the right. Let us discuss what happened here in-depth.</p><p>We set the Hamiltonian to be a constant operator. Since we perform the evolution in even time steps, and the Hamiltonian is not time-dependent, we can precompute the exponential of the Hamiltonian <span>$\hat{U} = e^{-i H t}$</span> and use it in the evolution. This is done automatically here.</p><p>The <code>Evolution</code> struct is not an iterator. Instead, it is a callable object that returns an iterator. This is done to allow for more flexibility, as you can see below.</p><p>The <code>Evolution</code> struct always yields stateful iterators. This means that the <code>psi</code> in the loop is actually the same object, and it is updated on each iteration. This is done to reduce memory allocations and improve performance. Do not edit the states in the loop, as it will affect the results.</p><p>This allows continuing the evolution from the last state. Let&#39;s stick to the previous example and add some more iterations:</p><pre><code class="language-julia hljs">for moment in ev(50:5:100)
    t = moment.t        # Get the time
    psi = moment.state  # Get the state
    # moment.H is the Hamiltonian, but it is not used here
    plot!(real.(psi.data) .+ t / 3, c=:blue, lab=&quot;&quot;)
    plot!(imag.(psi.data) .+ t / 3, c=:red, lab=&quot;&quot;)
end
plot!()</code></pre><img src="c9149829.svg" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If you do not need to iterate over a single <code>Evolution</code> object multiple times, you can use a shorthand. This notation:</p><pre><code class="language-julia hljs">for moment in Evolution(H, psi0, timedomain=0:5:50)
    # ...
end</code></pre><p>is equivalent to this:</p><pre><code class="language-julia hljs">ev = Evolution(H, psi0)
for moment in ev(0:5:50)
    # ...
end</code></pre></div></div><p>Note that we used a different notation to access the state and the time. You can use any of these two, whichever you find more convenient in your situation:</p><ul><li>Fields: <code>psi = moment.state; Ht = moment.H; t = moment.t</code></li><li>Unpacking: <code>psi, Ht, t = moment</code></li></ul><h2 id="Multiple-initial-states"><a class="docs-heading-anchor" href="#Multiple-initial-states">Multiple initial states</a><a id="Multiple-initial-states-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-initial-states" title="Permalink"></a></h2><p>The <code>Evolution</code> struct can also accept multiple initial states. Let&#39;s create two Gaussian wavepackets and evolve them:</p><pre><code class="language-julia hljs"># Define the initial states: two Gaussian wavepackets
psi0_1 = ketstate(@. exp(-0.02 * (x - 50) ^ 2 - im * 0.3x))
psi0_2 = ketstate(@. exp(-0.02 * (x - 150) ^ 2 + im * 0.3x))

p = plot(title=&quot;Two Gaussian wavepackets evolution&quot;, xlabel=&quot;x&quot;, yticks=:none)

ev = Evolution(H, psi0_1, psi0_2)     # Pass the initial states as keyword arguments
for moment in ev(0:5:50)
    psi1 = moment[1]
    psi2 = moment[2]
    t = moment.t
    plot!(abs2.(psi1.data) .+ t / 3, c=:black, lab=&quot;&quot;)
    plot!(abs2.(psi2.data) .+ t / 3, c=:green, lab=&quot;&quot;)
end
plot!()</code></pre><img src="2569fbfe.svg" alt="Example block output"/><p>Note that accessing <code>moment.state</code> will throw an error here, because there is more than one state. Instead, you can access all them as a tuple with <code>moment.states</code> or each one separately with <code>moment[1]</code>, <code>moment[2]</code>, etc. Also you can still unpack the <code>moment</code> as <code>psi1, psi2, Ht, t = moment</code>, which will do the very same thing.</p><p>The <code>Evolution</code> struct also allows assigning aliases to the states. You can do this by passing the initial states as keyword arguments. This code will produce the same result as in the previous example:</p><pre><code class="language-julia hljs">p = plot(title=&quot;Two Gaussian wavepackets evolution&quot;, xlabel=&quot;x&quot;, yticks=:none)

ev = Evolution(H, psi1=psi0_1, psi2=psi0_2)
for moment in ev(0:5:50)
    t = moment.t
    plot!(abs2.(moment.psi1.data) .+ t / 3, c=:black, lab=&quot;&quot;)
    plot!(abs2.(moment.psi2.data) .+ t / 3, c=:green, lab=&quot;&quot;)
end
plot!()</code></pre><p><code>moment.states</code> will be a named tuple with the states in this case. This way you can access the states as <code>moment.psi1</code>, <code>moment.psi2</code>, etc. You can still use indices <code>moment[1]</code>, <code>moment[2]</code> or unpack the <code>moment</code> as <code>psi1, psi2, Ht, t = moment</code>. The choice is yours.</p><h2 id="Time-dependent-Hamiltonian"><a class="docs-heading-anchor" href="#Time-dependent-Hamiltonian">Time-dependent Hamiltonian</a><a id="Time-dependent-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-Hamiltonian" title="Permalink"></a></h2><p>If the Hamiltonian is time-dependent, you can pass a function that returns the Hamiltonian at the given time. This function should accept a single argument — the time. An example of a time-dependent Hamiltonian is the one with a magnetic field that changes in time from the <a href="../../examples/#Examples">Examples section</a>:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = TriangularLattice(Circle(10), !Circle(5))
removedangling!(l)
h(B) = tightbinding_hamiltonian(l, field=PointFlux(B))
diag = diagonalize(h(0))

P_0 = densitymatrix(diag, mu = 0)
τ = 10
ht(t) = h(0.1 * min(t, τ) / τ)
ev = Evolution(ht, P_0)

anim = @animate for moment in ev(0:0.1:2τ)
    ρ, Ht, t = moment
    curr = DensityCurrents(Ht, ρ)
    plot(curr, title=&quot;t = $t&quot;, clims=(0, 0.005), size=(1000, 700))
end
gif(anim, &quot;currents.gif&quot;)</code></pre><img src="3da50f8f.gif" alt="Example block output"/><p>Here we applied magnetic field that changes in time. The flux is increased linearly from 0 to 0.1 in 10 time units, and then stays constant. The animation shows the density currents in the lattice at each time step.</p><p>To make the Hamiltonian time-dependent in the previous example, we defined a function <code>ht(t) = h(0.1 * min(t, τ) / τ)</code>. This function returns the Hamiltonian with the flux <code>0.1 * min(t, τ) / τ</code> at the given time <code>t</code>. The <code>Evolution</code> struct then uses this function to calculate the Hamiltonian at each time step.</p><p>The exponent for the time-dependent Hamiltonian is cached for each time step. This means that on the second half of the evolution interval, the exponent is calculated only once, and then reused for each time step. This improves performance. To improve it even more, you can pre-calculate the static Hamiltonian:</p><pre><code class="language-julia hljs">const H1 = h(0.1)   # Make it constant to enforce type stability
ht(t) = t &gt; τ ? H1 : h(0.1 * t / τ)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>Evolution</code> checks the Hamiltonian equality by storing a reference to the last Hamiltonian. Thes means that if you return the same object each time in the Hamiltonian function, the exponent will not be recalculated, even if you changed the Hamiltonian. To force the recalculation, wrap the return value into a <code>Ref</code>.</p><p>Note that you can also use <a href="https://docs.qojulia.org/timeevolution/timedependent-problems/#Time-dependent-operators"><code>QuantumOptics.TimeDependentOperator</code></a> interface — this might be more convenient, as it eliminates extra allocations more efficiently, and exponent caching for them is disabled by default.</p></div></div><h2 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h2><p>The <code>Evolution</code> struct can use several solvers to calculate the time evolution. You can set the solver to use explicitly this way:</p><pre><code class="language-julia hljs">ev = Evolution(CachedExp(threshold=1e-12, nztol=1e-15), H, psi0)</code></pre><p>The <a href="../../library/#LatticeModels.CachedExp"><code>CachedExp</code></a> solver is the default option, and it works in a very simple way: at each time step it calculates the exponent of the Hamiltonian <span>$\hat{U} = e^{-i H \Delta t}$</span> and applies it to the state. It also caches the exponent to avoid recalculating it if the Hamiltonian and the timestep are the same.</p><p>The exponent is calculated using a custom-implemented scaling and squaring algorithm. Contrary to the <code>exp</code> function from the <code>LinearAlgebra</code> package, it works with sparse matrices and GPU arrays also, while performance on dense matrices is comparable. However, some precision loss is possible, especially for large time steps, so you can adjust the tolerance for your case with these parameters:</p><ul><li><code>threshold</code> — the threshold for the error in the exponent calculation. Limits the number of iterations in the Taylor series expansion. The default value is <code>1e-10</code>.</li><li><code>nztol</code> — the tolerance for the zero elements in the Hamiltonian. Works only for sparse matrices — the elements with the absolute value less than <code>nztol</code> are considered zero. The default value is <code>1e-14</code>.</li></ul><p>The <code>CachedExp</code> solver is universal and works well in most cases. However, it is not the most efficient one. In some specific cases you might want to use a more specialized solver. For example, the <a href="../../library/#LatticeModels.KrylovKitExp"><code>KrylovKitExp</code></a> solver can be faster if the Hamiltonian is large, sparse and dependent on time. It uses the <code>exponentiate</code> function from the <code>KrylovKit</code> package to calculate the exponent.</p><p>Let&#39;s run some performance tests:</p><pre><code class="language-julia hljs">using LatticeModels
l = SquareLattice(40, 40)
h(B) = tightbinding_hamiltonian(l, field=LandauGauge(B))

# The initial state is the ground state of the Hamiltonian with B = 0
psi = groundstate(h(0))
τ = 10
ht(t) = h(0.1 * min(t, τ) / τ)
ts = 0:0.1:2τ
site = l[!, x = 20, y = 20]

println(&quot;CachedExp:&quot;)
# We can evaluate the density at x = 20, y = 20 in a one-liner
@time dens1 = [localdensity(moment.state)[site] for moment in
    Evolution(CachedExp(), ht, psi, timedomain=ts, showprogress=false)]
@time dens1 = [localdensity(moment.state)[site] for moment in
    Evolution(CachedExp(), ht, psi, timedomain=ts, showprogress=false)]
@time dens1 = [localdensity(moment.state)[site] for moment in
    Evolution(CachedExp(), ht, psi, timedomain=ts, showprogress=false)]

println(&quot;\nKrylovKitExp:&quot;)
@time dens2 = [localdensity(moment.state)[site] for moment in
    Evolution(KrylovKitExp(), ht, psi, timedomain=ts, showprogress=false)]
@time dens2 = [localdensity(moment.state)[site] for moment in
    Evolution(KrylovKitExp(), ht, psi, timedomain=ts, showprogress=false)]
@time dens2 = [localdensity(moment.state)[site] for moment in
    Evolution(KrylovKitExp(), ht, psi, timedomain=ts, showprogress=false)]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CachedExp:
  3.863933 seconds (184.55 k allocations: 10.844 GiB, 7.63% gc time, 5.07% compilation time)
  3.765998 seconds (75.61 k allocations: 10.837 GiB, 8.18% gc time, 1.44% compilation time)
  3.705388 seconds (75.61 k allocations: 10.837 GiB, 7.96% gc time, 1.49% compilation time)

KrylovKitExp:
  5.123325 seconds (9.27 M allocations: 962.008 MiB, 5.19% gc time, 91.06% compilation time)
  0.459550 seconds (78.03 k allocations: 389.925 MiB, 7.41% gc time, 12.89% compilation time)
  0.449005 seconds (78.03 k allocations: 389.923 MiB, 8.21% gc time, 12.42% compilation time)</code></pre><p>The first attempt took some time because of the precompilation required, but overall the <code>KrylovKitExp</code> solver turned out to be faster in this case. Let&#39;s plot the results to make sure they are the same:</p><pre><code class="language-julia hljs">using Plots
plot(ts, dens1, label=&quot;CachedExp&quot;, xlabel=&quot;t&quot;, ylabel=&quot;ρ(x=20, y=20)&quot;,
    ylims=(0, NaN), size=(800, 400))
plot!(ts, dens2, label=&quot;KrylovKitExp&quot;)</code></pre><img src="ca1a6c67.svg" alt="Example block output"/><p>A significant drawback of <code>KrylovKitExp</code> solver is that it works only with wavefunctions — it does not support density matrices.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Generally, the <code>Evolution</code> struct supports only Schrödinger/von Neumann equations. If you need to solve the master equation, you can use <a href="https://docs.qojulia.org/timeevolution/master/">the functions from the <code>QuantumOptics</code> package</a>.</p><p>However, a solver for the master equation can be implemented on top of the <code>Evolution</code> struct using this <code>EvolutionSolver</code> interface. Please file an issue if you are interested in this feature.</p></div></div><h2 id="TimeSequence_chapter"><a class="docs-heading-anchor" href="#TimeSequence_chapter">TimeSequence</a><a id="TimeSequence_chapter-1"></a><a class="docs-heading-anchor-permalink" href="#TimeSequence_chapter" title="Permalink"></a></h2><p>The <a href="../../library/#LatticeModels.TimeSequence"><code>TimeSequence</code></a> struct is used to store and manipulate time-dependent data. It is a dictionary-like object that maps time points to values. The values can be any type, including arrays, matrices, and even lattice-specific types like <code>LatticeValue</code>.</p><p>Let&#39;s calculate the evolution of a ground state of a tight-binding model after a magnetic field is adiaiabatically turned on. We will store the local density at each time step and use it to plot the local density depending on time, as well as its time derivative and integral over time:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = SquareLattice(20, 20)
h(B) = tightbinding_hamiltonian(l, field=LandauGauge(B))

# The initial state is the ground state of the Hamiltonian with B = 0
psi = groundstate(h(0))
τ = 10
ht(t) = h(0.1 * min(t, τ) / τ)
densities = TimeSequence{LatticeValue}()

for moment in Evolution(ht, psi, timedomain=0:0.1:2τ)
    densities[moment.t] = localdensity(moment.state)
end

plot(densities[!, x = 10, y = 10], label=&quot;ρ(t) (bulk)&quot;)
plot!(densities[!, x = 1, y = 10], label=&quot;ρ(t) (edge)&quot;)</code></pre><img src="35b1b1b1.svg" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The very same result could be achieved without writing the loop, using the <code>TimeSequence</code> constructor with a function. This way it will automatically iterate over the <code>Evolution</code> object and store the results:</p><pre><code class="language-julia hljs">densities = TimeSequence(Evolution(ht, psi), 0:0.1:2τ) do moment
    localdensity(moment.state)
end</code></pre></div></div><p>Note that we can index a <code>TimeSequence</code> of <code>LatticeValue</code>s the same way as a <code>LatticeValue</code> itself, which will produce another <code>TimeSequence</code> with the same time domain. This is because <code>TimeSequence</code> forwards almost all the indexing operations to the values it stores.</p><p>This type also supports time indexing and slicing. You can combine these types of indexing by using the <code>t</code> keyword for the time axis — all other arguments will be treated as spatial coordinates. Let&#39;s plot the local density at the center of the lattice and the local density at the edge of the lattice at the same time point:</p><pre><code class="language-julia hljs">p = plot(layout=2, size=(1000, 500))
plot!(p[1], densities[0.5])
plot!(p[2], densities[!, x=10, y=10, t=0.5 .. 3.5], label=&quot;ρ(t) (bulk)&quot;)
plot!(p[2], densities[!, x=1, y=10, t=5 .. 10], label=&quot;ρ(t) (edge)&quot;)</code></pre><img src="1c4381b6.svg" alt="Example block output"/><p>Another very useful feature of the <code>TimeSequence</code> is that it can be integrated and differentiated over time using the <a href="../../library/#LatticeModels.integrate-Tuple{TimeSequence}"><code>integrate</code></a> and <a href="../../library/#LatticeModels.differentiate-Tuple{TimeSequence}"><code>differentiate</code></a> functions. Let&#39;s plot the time derivative and integral of the local density in the bulk of the lattice:</p><pre><code class="language-julia hljs">densities_bulk = densities[!, x = 10, y = 10]
plot(densities_bulk, label=&quot;ρ(t) (bulk)&quot;)
plot!(differentiate(densities_bulk), label=&quot;dρ(t)/dt (bulk)&quot;)
plot!(integrate(densities_bulk), label=&quot;∫ρ(t)dt (bulk)&quot;)</code></pre><img src="dd393299.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../currents/">« Currents</a><a class="docs-footer-nextpage" href="../../library/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Monday 23 September 2024 22:08">Monday 23 September 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

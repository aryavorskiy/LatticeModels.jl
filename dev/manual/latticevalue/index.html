<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Working with &#39;LatticeValue&#39;s · LatticeModels.jl</title><meta name="title" content="Working with &#39;LatticeValue&#39;s · LatticeModels.jl"/><meta property="og:title" content="Working with &#39;LatticeValue&#39;s · LatticeModels.jl"/><meta property="twitter:title" content="Working with &#39;LatticeValue&#39;s · LatticeModels.jl"/><meta name="description" content="Documentation for LatticeModels.jl."/><meta property="og:description" content="Documentation for LatticeModels.jl."/><meta property="twitter:description" content="Documentation for LatticeModels.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LatticeModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattice/">Defining the lattice</a></li><li><a class="tocitem" href="../bonds/">Adding bonds</a></li><li class="is-active"><a class="tocitem" href>Working with &#39;LatticeValue&#39;s</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Common-operations"><span>Common operations</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li></ul></li><li><a class="tocitem" href="../hamiltonian/">Constructing the Hamiltonian</a></li><li><a class="tocitem" href="../operators/">States and Operators</a></li><li><a class="tocitem" href="../greenfunction/">Green&#39;s function</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li><a class="tocitem" href="../evolution/">Evolution</a></li></ul></li><li><span class="tocitem">Advanced usage</span><ul><li><a class="tocitem" href="../../performance/">Performance tips</a></li><li><a class="tocitem" href="../../interfaces/">Interfaces</a></li></ul></li><li><a class="tocitem" href="../../library/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Working with &#39;LatticeValue&#39;s</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Working with &#39;LatticeValue&#39;s</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/manual/latticevalue.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Working-with-LatticeValues"><a class="docs-heading-anchor" href="#Working-with-LatticeValues">Working with <code>LatticeValue</code>s</a><a id="Working-with-LatticeValues-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-LatticeValues" title="Permalink"></a></h1><p>This chapter introduces the <code>LatticeValue</code> type, which describes a value defined on the sites of a lattice. <code>LatticeValue</code> implements the <code>AbstractArray</code> interface and is used to represent quantities such as the magnetization or local density of a state.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>The <code>LatticeValue</code> type is actually a wrapper around a <code>Vector</code> of values, where each value is associated with a site of the lattice. Working with <code>LatticeValue</code> is very similar to working with a <code>Vector</code>, but with some additional functionality.</p><pre><code class="language-julia hljs">using LatticeModels, Plots

l = SquareLattice(-2:2, -2:2)
x = coordvalue(l, :x)       # get the x coordinate of the lattice sites
v = zeros(Int, l)           # create a lattice value with zeros
v[x = 1 .. 2, y = 1 .. 2] = x   # set the value to the x coordinate on the top right
v[x = -2 .. 0] .= 3           # set the value to 3 on the left half of the lattice
r = randn(l)                # create a random lattice value (normal distribution)
v2 = v .^ 2 .+ r            # broadcast operations work as expected
heatmap(v2)</code></pre><img src="29acd491.svg" alt="Example block output"/><p>The <code>LatticeValue</code> type implements basic vector creation operations: <code>zero</code>, <code>zeros</code>, <code>one</code>, <code>ones</code>, <code>rand</code>, <code>randn</code>, <code>fill</code>, <code>copy</code>. Slices and views are also supported.</p><p>There are also other <code>AbstractVector</code> methods you can use:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(abs2, v2)</code><code class="nohighlight hljs ansi" style="display:block;">1192.2130858807102</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; extrema(v2)</code><code class="nohighlight hljs ansi" style="display:block;">(-1.2081242227007074, 10.40385728986268)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; argmax(v2)</code><code class="nohighlight hljs ansi" style="display:block;">2-dim Bravais lattice site in 2D space at [-1.0, -1.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ms = findall(x -&gt; x &lt; 3, v2)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{LatticeModels.BravaisSite{2, 2, UnitCell{2, 2, 1, 4, 2}}}:
 Site at [1.0, -2.0]
 Site at [1.0, -1.0]
 Site at [1.0, 0.0]
 Site at [1.0, 1.0]
 Site at [1.0, 2.0]
 Site at [2.0, -2.0]
 Site at [2.0, -1.0]
 Site at [2.0, 0.0]
 Site at [2.0, 1.0]
 Site at [2.0, 2.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v2[first(ms)]</code><code class="nohighlight hljs ansi" style="display:block;">-0.30012541979133645</code></pre><h3 id="Indexing-and-slicing"><a class="docs-heading-anchor" href="#Indexing-and-slicing">Indexing and slicing</a><a id="Indexing-and-slicing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing-and-slicing" title="Permalink"></a></h3><p>Let&#39;s talk a bit more about the indexing and slicing of <code>LatticeValue</code>. There are several ways to index a <code>LatticeValue</code>. The return value in this case is either a scalar or another <code>LatticeValue</code> with a narrowed domain. The following indexing methods are supported:</p><ul><li><code>v[site]</code> returns the value at site <code>site</code>.</li><li><code>v[[site1, site2, ...]]</code> returns a <code>LatticeValue</code> with the values at the specified sites. <code>site1</code>, <code>site2</code>, etc. are single sites grouped into an abstract array. The return value is a <code>LatticeValue</code> with the same values but narrowed to the specified sites.</li><li><code>v[lat]</code> returns a <code>LatticeValue</code> with the same values but narrowed to the sites of lattice <code>lat</code>. <code>lat</code> here must be a lattice, which is a subset of the lattice of <code>v</code>.</li><li><code>v[mask]</code> returns a <code>LatticeValue</code> with the same values but narrowed to the sites where <code>mask</code> is <code>true</code>. <code>mask</code> here must be a <code>LatticeValue</code> of <code>Bool</code> type, defined on the same (or a superset of the) lattice.</li><li><code>v[x = 1 .. 2, y = 1 .. 2]</code> returns a <code>LatticeValue</code> with the same values but narrowed to the sites where the x coordinate is in the range <code>1 .. 2</code> and the y coordinate is in the range <code>1 .. 2</code>. The keyword arguments here must be the names of the site parameters (see <a href="../lattice/#Sites">Sites</a>), and the values can be any containers or single values. Pair notation is also supported: <code>v[Coord(1) =&gt; 1 .. 2, Coord(2) =&gt; 1 .. 2]</code>.</li></ul><p>This indexing is valid for both reading and writing. Remember, however, that the right-hand side of the assignment must be a <code>LatticeValue</code> or a scalar value (in which case the destination site must be a single site, otherwise an error will be thrown). </p><p>Therefore, <code>l[x=1, y=1] = 1</code> is not a valid assignment, because the left-hand side can contain multiple sites<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> (for example, if it is a 3D lattice). But <code>l[!, x=1, y=1] = 1</code> is a valid assignment — adding <code>!</code> to the index means that the left-hand side is a single site.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The same indexing methods can be used to slice a lattice, a <a href="../../library/#LatticeModels.GreenFunction"><code>GreenFunction</code></a>, a <a href="../../library/#LatticeModels.Currents"><code>Currents</code></a> object or a <a href="../../library/#LatticeModels.TimeSequence"><code>TimeSequence</code></a>.</p></div></div><h3 id="Iteration-and-broadcasting"><a class="docs-heading-anchor" href="#Iteration-and-broadcasting">Iteration and broadcasting</a><a id="Iteration-and-broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Iteration-and-broadcasting" title="Permalink"></a></h3><p>You can consider a <code>LatticeValue</code> as a vector of values, with its indices being the sites of the lattice. Therefore,  iterating over <code>v</code> will yield the values of the <code>LaticeValue</code>, and <code>eachindex(v)</code> will return the lattice it is defined on.</p><p>Broadcasting operations work as expected. For example, <code>v .+ 1</code> will add 1 to each value of <code>v</code>, and <code>v .+ r</code> will add the corresponding values of <code>v</code> and <code>r</code>. However, there are some limitations: you cannot broadcast a <code>LatticeValue</code> with anything other than a scalar or another <code>LatticeValue</code>. Also the lattices must be the same, otherwise an error will be thrown.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LatticeModels</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l = SquareLattice(4, 4);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x, y = coordvalues(l)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{LatticeValue{Float64, LatticeWithMetadata{LatticeModels.BravaisLattice{2, 2, UnitCell{2, 2, 1, 4, 2}}, params(:latticetype, :defaulttranslations, :nnbonds, :boundaries)}, Vector{Float64}}}:
 LatticeValue{Float64} on a 16-site SquareLattice in 2D space
 LatticeValue{Float64} on a 16-site SquareLattice in 2D space</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = zeros(l)</code><code class="nohighlight hljs ansi" style="display:block;">LatticeValue{Float64} on a 16-site SquareLattice in 2D space
Values stored in a Vector{Float64}:
[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v[x .&lt; y] = x               # This will work</code><code class="nohighlight hljs ansi" style="display:block;">LatticeValue{Float64} on a 16-site SquareLattice in 2D space
Values stored in a Vector{Float64}:
[1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v[y = 1] .= 1               # This will work</code><code class="nohighlight hljs ansi" style="display:block;">LatticeValue{Float64} on a 4-site SquareLattice in 2D space
Values stored in a SubArray{Float64, 1, Vector{Float64}, Tuple{Vector{Int64}}, false}:
[1.0, 1.0, 1.0, 1.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v[x .&gt; y] .= y              # This will not work - RHS on a different lattice</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: DimensionMismatch: array could not be broadcast to match destination</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v[x = 1] .= [1, 2, 3, 4]    # This will not work - RHS is a vector</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: cannot broadcast LatticeValue along Base.Broadcast.DefaultArrayStyle{1}()</code></pre><h2 id="Common-operations"><a class="docs-heading-anchor" href="#Common-operations">Common operations</a><a id="Common-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Common-operations" title="Permalink"></a></h2><p>There are several common use-cases for the <code>LatticeValue</code> type. We will discuss some of them here.</p><h3 id="External-parameter-of-a-system"><a class="docs-heading-anchor" href="#External-parameter-of-a-system">External parameter of a system</a><a id="External-parameter-of-a-system-1"></a><a class="docs-heading-anchor-permalink" href="#External-parameter-of-a-system" title="Permalink"></a></h3><p>In many cases, you need to define a parameter that depends on the site that is used in the Hamiltonian. For example, the on-site potential in the tight-binding model. You can use <code>LatticeValue</code> for this purpose.</p><pre><code class="language-julia hljs">using LatticeModels
l = SquareLattice(4, 4)
v = zeros(l)
v[y = 0 .. 2] .= 1.0                          # add a potential barrier
H = tightbinding_hamiltonian(l, v, t1=-1.0) # create a tight-binding Hamiltonian</code></pre><p>Here <span>$v$</span> is a <code>LatticeValue</code> that represents the on-site potential. In other models you can use it to represent the magnetic field, for example: see <a href="../../library/#LatticeModels.qwz-Tuple{LatticeValue{T} where T}"><code>qwz</code></a>.</p><h3 id="Wavefunctions"><a class="docs-heading-anchor" href="#Wavefunctions">Wavefunctions</a><a id="Wavefunctions-1"></a><a class="docs-heading-anchor-permalink" href="#Wavefunctions" title="Permalink"></a></h3><p>In some cases you need a custom-defined wavefunction. You can use <code>LatticeValue</code> for this purpose.</p><pre><code class="language-julia hljs">using LatticeModels
l = SquareLattice(10, 10)
x, y = coordvalues(l)
spin = SpinBasis(1//2)                  # create a spin basis
gauss = @. exp(-0.05 * ((x - 5.5) ^ 2 + (y - 5.5) ^ 2))
wave = @. exp(im * (x + y))             # create a plane wave
ψ = basisstate(spin, 1) ⊗ (@. gauss .* wave) + 
    basisstate(spin, 2) ⊗ (@. gauss * conj(wave))</code></pre><p>Here <code>ψ</code> is a <code>QuantumOptics.Ket</code> wavefunction. In this example it is a superposition of two states with opposite spins and different momenta.</p><p>We will discuss this theme in more detail in the [States and Operators] section.</p><h3 id="Processing-data"><a class="docs-heading-anchor" href="#Processing-data">Processing data</a><a id="Processing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-data" title="Permalink"></a></h3><p>Many observables like local density are returned as a <code>LatticeValue</code>. You can process it quite easily.</p><pre><code class="language-julia hljs">using LatticeModels, Statistics
l = HoneycombLattice(Hexagon(), sites=120)
H = tightbinding_hamiltonian(l, t1=-1.0)    # create a tight-binding Hamiltonian
dens = localdensity(groundstate(H))         # calculate the local density of the ground state
r = shaperadius(l, Hexagon())               # get the radius of the lattice
bulk = HoneycombLattice(Hexagon(r * 0.8))
edge = setdiff(l, bulk)
println(&quot;Average bulk density: &quot;, round(mean(dens[bulk]), digits=6))
println(&quot;Average edge density: &quot;, round(mean(dens[edge]), digits=6))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Average bulk density: 0.012806
Average edge density: 0.001358</code></pre><p>The average local density in the bulk is much higher than on the edge, as expected.</p><p>We will discuss this theme in more detail in the [Measurements] section.</p><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>One key feature of <code>LatticeValue</code> is that it can be visualized using the <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a> package. There are several ways to do it.</p><p>The &quot;classical&quot; way is just to use the <code>plot</code> function. The result will be a scatter plot of the lattice sites with the value of the <code>LatticeValue</code> as the color and size of the markers.</p><p>Let us continue with the previous example:</p><pre><code class="language-julia hljs">using Plots
plot(dens)</code></pre><img src="c9cb27fb.svg" alt="Example block output"/><p>This is the default behavior. You can customize the plot as usual with Plots.jl — for example, you can change the colormap, the marker size, etc. You can also set <code>markerscale=false</code> to disable the scaling of the marker size by the value of the <code>LatticeValue</code>:</p><pre><code class="language-julia hljs"># Dark theme makes everything look cooler
plot(dens, markerscale=false, markersize=12, c=:inferno,
    title=&quot;Local density of the ground state&quot;, bg=:black)</code></pre><img src="f79f973c.svg" alt="Example block output"/><p>Another way to visualize a <code>LatticeValue</code> is to use the shape plot <code>seriestype=:shape</code>, or <code>heatmap</code> function. This will create a tile plot of the lattice sites with the value of the <code>LatticeValue</code> as the color of the tiles.</p><pre><code class="language-julia hljs">heatmap(dens, title=&quot;Local density of the ground state&quot;)</code></pre><img src="390d00c8.svg" alt="Example block output"/><p>You can also pass <code>shape=:circle</code> to create a scatter plot with large circles instead of the default markers. The difference here is that the size of the circles will scale with the plot, unlike the markers in the <code>scatter</code> plot. <code>markerscale</code> is also supported here, but by default it is set to <code>false</code>.</p><p>Let&#39;s showcase all of these options:</p><pre><code class="language-julia hljs">p = plot(size=(1000, 850), layout=(2, 2))
heatmap!(p[1], dens, title=&quot;Hexagons, no scale&quot;)
heatmap!(p[2], dens, markerscale=true, title=&quot;Hexagons, scale&quot;)
heatmap!(p[3], dens, shape=:circle, title=&quot;Circles, no scale&quot;)
heatmap!(p[4], dens, shape=:circle, markerscale=true, title=&quot;Circles, scale&quot;)</code></pre><img src="990c376a.svg" alt="Example block output"/><p>Another important use case is dimension reduction. <a href="../lattice/#Multi-dimensional-lattices">Before</a> we already discussed how to plot a 2D slice of a 3D lattice. Here is an example of plotting a 1D slice of a 2D <code>LatticeValue</code>:</p><pre><code class="language-julia hljs">p = plot(size=(1000, 500), layout=(1, 2))
plot!(p[1], dens, st=:shape)
plot!(p[1], lattice(dens[j2 = 0]), :high_contrast)
plot!(p[2], dens[j2 = 0], axes=:x)</code></pre><img src="99561744.svg" alt="Example block output"/><p>By projecting <code>axes=:x</code> the selected values on <code>j2 = 0</code> (e.g. the horizontal line in the middle of the plot) are shown as a 1D plot. Also we have shown the exact line where we took the slice from by plotting the markers with the <code>:high_contrast</code> setting.</p><h3 id="Large-lattices"><a class="docs-heading-anchor" href="#Large-lattices">Large lattices</a><a id="Large-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Large-lattices" title="Permalink"></a></h3><p>The shape plot can be slow for large lattices (more than 1000 sites). The scatter plot is much faster, but the markers will overlap for large lattices, and the memory consumption for very big lattices is still very high. In this case, you can use the <code>histogram2d</code> or <code>contour</code> plots:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = HoneycombLattice(Hexagon(), sites=1_000_000)    # A really big lattice
v = LatticeValue(l) do (x, y)
    sin((x + 2y) / 30) * exp(- (x^2 + y^2) / 100^2)
end
p = plot(size=(1000, 650), layout=(2, 2))
histogram2d!(p[1], v, title=&quot;Histogram2D&quot;)
contour!(p[2], v, title=&quot;Contour&quot;)

# Decreasing the number of bins will speed up the plotting, but decrease the quality
# Set as a tuple, number or via separate keywords `xbins`, `ybins` (can be omitted)
histogram2d!(p[3], v, xbins=40, title=&quot;Histogram2D, 20x40 bins&quot;)
contour!(p[4], v, bins=(30, 30), levels=20, title=&quot;Contour, 10 levels&quot;)</code></pre><p><img src="../large_lattice.png" alt/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>heatmap</code> plot produces a shape plot, not an actual heatmap. This is more due to historical reasons than anything else. If you need a real heatmap, use the <code>histogram2d</code> plot.</p></div></div><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>This is somewhat similar to the behavior of arrays in Julia: <code>v[1:1] = 1</code> will throw an error, even though the left-hand side is a single-element array.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bonds/">« Adding bonds</a><a class="docs-footer-nextpage" href="../hamiltonian/">Constructing the Hamiltonian »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 13 February 2025 03:14">Thursday 13 February 2025</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

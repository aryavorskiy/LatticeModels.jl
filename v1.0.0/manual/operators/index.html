<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>States and Operators · LatticeModels.jl</title><meta name="title" content="States and Operators · LatticeModels.jl"/><meta property="og:title" content="States and Operators · LatticeModels.jl"/><meta property="twitter:title" content="States and Operators · LatticeModels.jl"/><meta name="description" content="Documentation for LatticeModels.jl."/><meta property="og:description" content="Documentation for LatticeModels.jl."/><meta property="twitter:description" content="Documentation for LatticeModels.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="LatticeModels.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LatticeModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../examples/">Examples</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../lattice/">Defining the lattice</a></li><li><a class="tocitem" href="../bonds/">Adding bonds</a></li><li><a class="tocitem" href="../latticevalue/">Working with &#39;LatticeValue&#39;s</a></li><li><a class="tocitem" href="../hamiltonian/">Constructing the Hamiltonian</a></li><li class="is-active"><a class="tocitem" href>States and Operators</a><ul class="internal"><li><a class="tocitem" href="#Builtins"><span>Builtins</span></a></li><li><a class="tocitem" href="#Measurements"><span>Measurements</span></a></li><li><a class="tocitem" href="#Diagonalizing"><span>Diagonalizing</span></a></li><li><a class="tocitem" href="#Density-matrix"><span>Density matrix</span></a></li></ul></li><li><a class="tocitem" href="../greenfunction/">Green&#39;s function</a></li><li><a class="tocitem" href="../currents/">Currents</a></li><li><a class="tocitem" href="../evolution/">Evolution</a></li></ul></li><li><a class="tocitem" href="../../library/">API</a></li><li><a class="tocitem" href="../../internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>States and Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>States and Operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aryavorskiy/LatticeModels.jl/blob/master/docs/src/manual/operators.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="States-and-Operators"><a class="docs-heading-anchor" href="#States-and-Operators">States and Operators</a><a id="States-and-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#States-and-Operators" title="Permalink"></a></h1><p>In the previous chapter we have seen how to define a Hamiltonian for a lattice model. In this chapter we will see how to work with other types of operators, such as measurements and diagonalizing.</p><h2 id="Builtins"><a class="docs-heading-anchor" href="#Builtins">Builtins</a><a id="Builtins-1"></a><a class="docs-heading-anchor-permalink" href="#Builtins" title="Permalink"></a></h2><p>There are some basic building blocks that can be used to create states and operators. These functions are taken from <a href="https://docs.qojulia.org/quantumobjects/operators/">QuantumOptics.jl</a> package, but extended to work with lattices:</p><ul><li><code>basisstate</code> creates a state vector in the basis of a lattice.</li><li><code>diagonaloperator</code> creates a diagonal operator in the basis of a lattice.</li><li><code>transition</code> creates a transition operator between two states in the basis of a lattice.</li><li><code>number</code>, <code>destroy</code>, and <code>create</code> are the number, annihilation, and creation operators in the basis of a lattice.</li></ul><p>Remember the general rule of thumb for working with lattices: <strong>You can provide a lattice (and optionally the internal basis) instead of a <code>QuantumOptics.Basis</code>, and a site (or a <code>(site, internal_index)</code> tuple) instead of an integer index</strong>.</p><p>For example, the <code>basisstate</code> function creates a state vector in the basis of a lattice. Normally it takes a <code>QuantumOptics.Basis</code> and an index as arguments, and returns a <code>Ket</code> object. However, you can use a lattice and a site as arguments to create a state vector in the basis of the lattice:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LatticeModels</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l = SquareLattice(6, 6);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; site = l[!, x = 3, y = 3]</code><code class="nohighlight hljs ansi" style="display:block;">2-dim Bravais lattice site in 2D space at [3.0, 3.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; l_bas, ind = LatticeBasis(l), site_index(l, site);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; psi1 = basisstate(l_bas, ind);  # The pure QuantumOptics.jl way</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; psi2 = basisstate(l, site);     # The LatticeModels.jl way</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; psi1 == psi2</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>If you work in a composite system (e. g. a lattice with a spin degree of freedom), you can either use composite indexing or construct the state as tensor product of the states for each subsystem:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; spin = SpinBasis(1//2)</code><code class="nohighlight hljs ansi" style="display:block;">Spin(1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; psi1_composite = basisstate(l, spin, (site, 1));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; psi2_composite = basisstate(spin, 1) ⊗ basisstate(l, site); # Note the order!</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; psi1_composite == psi2_composite</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The order of the tensor product is important. <strong>The first argument is the on-site degrees of freedom, and the second is the lattice</strong>. This convention is consistent in the rest of the package — the reason behind this is performance of <a href="../../library/#LatticeModels.construct_operator-Tuple{Type, System, Vararg{Any}}"><code>construct_operator</code></a> and <a href="../../library/#LatticeModels.OperatorBuilder"><code>OperatorBuilder</code></a>.</p><p>If this order is not followed, you will probably get an error somewhere in your calculations.</p></div></div><p>The <code>diagonaloperator</code> function creates a diagonal operator in the basis of a lattice. Normally it takes a <code>QuantumOptics.Basis</code> and a vector of values (or a single value) as arguments, and returns an <code>Operator</code> object. There are several convenient ways to use this function with lattices. As an example let&#39;s consider the position operator in the basis of a lattice:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; xval = coordvalue(l, :x)</code><code class="nohighlight hljs ansi" style="display:block;">LatticeValue{Float64} on a 36-site SquareLattice in 2D space
Values stored in a Vector{Float64}:
[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0  …  5.0, 5.0, 5.0, 5.0, 6.0, 6.0, 6.0, 6.0, 6.0, 6.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X_1 = diagonaloperator(l_bas, xval.values); # The pure QuantumOptics.jl way</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X_2 = diagonaloperator(l, :x);      # The LatticeModels.jl way, with a site property</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X_3 = diagonaloperator(xval);       # The LatticeModels.jl way, with a LatticeValue</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X_1 == X_2 == X_3</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>This notation allows converting any <code>LatticeValue</code> or <a href="../lattice/#Sites">Site parameter</a> to an operator. Hence, <code>diagonaloperator(l, Coord(1))</code> is also valid and will return the same operator.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Generally, a good value to create a custom diagonal operator is by using the <code>LatticeValue</code> approach. </p><p>Consider this example: in the Haldane model the diagonal part is <span>$m$</span> on the A sublattice and <span>$-m$</span> on the B sublattice. You can create this operator with the following code:</p><pre><code class="language-julia hljs">l = HoneycombLattice(6, 6)
m = 3
ms = LatticeValue(l) do site
    site.index == 1 ? m : -m
end
Op = diagonaloperator(ms)</code></pre></div></div><p>Also note the <a href="../../library/#LatticeModels.coordoperator-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}, Any}"><code>coordoperator</code></a> and <a href="../../library/#LatticeModels.coordoperators-Tuple{Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>coordoperators</code></a> functions that do the same thing as <a href="../../library/#LatticeModels.coordvalue-Tuple{LatticeModels.AbstractLattice, Int64}"><code>coordvalue</code></a> and <a href="../../library/#LatticeModels.coordvalues-Tuple{LatticeModels.AbstractLattice}"><code>coordvalues</code></a>, but return the operator instead of the value:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; X, Y = coordoperators(l);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; X == X_1</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Measurements"><a class="docs-heading-anchor" href="#Measurements">Measurements</a><a id="Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements" title="Permalink"></a></h2><p>The most common type of measurements is the local density: the average number of particles at each site. This can be calculated using the <a href="../../library/#LatticeModels.localdensity-Tuple{Union{DataOperator{var&quot;#s190&quot;, var&quot;#s190&quot;}, Bra{var&quot;#s190&quot;}, Ket{var&quot;#s190&quot;}} where var&quot;#s190&quot;&lt;:Union{LatticeBasis, CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT}}}"><code>localdensity</code></a> function — it takes a state (a <code>QuantumOptics.Ket</code> vector or a <code>QuantumOptics.Operator</code> representing the density matrix) and returns a <code>LatticeValue</code> with the density at each site.</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = GrapheneRibbon(6, 4)
H = tightbinding_hamiltonian(l)
d = localdensity(groundstate(H))
plot(d)</code></pre><img src="62129172.svg" alt="Example block output"/><p>The <code>localdensity</code> function uses the following formula to calculate the density at each site: <span>$\rho_i = \text{Tr}(\hat{n}_i \hat{\rho})$</span>, where <span>$\hat{n}_i$</span> is the number operator at site <span>$i$</span> and <span>$\hat{\rho}$</span> is the density matrix. Note that if the values are complex, the function will return the real part of them. This is what makes the next example work.</p><p>The <a href="https://arxiv.org/abs/2304.13708">local Chern marker</a> is a quantity that can be used to detect topological phases in a lattice model. It can be calculated using the following formula:</p><p class="math-container">\[\mathcal{C}(r) = 4\pi \text{Im} \langle r | P X P Y P | r \rangle\]</p><p>Here <span>$P$</span> is the projector onto the occupied states (e. g. the density matrix), and <span>$X$</span> and <span>$Y$</span> are the position operators. The local Chern marker is a real number that can be calculated for each site in the lattice.</p><p>Let&#39;s do this for a QWZ model Hamiltonian on a square lattice:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = SquareLattice(6, 6)
sys = l ⊗ SpinBasis(1//2)
ms = ones(l)
ms[x = 3 .. 4, y = 3 .. 4] .= -1
H = qwz(l, ms)

P = densitymatrix(H, mu=0, statistics=FermiDirac)
X, Y = coordoperators(sys)
c = localdensity(-4π * im * P * X * P * Y * P)
heatmap(c, title=&quot;Local Chern marker&quot;)</code></pre><img src="f99816f8.svg" alt="Example block output"/><p>A generalization of the density measurement is the <a href="../../library/#LatticeModels.localexpect-Tuple{DataOperator, Union{DataOperator{var&quot;#s188&quot;, var&quot;#s188&quot;}, Bra{var&quot;#s188&quot;}, Ket{var&quot;#s188&quot;}} where var&quot;#s188&quot;&lt;:(CompositeBasis{S, Tuple{BT, LatticeBasis{LT}}} where {S, BT, LT})}"><code>localexpect</code></a> function. It takes a local operator <span>$\hat{A}$</span> and a state, and calculates the expectation value of the operator at each site: <span>$A_i = \text{Tr}((\hat{A} \otimes \hat{n}_i) \cdot \hat{\rho})$</span>, where <span>$\hat{n}_i$</span> is the number operator at site <span>$i$</span> and <span>$\hat{\rho}$</span> is the density matrix. Note that the result is a complex numbered <code>LatticeValue</code>.</p><p>As an example, let us visualize a spin wavefunction on a square lattice:</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = SquareLattice(10, 10)
x, y = coordvalues(l)
spin = SpinBasis(1//2)
gauss = @. exp(-0.05 * ((x - 5.5) ^ 2 + (y - 5.5) ^ 2))
wave = @. exp(im * (x + y))
ψ = basisstate(spin, 1) ⊗ (@. gauss .* wave) + basisstate(spin, 2) ⊗ (@. gauss * conj(wave))
normalize!(ψ)
σx = sigmax(spin)

p = plot(layout=2, size=(800, 400))
plot!(p[1], localdensity(ψ), title=&quot;Local density&quot;)
plot!(p[2], localexpect(σx, ψ) .|&gt; real, title=&quot;σx projection&quot;)</code></pre><img src="66b0920a.svg" alt="Example block output"/><h2 id="Diagonalizing"><a class="docs-heading-anchor" href="#Diagonalizing">Diagonalizing</a><a id="Diagonalizing-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonalizing" title="Permalink"></a></h2><p>To diagonalize a Hamiltonian or any other operator, you can use the <a href="../../library/#LatticeModels.diagonalize-Tuple{Hamiltonian, Val}"><code>diagonalize</code></a> function. It takes an operator and returns a <code>EigenSystem</code> object with the eigenvalues and eigenvectors of the operator.</p><pre><code class="language-julia hljs">using LatticeModels, Plots
l = GrapheneRibbon(6, 4)
H = haldane(l, 0.1, 1)
eig = diagonalize(H)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Diagonalized Hamiltonian (48 eigenvectors)
Eigenvalues in range -4.27959 .. 4.27959
System: One particle on 48-site HoneycombLattice in 2D space</code></pre><p>This struct simplifies the access to the eigenvalues and eigenvectors of the operator. You can access the eigenvalues with <code>eig.values</code>, and eigenvectors as <code>Ket</code>s can be obtained with the bracket notation <code>eig[i]</code> or <code>eig[value = E]</code>:</p><pre><code class="language-julia hljs"># The states are sorted by real part of the eigenvalues, so
psi = eig[1]                        # `psi` is the ground state
psi2 = eig[value = 0]               # `psi2` is the state with zero energy
p = plot(layout = @layout[a b; c], size=(800, 800))
plot!(p[1], localdensity(psi), title=&quot;Ground state&quot;)
plot!(p[2], localdensity(psi2), title=&quot;Zero energy state&quot;)
scatter!(p[3], eig.values, title=&quot;Spectrum&quot;, lab=&quot;&quot;)</code></pre><img src="e24b875f.svg" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can find the ground state of a Hamiltonian in one line using the <a href="../../library/#LatticeModels.groundstate-Tuple{Any}"><code>groundstate</code></a> function:</p><pre><code class="language-julia hljs">psi = groundstate(H)</code></pre><p>To evaluate both the ground state and its energy, use the <a href="../../library/#LatticeModels.findgroundstate-Tuple{LatticeModels.HamiltonianEigensystem}"><code>findgroundstate</code></a> function:</p><pre><code class="language-julia hljs">E0, psi = findgroundstate(H)</code></pre></div></div><p>The <code>diagonalize</code> function under its hood uses the <code>eigen</code> function from the <code>LinearAlgebra</code> standard library.  However, this does not work for non-trivial matrix types (e. g. sparse matrices or GPU arrays). For such cases you  can pass the second argument to the <code>diagonalize</code> function, which is a <code>Symbol</code> indicating the method to use for  diagonalization. To use the <code>eigsolve</code> function from the <a href="https://jutho.github.io/KrylovKit.jl/stable/"><code>KrylovKit.jl</code></a>  package, you can pass <code>:krylovkit</code> as the second argument. Since this solves the eigenvalue problem iteratively, you  can also pass the keyword arguments: <code>n</code> for the number of eigenvalues to compute, <code>v0</code> for the initial guess, and  the keyword arguments for the <code>eigsolve</code> function.</p><pre><code class="language-julia hljs">l = SquareLattice(100, 100)             # A really big lattice
H = tightbinding_hamiltonian(l)
eig = diagonalize(H, :krylovkit, n=9)   # Compute only 9 eigenvalues with smallest real part
p = plot(layout=9, leg=false, size=(1000, 900))
for i in 1:9
    plot!(p[i], localdensity(eig[i]), title=&quot;E = $(round(eig.values[i], digits=5))&quot;,
        ms=2, msw=0, msa=0)             # Plot with small markers with no outline
end
plot!()</code></pre><p><img src="../gs_density.png" alt/></p><p><code>EigenSystem</code> objects have a wide range of applications in this package. One of them is creating equilibrium states for a given Hamiltonian. This can be done using the <a href="../../library/#LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.FixedMu}}"><code>densitymatrix</code></a> function, which is described in the next section.</p><h2 id="Density-matrix"><a class="docs-heading-anchor" href="#Density-matrix">Density matrix</a><a id="Density-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Density-matrix" title="Permalink"></a></h2><p>After you diagonalize a Hamiltonian, you can calculate the <a href="https://en.wikipedia.org/wiki/Density_matrix">density matrix</a> for the system. Use the <a href="../../library/#LatticeModels.densitymatrix-Tuple{LatticeModels.HamiltonianEigensystem{&lt;:LatticeModels.FixedMu}}"><code>densitymatrix</code></a> function to do this:</p><pre><code class="language-julia hljs">using LatticeModels
l = SquareLattice(6, 6)
sys = System(l, SpinBasis(1//2), mu=0, statistics=FermiDirac, T=0.1)
H = tightbinding_hamiltonian(sys)
eig = diagonalize(H)
P1 = densitymatrix(eig)                 # Use the default parameters from the `System`
P2 = densitymatrix(eig,
    statistics=BoseEinstein, T=0, mu=1) # Or you can override them</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Info: Creating density matrix: FermiDirac distribution, T = 0.1, μ = 0.0
└ set `info=false` to disable this message
┌ Info: Creating density matrix: BoseEinstein distribution, T = 0, μ = 1
└ set `info=false` to disable this message</code></pre><p>Note that the <code>densitymatrix</code> function can also be applied to a <code>Hamiltonian</code> object, in which case it will first diagonalize the Hamiltonian and then calculate the density matrix:</p><pre><code class="language-julia hljs">P1_1 = densitymatrix(H)
@assert P1 ≈ P1_1
P2_1 = densitymatrix(H, statistics=BoseEinstein, T=0, mu=1)
@assert P2 ≈ P2_1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Info: Creating density matrix: FermiDirac distribution, T = 0.1, μ = 0.0
└ set `info=false` to disable this message
┌ Info: Creating density matrix: BoseEinstein distribution, T = 0, μ = 1
└ set `info=false` to disable this message</code></pre><p>The <code>densitymatrix</code> function uses a simple formula to calculate the density matrix:</p><p class="math-container">\[\hat{\rho} = \sum_{i} \rho(E_i) | \psi_i \rangle \langle \psi_i |\]</p><p>Here <span>$E_i$</span> are the eigenvalues of the operator, <span>$\psi_i$</span> are the corresponding eigenvectors, and <span>$\rho(E)$</span> is the distribution function defined by the <code>statistics</code>, <code>T</code>, and <code>mu</code> parameters. By default, when no additional parameters are passed to the <code>System</code> or <code>densitymatrix</code>, the density matrix will be a thermal state at zero temperature.</p><p>The basis for these computations is the <a href="../../library/#LatticeModels.projector-Tuple{Any, LatticeModels.AbstractEigensystem}"><code>projector</code></a> function, which takes a function <code>p</code> and an <code>EigenSystem</code> object <code>d</code> that represents the diagonalized operator <span>$\hat{O}$</span>. The return value is an operator <span>$\hat{P}$</span> defined by the formula:</p><p class="math-container">\[\hat{O} = \sum_{i} E_i | \psi_i \rangle \langle \psi_i |, \hspace{1cm}
\hat{P} = \sum_{i} p(E_i) | \psi_i \rangle \langle \psi_i |\]</p><p>Here <span>$E_i$</span> are the eigenvalues of the operator <span>$\hat{O}$</span>, and <span>$| \psi_i \rangle$</span> are the corresponding eigenvectors. The function <code>p</code> is applied to the eigenvalues to obtain the diagonal elements of the density matrix. Here is an example of how to use this function:</p><pre><code class="language-julia hljs">l = SquareLattice(6, 6)
H = tightbinding_hamiltonian(l)
eig = diagonalize(H)
P1 = projector(x -&gt; x &lt; 0, eig)             # Projector onto the states with energy &lt; 0
P2 = projector(x -&gt; 1 / (1 + exp(x)), eig)  # Fermi-Dirac distribution
P3 = projector(eig[1:4])                    # Projector onto the first 4 states
# Note how we slice the `eig` object to get the first 4 states</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../hamiltonian/">« Constructing the Hamiltonian</a><a class="docs-footer-nextpage" href="../greenfunction/">Green&#39;s function »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 17 September 2024 00:55">Tuesday 17 September 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
